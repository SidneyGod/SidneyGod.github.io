<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sidney God</title>
  <icon>https://sidneyding.cn/icon.png</icon>
  <subtitle>Keep quiet time for time</subtitle>
  <link href="https://sidneyding.cn/atom.xml" rel="self"/>
  
  <link href="https://sidneyding.cn/"/>
  <updated>2025-06-25T15:47:22.540Z</updated>
  <id>https://sidneyding.cn/</id>
  
  <author>
    <name>Sidney Ding</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Make MyOS] Start Again</title>
    <link href="https://sidneyding.cn/posts/3f345216/"/>
    <id>https://sidneyding.cn/posts/3f345216/</id>
    <published>2025-06-25T15:41:11.000Z</published>
    <updated>2025-06-25T15:47:22.540Z</updated>
    
    <content type="html"><![CDATA[<p>主要是受打击了..md..太多不会了，又重新拾起来了，这次为了方便也不搞什么虚拟机了，所有环境完全在Win10上，主要是笔记本有点破，再搞个虚拟机有点吃不消了..所以参考了下各种教程，最终使用vscode + gdb + qemu的组合..或许qemu会换成Bochs..</p><h1 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h1><h2 id="1-1-gcc工具链"><a href="#1-1-gcc工具链" class="headerlink" title="1.1 gcc工具链"></a>1.1 gcc工具链</h2><p>可以去这个github：<a href="https://github.com/blessingwater/GCC_x86_64-elf-tools-windows">https://github.com/blessingwater/GCC_x86_64-elf-tools-windows</a> 下载，解压之后添加环境变量即可</p><table><thead><tr><th>解压</th><th>设置环境变量</th><th>命令行验证</th></tr></thead><tbody><tr><td><img data-src="/assets/07_Make-MyOS-Again/image-20250621205003547.png" alt="image-20250621205003547"></td><td><img data-src="/assets/07_Make-MyOS-Again/image-20250621205106657.png" alt="image-20250621205106657"></td><td><img data-src="/assets/07_Make-MyOS-Again/image-20250621205328909.png" alt="image-20250621205328909"></td></tr></tbody></table><p>TODO 有时间折腾一下交叉编译工具链：<a href="https://wiki.osdev.org/GCC_Cross-Compiler">https://wiki.osdev.org/GCC_Cross-Compiler</a></p><h2 id="1-2-CMake"><a href="#1-2-CMake" class="headerlink" title="1.2 CMake"></a>1.2 CMake</h2><p>去 <a href="https://cmake.org/download/">https://cmake.org/download/</a> 下载Windwos版本安装即可，添加到系统环境变量，能执行<code>cmake --version</code>就可以了</p><h2 id="1-3-安装GCC"><a href="#1-3-安装GCC" class="headerlink" title="1.3 安装GCC"></a>1.3 安装GCC</h2><p>主要是为了要make命令，去github下载、解压即可：<a href="https://github.com/niXman/mingw-builds-binaries/releases">https://github.com/niXman/mingw-builds-binaries/releases</a></p><p>解压后在bin目录有个可执行文件<code>mingw32-make.exe</code>，这个就是我们需要的<code>make</code>命令，改成<code>make.exe</code>加环境变量就好了</p><p><img data-src="/assets/07_Make-MyOS-Again/image-20250625214843502.png" alt="image-20250625214843502"></p><h2 id="1-4-Qemu"><a href="#1-4-Qemu" class="headerlink" title="1.4 Qemu"></a>1.4 Qemu</h2><p>去 <a href="https://qemu.eu/w64/">https://qemu.eu/w64/</a> 下载最新的安装即可，记得添加的系统环境变量</p><p>TODO 自己下载源码编译：<a href="https://www.qemu.org/download/">https://www.qemu.org/download/</a></p><h2 id="1-4-Other"><a href="#1-4-Other" class="headerlink" title="1.4 Other"></a>1.4 Other</h2><p>VS Code，Git啥的就不说了</p><h1 id="2-操作系统启动"><a href="#2-操作系统启动" class="headerlink" title="2 操作系统启动"></a>2 操作系统启动</h1><p>一篇老文档：<a href="https://manybutfinite.com/post/how-computers-boot-up/">How Computers Boot Up | Many But Finite</a></p><p>细节部分可以下载Intel手册：<a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/intel-sdm.html">Manuals for Intel® 64 and IA-32 Architectures</a></p><p><img data-src="/assets/07_Make-MyOS-Again/image-20250622184950150.png" alt="image-20250622184950150"></p><p>x86_64系统上电后的启动流程（参考卷3：PROCESSOR MANAGEMENT AND INITIALIZATION）大致如下：</p><h2 id="2-1-上电与硬件复位"><a href="#2-1-上电与硬件复位" class="headerlink" title="2.1 上电与硬件复位"></a>2.1 上电与硬件复位</h2><p>电源供应稳定后，主板上的硬件复位电路会发出一个复位信号；</p><p>CPU强制进入一个已知的初始状态：将所有寄存器重置为预设值，消除系统断电或异常导致的随机状态，确保可预测的启动环境，同时大部分功能单元也会被禁用（如缓存、超线程、多核）；</p><p>控制寄存器CR0状态设置为<code>60000010H</code>，此时处理器进入<strong>实地址模式</strong>。下图是部分寄存器的初始值<img data-src="/assets/07_Make-MyOS-Again/image-20250622153336796.png" alt="image-20250622153336796"></p><p>注意几个重要的寄存器值：指令指针寄存器<code>EIP=0000FFF0H</code>，代码段寄存器CS的Selector为<code>F000H</code>，通用寄存器EDX表示处理器型号（0000B）、系列（1111B）、处理器类型（00B）。</p><h2 id="2-2-处理器内置自检（BIST，Build-In-Self-Test）"><a href="#2-2-处理器内置自检（BIST，Build-In-Self-Test）" class="headerlink" title="2.2 处理器内置自检（BIST，Build-In Self Test）"></a>2.2 处理器内置自检（BIST，Build-In Self Test）</h2><p>这是<strong>可选项</strong>。硬件可要求在开机时执行BIST，若处理器通过了BIST，则将EAX寄存器置0H；非零值表示检测到处理器故障。如果未请求BIST，硬件复位后EAX内容亦为0H。</p><p>一般就是逻辑电路测试、内存测试、时序测试</p><h2 id="2-3-执行第一条指令"><a href="#2-3-执行第一条指令" class="headerlink" title="2.3 执行第一条指令"></a>2.3 执行第一条指令</h2><p>上面提到了<strong>实地址模式</strong>，是CPU的一种工作模式，该模式下A20地址线默认被禁用，CPU只能通过20位地址线<strong>直接访问物理内存</strong>，即最大寻址空间为FFFFFH，1MB（$$2^{20}&#x3D;1048576 B$$）。</p><p>CPU从复位状态释放后，根据预定义的初始设置（Intel和AMD规定固定物理地址<code>FFFFFFF0H</code>），从<strong>固件</strong>（BIOS或UEFI）的ROM芯片中读取第一条指令。</p><p>在实模式下，<code>物理地址 = CS.Selector &lt;&lt; 4 + IP</code>，这里CS偏移4位刚好是20位。所以第一条指令物理地址为：<code>F000H &lt;&lt; 4 + FFF0H = F0000H + FFF0H = FFFF0H</code>，计算出来的物理地址并不是实际执行的<code>FFFFFFF0H</code>。问题核心在于<strong>硬件对地址空间的特殊映射</strong>，<strong>硬件强制高位地址线（A20~A31或更高）&#x3D; 1</strong>。</p><p>为什么要选择<code>FFFFFFF0H</code>作为第一条指令？一个兼容，另一个就是灵活。开机第一件事是读取固件（BIOS&#x2F;UEFI），其实<code>FFFFFFF0H</code>的位置就是固件ROM的末尾，并且是一条跳转指令，<strong>跳转到固件启动代码位置</strong>。每家计算机生产厂商生产的机器外设不同，所以其固件程序大小不尽相同，有的可能是1K，有的可能是2K，如果把固件程序放在0x0000处，那么会造成在机器A上用户写的程序是从<code>0x0400</code>开始，机器B上用户写的程序就是<code>0x0800</code>开始，非常不统一。如果把这程序放在1M内存的顶部，再规定计算机第一条指令位置是<code>FFFFFFF0H</code>，然后就跳到各家固件开始处，那么用户写的程序都可以从<code>0x0000</code>开始了。</p><h2 id="2-4-固件阶段（BIOS-x2F-UEFI）"><a href="#2-4-固件阶段（BIOS-x2F-UEFI）" class="headerlink" title="2.4 固件阶段（BIOS&#x2F;UEFI）"></a>2.4 固件阶段（BIOS&#x2F;UEFI）</h2><p>开机自检(POST，Power-On Self-Test)：执行加电自检，检测关键硬件（CPU、内存、显卡、存储控制器）是否正常工作。如有故障，会通过蜂鸣码或LED灯报告。</p><p>硬件初始化：初始化芯片组、内存控制器、配置RAM（执行内存检测如MemTest，建立内存映射）、初始化基本显示输出（VGA&#x2F;文本模式）、初始化基本输入（键盘控制器）、枚举PCI&#x2F;PCIe设备、初始化存储控制器（SATA, NVMe）等。</p><p>固件运行时服务设置：建立供后续阶段（OS Loader）调用的服务接口。</p><p>启动设备选择：根据用户配置（Boot Order）或默认顺序，查找可启动设备（硬盘、SSD、USB、网络PXE等）。</p><p>加载并移交控制权：从选定的启动设备上找到并加载<strong>第一阶段引导加载程序</strong>（通常是磁盘上的 MBR 或 EFI 分区中的 <code>.efi</code> 文件）到内存，并将 CPU 控制权交给它。</p><p>BIOS：工作在16位实模式。启动设备查找基于磁盘的<strong>主引导记录</strong>。将MBR的512字节内容加载到物理地址 <code>0x7C00</code>。控制权交给<code>0x7C00</code>处的MBR代码。分区和文件系统认知有限（依赖MBR和VBR）、仅支持16位代码、寻址空间小、安全性差。</p><p>UEFI：大部分代码运行在<strong>32位保护模式</strong>或<strong>64位长模式</strong>（取决于固件实现）。使用<strong>GUID分区表</strong>。直接在EFI 系统分区上查找并加载<strong>EFI应用程序</strong>（通常是<code>\EFI\BOOT\BOOTX64.EFI</code> 或操作系统特定的加载器如 <code>\EFI\Microsoft\Boot\bootmgfw.efi</code>）。使用UEFI提供的<strong>Boot Services</strong>和<strong>Runtime Services</strong>进行硬件访问、内存分配、文件系统操作等。支持大容量磁盘、独立于文件系统的启动加载、模块化设计、安全启动、图形化界面、更快启动速度。</p><h2 id="2-5-引导加载程序阶段"><a href="#2-5-引导加载程序阶段" class="headerlink" title="2.5 引导加载程序阶段"></a>2.5 引导加载程序阶段</h2><p>这个阶段的任务是<strong>找到并加载操作系统内核</strong>，并为其执行做好环境准备（特别是模式切换）。</p><p>BIOS：</p><ul><li>MBR（Stage 1）：位于磁盘第一个扇区（512字节）。主要职责是查找活动分区，将该分区的卷引导记录加载到内存（通常是<code>0x7C00</code>），并跳转执行。</li><li>VBR（Stage 1.5&#x2F;Stage 2）：位于活动分区起始扇区。包含更复杂的代码，能理解特定文件系统（如FAT32, NTFS, ext4）。它的职责是在文件系统中查找并加载第二阶段引导加载程序到内存并执行。</li><li>第二阶段引导加载程序（Stage 2）：提供用户界面（可选菜单）、加载配置文件、加载操作系统内核映像和初始内存盘到内存。它负责进行从16位实模式到32位保护模式再到64位长模式的切换。最终，准备好内核需要的参数（如命令行、内存布局信息），并跳转到内核的入口点。</li></ul><p>UEFI：</p><ul><li>UEFI Boot Manager：根据NVRAM中的启动项配置，直接加载指定的OS Loader。这个加载器本身就是一个UEFI应用程序。</li><li>OS Loader（EFI App）：由UEFI直接加载到内存并执行。它运行在UEFI提供的环境（保护模式&#x2F;长模式）下。主要职责是：使用 UEFI Boot Services 访问文件系统，<strong>加载操作系统内核映像</strong>和<strong>初始内存盘</strong>；解析启动配置数据；为内核准备启动信息；通知UEFI固件，操作系统即将接管，UEFI会回收其占用的内存并将硬件控制权完全移交给OS Loader&#x2F;内核；跳转到内核的入口点，此时CPU通常已由UEFI或OS Loader置于<strong>64 位长模式</strong></li></ul><h2 id="2-6-操作系统内核初始化"><a href="#2-6-操作系统内核初始化" class="headerlink" title="2.6 操作系统内核初始化"></a>2.6 操作系统内核初始化</h2><p>CPU 控制权正式移交到<strong>操作系统内核</strong>的入口点（如Linux的<code>startup_64()</code>，Windows的<code>KiSystemStartup()</code>）。</p><p><strong>早期内核初始化</strong>：设置内核自己的页表、建立终端描述符表、初始化内存管理子系统、解析bootloader传来的参数……</p><p><strong>中后期内核初始化</strong>：解压并挂载初始内存盘、执行更全面的硬件探测和驱动程序初始化、挂载根文件系统、初始化进程管理和调度器、启动用户空间第一个进程</p><h2 id="2-7-用户空间初始化"><a href="#2-7-用户空间初始化" class="headerlink" title="2.7 用户空间初始化"></a>2.7 用户空间初始化</h2><p>由第一个用户空间进程负责：读取系统配置文件、启动系统服务……</p><h1 id="3-Hello-MyOS"><a href="#3-Hello-MyOS" class="headerlink" title="3 Hello MyOS"></a>3 Hello MyOS</h1><p>固件的东西不在本次考虑范围内了，系统制作仅从bootloader开始。Bootloader引导程序由两部构成：boot引导程序负责开机启动和加载loader引导程序；loader引导程序用于完成配置硬件工作环境、引导加载内核。</p><p>当BIOS自检结束后会根据启动选项设置去选择启动设备，即检测软盘的第0磁头第0磁道第1扇区，是否以<code>0x55aa</code>作为结尾。如果是，那么BIOS就认为这个扇区是一个引导扇区（Boot Sector），进而把这个扇区的数据复制到物理内存地址<strong>0x7c00</strong>处，随后将处理器的执行权移交给这段程序（跳转至<code>0x7c00</code>地址处执行）。</p><p>一个扇区的总容量仅有512B，去掉两字节<code>0x55aa</code>，就只剩下510字节，容量太小了只能作为一级引导程序来加载二级引导程序Loader。</p><p>写个Hello World试试手，文件树如下：</p><p><img data-src="/assets/07_Make-MyOS-Again/image-20250625221920519.png" alt="image-20250625221920519"></p><p>其中<code>image</code>是生成的用于加载的镜像，<code>out</code>是生成的中间文件以及elf等，<code>ref</code>放一些参考文件，<code>script</code>放一下好用的脚本，<code>src</code>就是系统的源码了</p><p>因为不是nasm来编译，而是<code>x86_64_elf_gcc</code>来编译，所以汇编语法略有变化，叫GAS汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 指定以下代码生成16位的机器指令，确保可以在实模式下运行</span><br><span class="line">.code16</span><br><span class="line"></span><br><span class="line"># 声明本地以下符号是全局的，在其他源文件中可以访问</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line"># 代码段地址开始</span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    xor %ax, %ax  # ax = 0</span><br><span class="line">    mov %ax, %ds</span><br><span class="line">    mov %ax, %es</span><br><span class="line">    mov %ax, %ss</span><br><span class="line"></span><br><span class="line">    # 设置栈指针sp指向0x7c00 栈向低地址增长 0x7c00 -&gt; 0x0000</span><br><span class="line">    mov $_start, %sp</span><br><span class="line">    </span><br><span class="line">    # 设置显示模式为 80x25 16色文本模式</span><br><span class="line">    mov $0x0003, %ax</span><br><span class="line">    int $0x10</span><br><span class="line"></span><br><span class="line">    # clear screen</span><br><span class="line">    mov $0x0600, %ax</span><br><span class="line">    mov $0x0700, %bx</span><br><span class="line">    xor %cx, %cx</span><br><span class="line">    mov $0x184f, %dx</span><br><span class="line">    int $0x10</span><br><span class="line"></span><br><span class="line">    # set focus</span><br><span class="line">    mov $0x0200, %ax</span><br><span class="line">    xor %bx, %bx</span><br><span class="line">    xor %dx, %dx</span><br><span class="line">    int $0x10</span><br><span class="line"></span><br><span class="line">    # display msg on screen</span><br><span class="line">    mov $0x1301, %ax</span><br><span class="line">    mov $0x0007, %bx</span><br><span class="line">    mov $StartBootMsg, %bp  # 放入字符串</span><br><span class="line">    mov $StartBootMsgLen, %cx  # 字符串长度</span><br><span class="line">    xor %dx, %dx</span><br><span class="line">    int $0x10</span><br><span class="line"></span><br><span class="line">    # reset floppy</span><br><span class="line">    xor %ah, %ah</span><br><span class="line">    xor %dl, %dl</span><br><span class="line">    int $0x13    # 重置磁盘</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">    cli       # 禁用中断</span><br><span class="line">    hlt       # 暂停CPU</span><br><span class="line">    jmp halt  # 无限循环 双重保险</span><br><span class="line"></span><br><span class="line"># 定义一个字符串:</span><br><span class="line">#   .string &quot;...&quot; 定义未自动加0的字符串</span><br><span class="line">#   .asciz &quot;...&quot;  定义以0结尾的字符串</span><br><span class="line">StartBootMsg: .string &quot;Sidney DING, Start Boot......&quot;</span><br><span class="line"># 定义常量表达式，用于保存静态长度. 当前位置计数器减去msg的起始地址，得到字符串长度</span><br><span class="line">StartBootMsgLen = . - StartBootMsg</span><br><span class="line"></span><br><span class="line"># 伪指令 跳到 510 字节处，填充 0x55aa 可改成 .byte 0x55, 0xaa</span><br><span class="line">.org 0x01fe</span><br><span class="line">.word 0xaa55</span><br></pre></td></tr></table></figure><p>基本主要就是向屏幕输出了一串字符串，BIOS中断参考<code>ref/BIOS-interrupts.pdf</code>即可，然后此时的内存布局应当如下</p><table><thead><tr><th align="left">地址范围</th><th align="left">内容</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">0x00000-0x003FF</td><td align="left">中断向量表</td><td align="left">1KB</td></tr><tr><td align="left">0x00400-0x004FF</td><td align="left">BIOS 数据区</td><td align="left">256B</td></tr><tr><td align="left">0x00500-0x07BFF</td><td align="left">空闲内存</td><td align="left">~30KB</td></tr><tr><td align="left"><strong>0x07C00-0x07DFF</strong></td><td align="left"><strong>引导程序</strong></td><td align="left"><strong>512B</strong></td></tr><tr><td align="left">0x07E00-0x9FFFF</td><td align="left">可用内存</td><td align="left">~608KB</td></tr></tbody></table><ol><li>为什么是<code>0x7c00</code>？</li></ol><p>很久很久以前，这个值是<code>0x200</code>，关于这个<code>0x200</code>大概有三个原因：一是8086中断向量使用<code>0x0 - 0x3FF</code>，二是86-DOS从<code>0x400</code>加载，三是86-DOS不使用<code>0x200 - 0x3FF</code>之间的中断向量。这些原因意味着需要保留<code>0x200 - 0x3FF</code>，而且无论86-DOS或用户应用程序想在哪里加载，都不能妨碍操作系统。因此Tim Paterson（86-DOS开发者）选择<code>0x200</code>作为MBR加载地址。</p><p><code>0x7C00</code>由IBM PC 5150 BIOS开发团队（David Bradley 博士）决定的。因为当时认为DOS1.0最少需要32KB，为了让操作系统有一个连续的内存空间，尽量把启动扇区的位置放到内存的尾部，启动扇区是512字节，除此之外启动扇区的堆栈&#x2F;数据区还需空间，又预留了512字节。因此，<code>0x7c00 = 32K - 1024B</code></p><ol start="2"><li>为什么是<code>0x55aa</code>？</li></ol><p>首先，1字节不够可靠（可能随机出现），2字节组合概率：1&#x2F;65536（足够安全）。这俩数字是完美的0、1交替序列<code>01010101 10101010</code>，早期软盘的物理表现：产生稳定的250KHz方波（对模拟电路友好）</p><blockquote><p>“我们需要一个不可能随机出现的模式。55 AA 的交替位模式在损坏时仍保留可识别特征，且电气特性上产生独特的电压波动，这对软盘驱动器识别扇区结束至关重要。”<br>—— David Bradley, IBM PC BIOS 首席设计师</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要是受打击了..md..太多不会了，又重新拾起来了，这次为了方便也不搞什么虚拟机了，所有环境完全在Win10上，主要是笔记本有点破，再搞个虚拟机有点吃不消了..所以参考了下各种教程，最终使用vscode + gdb + qemu的组合..或许qemu会换成Bochs..&lt;</summary>
      
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Make OS" scheme="https://sidneyding.cn/categories/OS/Make-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>Compile system app with AndroidStudio</title>
    <link href="https://sidneyding.cn/posts/1c3367f4/"/>
    <id>https://sidneyding.cn/posts/1c3367f4/</id>
    <published>2022-10-16T03:51:07.000Z</published>
    <updated>2025-06-25T15:36:28.255Z</updated>
    
    <content type="html"><![CDATA[<p>作为OS研发，在framework加点api，写个apk验证想法是常有的事，什么系统api，隐藏api更是想用就用，怎么能被<code>@hide</code>限制？所以一般的写的apk都是集成在系统源码里面，比如Settings，加上系统签名，这样确实没有<code>@hide</code>限制了，但是这样基本都是基于记事本开发，没有IDE的提示来得舒服，但是用Android Studio打开，由于原生sdk的限制，调用隐藏的api或咱们自己加的api会报红，这代码写起来就不爽。所以咱就是要整个两者兼得的方法，核心是两点，一是系统的jar包，也就是sdk；二是platform签名，没有签名认证，是安装不了的</p><p>关于sdk，咱们手上有源码是可以自己编译的，直接<code>lunch sdk-eng</code>，整编就好了，出来个啥，不大清楚，没用过，这里不用这个法子，此处选择用哪个模块导入哪个模块的jar包；系统签名相信就按着步骤来生成就好了</p><span id="more"></span><h1 id="1-创建APP工程"><a href="#1-创建APP工程" class="headerlink" title="1 创建APP工程"></a>1 创建APP工程</h1><p>用AS创建app工程没啥好说的，创建完毕后在<code>MainActivity</code>的<code>onCreate</code>方法中写几个hide调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TEST ADD</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line">    <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> context.getUserId();  <span class="comment">// hide方法，报红</span></span><br><span class="line">    Log.e(<span class="string">&quot;dingfs&quot;</span>, <span class="string">&quot;User Id: &quot;</span> + uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WifiManager</span> <span class="variable">wifiManager</span> <span class="operator">=</span> (WifiManager) getSystemService(WIFI_SERVICE);</span><br><span class="line">    String[] factoryMacArray = wifiManager.getFactoryMacAddresses();  <span class="comment">// hide方法，报红</span></span><br><span class="line">    Log.e(<span class="string">&quot;dingfs&quot;</span>, <span class="string">&quot;factoryMacArray: &quot;</span> + Arrays.toString(factoryMacArray));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ConnectivityManager</span> <span class="variable">cm</span> <span class="operator">=</span> (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">avoidBadWifi</span> <span class="operator">=</span> cm.shouldAvoidBadWifi();  <span class="comment">// hide方法，报红</span></span><br><span class="line">    Log.e(<span class="string">&quot;dingfs&quot;</span>, <span class="string">&quot;avoidBadWifi: &quot;</span> + avoidBadWifi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时这几个方法肯定是会报红的</p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221016224617836.png" alt="image-20221016224617836"></p><p>如果此时点击build会直接报错</p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221016224722293.png" alt="image-20221016224722293"></p><p>所以目前遇到的是两个问题，不能编译和报红，接下来解决这俩问题</p><h1 id="2-添加jar包"><a href="#2-添加jar包" class="headerlink" title="2 添加jar包"></a>2 添加jar包</h1><p>这个三个hide api在Android 13上对应的分别是framework，wifi，connectivity模块下的，虽然我们不用整编sdk，但是这三个模块的还是得编译一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch sdk_phone_x86_64-eng</span><br><span class="line"></span><br><span class="line">make framework-minus-apex -j8</span><br><span class="line">make com.android.wifi -j8  <span class="comment"># 编译 framework-wifi 应该就ok</span></span><br><span class="line">make com.android.tethering.inprocess -j8  <span class="comment"># 编译 framework-connectivity 应该就ok</span></span><br></pre></td></tr></table></figure><p>这里简单说下怎么找到编译的模块名字，规律还是比较好找的</p><p>对于framework，作为Android OS开发应当不陌生，只是换个名字而已，bp文件：<code>frameworks/base/Android.bp</code></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">370 </span>// This <span class="string">&quot;framework&quot;</span> module is <span class="keyword">NOT</span> installed <span class="keyword">to</span> the device. It<span class="comment">&#x27;s</span></span><br><span class="line"><span class="symbol">371 </span>// <span class="string">&quot;framework-minus-apex&quot;</span> that gets installed <span class="keyword">to</span> the device. Note that</span><br><span class="line"><span class="symbol">372 </span>// the filename is still framework.jar (via the stem property) <span class="keyword">for</span></span><br><span class="line"><span class="symbol">373 </span>// compatibility reason. The purpose of this module is <span class="keyword">to</span> provide</span><br><span class="line"><span class="symbol">374 </span>// framework APIs (both public <span class="keyword">and</span> private) <span class="keyword">for</span> bundled apps.</span><br><span class="line"><span class="symbol">375 </span>// <span class="string">&quot;framework-minus-apex&quot;</span> can<span class="comment">&#x27;t be used for the purpose because 1)</span></span><br><span class="line"><span class="symbol">376 </span>// many apps have already hardcoded the <span class="keyword">name</span> <span class="string">&quot;framework&quot;</span> <span class="keyword">and</span></span><br><span class="line"><span class="symbol">377 </span>// <span class="number">2</span>) it lacks API symbols from updatable modules - as it<span class="comment">&#x27;s clear from</span></span><br><span class="line"><span class="symbol">378 </span>// its suffix <span class="string">&quot;-minus-apex&quot;</span>.</span><br><span class="line"><span class="symbol">379 </span>java_library &#123;</span><br><span class="line"><span class="symbol">380 </span>    <span class="keyword">name</span>: <span class="string">&quot;framework&quot;</span>,</span><br></pre></td></tr></table></figure><p>对于WiFi和Connectivity，编译apex和sdk library都行，毕竟apex需要sdk library，只是所在的bp的文件不同，这里看sdk library，其实只要在bp文件中找java_sdk_library就好了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 一般提供api的都是framework</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> packages<span class="regexp">/modules/</span>Wifi<span class="regexp">/framework/</span>Android.bp</span><br><span class="line"><span class="number">135</span> <span class="regexp">//</span> post-jarjar version of framework-wifi</span><br><span class="line"><span class="number">136</span> java_sdk_library &#123;</span><br><span class="line"><span class="number">137</span>     name: <span class="string">&quot;framework-wifi&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> packages<span class="regexp">/modules/</span>Connectivity<span class="regexp">/framework/</span>Android.bp</span><br><span class="line"><span class="number">118</span> java_sdk_library &#123;</span><br><span class="line"><span class="number">119</span>     name: <span class="string">&quot;framework-connectivity&quot;</span>,</span><br></pre></td></tr></table></figure><p>编译完成后，在out目录找对应的jar包，并导入到AndroidStudio中，这个规律很好找的，**<code>out/soong/.intermediates/&lt;模块路径&gt;/combined/&lt;模块名&gt;.jar</code>**，所以只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用find命令就好了，找准combined</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android13-dev$ find out/soong/.intermediates/frameworks/ -name <span class="string">&quot;framework-minus-apex.jar&quot;</span></span><br><span class="line">out/soong/.intermediates/frameworks/base/framework-minus-apex/android_common/dex/framework-minus-apex.jar</span><br><span class="line">...</span><br><span class="line">out/soong/.intermediates/frameworks/base/framework-minus-apex/android_common/combined/framework-minus-apex.jar</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 拷贝出来</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android13-dev$ <span class="built_in">cp</span> out/soong/.intermediates/frameworks/base/framework-minus-apex/android_common/combined/framework-minus-apex.jar /mnt/d/Develop/Android/sdk/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 就找combined的</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android13-dev$ find out/soong/.intermediates/packages/modules/Wifi/ -name <span class="string">&quot;framework-wifi.jar&quot;</span></span><br><span class="line">out/soong/.intermediates/packages/modules/Wifi/framework/framework-wifi/android_common_apex30/dex/framework-wifi.jar</span><br><span class="line">...</span><br><span class="line">out/soong/.intermediates/packages/modules/Wifi/framework/framework-wifi/android_common_apex30/combined/framework-wifi.jar</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 拷贝出来</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android13-dev$ <span class="built_in">cp</span> out/soong/.intermediates/packages/modules/Wifi/framework/framework-wifi/android_common_apex30/combined/framework-wifi.jar /mnt/d/Develop/Android/sdk/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区别不大 哪个都行</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android13-dev$ find out/soong/.intermediates/packages/modules/Connectivity/ -name <span class="string">&quot;framework-connectivity.jar&quot;</span></span><br><span class="line">out/soong/.intermediates/packages/modules/Connectivity/Tethering/apex/com.android.tethering-bootclasspath-fragment/android_common_apex30/hiddenapi-modular/encoded/framework-connectivity.jar</span><br><span class="line">...</span><br><span class="line">out/soong/.intermediates/packages/modules/Connectivity/framework/framework-connectivity/android_common/combined/framework-connectivity.jar</span><br><span class="line">...</span><br><span class="line">out/soong/.intermediates/packages/modules/Connectivity/framework/framework-connectivity/android_common_apex30/combined/framework-connectivity.jar</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 我选第一个</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android13-dev$ <span class="built_in">cp</span> out/soong/.intermediates/packages/modules/Connectivity/framework/framework-connectivity/android_common/combined/framework-connectivity.jar /mnt/d/Develop/Android/sdk/</span><br></pre></td></tr></table></figure><p>然后将这个三个jar包拷贝出来，放到项目的<code>app/libs/</code>目录下，然后在app目录下<code>build.gradle</code>中加点东西</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdk <span class="number">32</span></span><br><span class="line">    ...</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面这一坨的意思就是将三个jar包扩展为bootstrap级别</span></span><br><span class="line">    <span class="comment">// 这里的options就是上面的compileOptions，版本不是1.8的话bootstrapClasspath为null..</span></span><br><span class="line">    gradle.projectsEvaluated &#123;</span><br><span class="line">        tasks.withType(JavaCompile) &#123;</span><br><span class="line">            <span class="keyword">if</span> (options.bootstrapClasspath == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(<span class="string">&quot;options.bootstrapClasspath is null, check your compileOptions first!&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;File&gt; fileSet = options.bootstrapClasspath.getFiles()</span><br><span class="line">            List&lt;File&gt; newFileList = <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">            <span class="comment">// 输入参数建议为相对路径</span></span><br><span class="line">            newFileList.add(<span class="keyword">new</span> File(<span class="string">&#x27;libs/framework-wifi.jar&#x27;</span>))</span><br><span class="line">            newFileList.add(<span class="keyword">new</span> File(<span class="string">&#x27;libs/framework-connectivity.jar&#x27;</span>))</span><br><span class="line">            newFileList.add(<span class="keyword">new</span> File(<span class="string">&#x27;libs/framework-minus-apex.jar&#x27;</span>))</span><br><span class="line">            <span class="comment">// 最后将原始参数添加</span></span><br><span class="line">            newFileList.addAll(fileSet)</span><br><span class="line">            options.bootstrapClasspath = files(newFileList.toArray())</span><br><span class="line">            println(<span class="string">&quot;bootstrapClasses: &quot;</span> + options.bootstrapClasspath.getFiles())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 只是编译时需要，不要用implementation</span></span><br><span class="line">    compileOnly files(<span class="string">&#x27;libs/framework-minus-apex.jar&#x27;</span>)</span><br><span class="line">    compileOnly files(<span class="string">&#x27;libs/framework-wifi.jar&#x27;</span>)</span><br><span class="line">    compileOnly files(<span class="string">&#x27;libs/framework-connectivity.jar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.5.1&#x27;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示位置</p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221016234740682.png" alt="image-20221016234740682"></p><p>修改完毕后，sync一下gradle文件，此时虽然那三个隐藏api还是报红的，但是编译已经不报错了，apk也能编出装手机上了，但是apk起不来，看看log</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime: FATAL EXCEPTION: <span class="selector-tag">main</span></span><br><span class="line">    Process: fri<span class="selector-class">.sidney</span><span class="selector-class">.systemapp</span>, PID: <span class="number">1974</span></span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>: Unable to start activity ComponentInfo&#123;fri<span class="selector-class">.sidney</span>.systemapp/fri<span class="selector-class">.sidney</span><span class="selector-class">.systemapp</span>.MainActivity&#125;: java<span class="selector-class">.lang</span><span class="selector-class">.SecurityException</span>: App not allowed to get Wi-Fi factory MAC <span class="selector-tag">address</span> (uid = <span class="number">10115</span>)</span><br><span class="line">        at android<span class="selector-class">.app</span><span class="selector-class">.ActivityThread</span><span class="selector-class">.performLaunchActivity</span>(ActivityThread<span class="selector-class">.java</span>:<span class="number">3676</span>)</span><br></pre></td></tr></table></figure><p>显然是缺少了权限，解决完报红IDE应该会提示我们添加对应的权限</p><h1 id="3-解决报红"><a href="#3-解决报红" class="headerlink" title="3 解决报红"></a>3 解决报红</h1><p>这里因为hide api还是红色的，所以IDE没给咱提示，让咱们添加对应的权限。而报红的原因就是对原生sdk的依赖优先级比后添加的几个jar包高，导致IDE优先用sdk的类，而原生sdk中关键系统类和隐藏属性和方法都是不允许我们直接引用的，所以看起来仍然是can not find symbol，解决方法是修改项目中的文件<code>.idea/modules/app/SystemApp.app.main.iml</code>，这里的路径名根据项目名不同而不同，不是固定的，打开文件会看到如下内容，找到咱们的jar包，并挪到Android SDK上面就好了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;jdk&quot;</span> <span class="attr">jdkName</span>=<span class="string">&quot;Android API 32 Platform&quot;</span> <span class="attr">jdkType</span>=<span class="string">&quot;Android SDK&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;sourceFolder&quot;</span> <span class="attr">forTests</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Gradle: androidx.annotation:annotation:1.3.0&quot;</span> <span class="attr">level</span>=<span class="string">&quot;project&quot;</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 将下面这三个jar包挪到 Android SDK上面就好了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Gradle: ./app/libs/framework-minus-apex.jar&quot;</span> <span class="attr">level</span>=<span class="string">&quot;project&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Gradle: ./app/libs/framework-wifi.jar&quot;</span> <span class="attr">level</span>=<span class="string">&quot;project&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Gradle: ./app/libs/framework-connectivity.jar&quot;</span> <span class="attr">level</span>=<span class="string">&quot;project&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>还有长得比较恶心的，是这样的..</p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221016235609587.png" alt="image-20221016235609587"></p><p>反正长得奇怪的就是咱的..修改好保存下，此时再看，隐藏api已经不报红了，并且提示咱们需要添加权限</p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221016235711583.png" alt="image-20221016235711583"></p><p>直接点击提示就添加就好啦，但是这两个权限普通app加了是没用的”Permission is only granted to system apps”，此时app仍然起不来，还是会报权限问题</p><p>还有个问题，这个iml文件每次改动下gradle文件都得手动改下，很是费劲，为了解决这个问题，咱们可以在app的gradle文件中加点东西，一劳永逸</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">preBuild &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="comment">// 此处文件名根据实际情况修改，绝对路径/相对路径都可以</span></span><br><span class="line">        <span class="keyword">def</span> imlFile = file(<span class="string">&quot;../.idea/modules/app/SystemApp.app.main.iml&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">def</span> parsedXml = (<span class="keyword">new</span> XmlParser()).parse(imlFile)</span><br><span class="line">            <span class="keyword">def</span> jdkNode = parsedXml.component[<span class="number">1</span>].orderEntry.find &#123; it.<span class="string">&#x27;@type&#x27;</span> == <span class="string">&#x27;jdk&#x27;</span> &#125;</span><br><span class="line">            parsedXml.component[<span class="number">1</span>].remove(jdkNode)</span><br><span class="line">            <span class="keyword">def</span> sdkString = <span class="string">&quot;Android API &quot;</span> + android.compileSdkVersion.substring(<span class="string">&quot;android-&quot;</span>.length()) + <span class="string">&quot; Platform&quot;</span></span><br><span class="line">            <span class="keyword">new</span> Node(parsedXml.component[<span class="number">1</span>], <span class="string">&#x27;orderEntry&#x27;</span>, [<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;jdk&#x27;</span>, <span class="string">&#x27;jdkName&#x27;</span>: sdkString, <span class="string">&#x27;jdkType&#x27;</span>: <span class="string">&#x27;Android SDK&#x27;</span>])</span><br><span class="line">            groovy.xml.XmlUtil.serialize(parsedXml, <span class="keyword">new</span> FileOutputStream(imlFile))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException ignored) &#123;</span><br><span class="line">            <span class="comment">// nop, iml not found</span></span><br><span class="line">            println <span class="string">&quot;no iml found&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>编译前点一下这个preBuild就好了</p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221017000052491.png" alt="image-20221017000052491"></p><h1 id="4-系统签名"><a href="#4-系统签名" class="headerlink" title="4 系统签名"></a>4 系统签名</h1><p>最后便是来解决这个系统签名，既然有些权限只能是系统app才能添加，那就将咱们的app变成系统app</p><h2 id="4-1-成为系统app"><a href="#4-1-成为系统app" class="headerlink" title="4.1 成为系统app"></a>4.1 成为系统app</h2><p>成为系统app很简单，在<code>AndroidManifest.xml</code>加上<code>android:sharedUserId=&quot;android.uid.system&quot;</code>就ok了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:sharedUserId</span>=<span class="string">&quot;android.uid.system&quot;</span>  &lt;!<span class="attr">--</span> 系统<span class="attr">uid</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">          package=&quot;com.xiaomi.systemapp&quot;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.NETWORK_SETTINGS&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.NETWORK_STACK&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这个编译没问题，但是安装不上去了</p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221017000525132.png" alt="image-20221017000525132"></p><p>是的uid变了，需要系统签名</p><h2 id="4-2-生成系统签名"><a href="#4-2-生成系统签名" class="headerlink" title="4.2 生成系统签名"></a>4.2 生成系统签名</h2><p>一般签名分为正式签名和测试签名，签名这东西可以直接从源码提取，步骤如下，主要为了生成keystore或jks文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 源码目录build/target/product/security 取platform.pk8 platform.x509.pem放到一个目录下</span></span><br><span class="line"><span class="built_in">cp</span> build/target/product/security/platform.* ~/temp/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 生成platform.priv.pem</span></span><br><span class="line">openssl pkcs8 -inform DER -nocrypt -<span class="keyword">in</span> platform.pk8 -out platform.priv.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 生成platform.p12，这里证书密码格式 -password pass:&lt;android&gt; 这里 -name &lt;alias&gt; 就是别名</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> platform.x509.pem -out platform.p12 -inkey platform.priv.pem -password pass:android -name platformKey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 生成platform.keystore，这里-deststorepass要与上面证书密码一致 -srcstorepass为了方便写成一样吧</span></span><br><span class="line">keytool -importkeystore -deststorepass android -destkeystore platform.keystore -srckeystore platform.p12 -srcstoretype PKCS12 -srcstorepass android</span><br></pre></td></tr></table></figure><p>到这里咱们的签名就制作好了，就是那个<code>platform.keystore</code>文件，拷贝值app目录下，再次修改app下的<code>build.gradle</code>文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdk <span class="number">32</span></span><br><span class="line">...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 就是下面这个签名配置</span></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            keyAlias <span class="string">&#x27;platformKey&#x27;</span></span><br><span class="line">            keyPassword <span class="string">&#x27;android&#x27;</span></span><br><span class="line">            storeFile file(<span class="string">&#x27;platform.keystore&#x27;</span>)</span><br><span class="line">            storePassword <span class="string">&#x27;android&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候再编译，就没问题了，成功打印出了咱们的log</p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221017001217952.png" alt="image-20221017001217952"></p><p>PS：</p><p>如果这个时候编不过，提示”Algorithm HmacPBESHA256 not available”，这是因为java版本问题，将gradle的java版本换成jdk17就好了，再编译就没有问题了，可以愉快的用系统级api开发了</p><p>Android Studio修改gradle Java版本：<code>File | Settings | Build, Execution, Deployment | Build Tools | Gradle</code></p><p><img data-src="/assets/Compile-system-app-with-AndroidStudio/image-20221017001448432.png" alt="image-20221017001448432"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为OS研发，在framework加点api，写个apk验证想法是常有的事，什么系统api，隐藏api更是想用就用，怎么能被&lt;code&gt;@hide&lt;/code&gt;限制？所以一般的写的apk都是集成在系统源码里面，比如Settings，加上系统签名，这样确实没有&lt;code&gt;@hide&lt;/code&gt;限制了，但是这样基本都是基于记事本开发，没有IDE的提示来得舒服，但是用Android Studio打开，由于原生sdk的限制，调用隐藏的api或咱们自己加的api会报红，这代码写起来就不爽。所以咱就是要整个两者兼得的方法，核心是两点，一是系统的jar包，也就是sdk；二是platform签名，没有签名认证，是安装不了的&lt;/p&gt;
&lt;p&gt;关于sdk，咱们手上有源码是可以自己编译的，直接&lt;code&gt;lunch sdk-eng&lt;/code&gt;，整编就好了，出来个啥，不大清楚，没用过，这里不用这个法子，此处选择用哪个模块导入哪个模块的jar包；系统签名相信就按着步骤来生成就好了&lt;/p&gt;</summary>
    
    
    
    <category term="Other" scheme="https://sidneyding.cn/categories/Other/"/>
    
    
    <category term="Android" scheme="https://sidneyding.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>[Make MyOS] Starting kernel</title>
    <link href="https://sidneyding.cn/posts/e304028/"/>
    <id>https://sidneyding.cn/posts/e304028/</id>
    <published>2022-07-24T14:53:35.000Z</published>
    <updated>2025-06-25T15:38:58.904Z</updated>
    
    <content type="html"><![CDATA[<p>上一节loader程序装载完kernel后，执行了<code>jmp SelectorCode64:OffsetOfKernelFile</code>命令跳转到kernel部分了，意味着Loader将处理的控制权交给了Kernel</p><blockquote><p><strong>处理器把控制权交给kernel后，kernel最先执行的是内核执行头程序。内核执行头程序是一段精心设计的汇编代码，而且必须借助特殊的编译链接方法才能得到最先执行。</strong></p><p>内核头程序负责为操作系统创建段结构和页表结构，设置某些结构的默认处理函数、配置关键寄存器等工作。在完成上述工作后，依然要借助远跳指令才能进入系统内核主程序。</p><p>如何将内核执行头程序编译生成到整个内核程序文件的起始处？手动编写内核程序的链接脚本，在内核程序的链接过程中，链接器会按照链接脚本描述的地址空间布局，把编译好的各个程序片段填充到内核程序文件中。</p></blockquote><p>看完有点懵，都是内核程序为啥要咱手动指定谁先谁后？大概是因为内核头是汇编写的，内核是c写的..要让head先执行就得在lds中指定第一条指令是啥..编译部分参考哈: <a href="https://zhuanlan.zhihu.com/p/504742628">ld - 链接脚本学习笔记与实践过程</a></p><span id="more"></span><h1 id="1-链接脚本"><a href="#1-链接脚本" class="headerlink" title="1 链接脚本"></a>1 链接脚本</h1><p>来瞅瞅这个<code>Kernel.lds</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* OUTPUT_FORMAT(DEFAULT, BIG, LITTLE)，给链接过程提供 默认，大端，小端 三种格式 */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf64-x86-64&quot;,&quot;elf64-x86-64&quot;,&quot;elf64-x86-64&quot;)</span><br><span class="line">OUTPUT_ARCH(i386:x86-64)  /* 指定输出文件的处理器体系结构 */</span><br><span class="line">ENTRY(_start)  /* 将标识符 _start 作为程序的入口地址，即程序第一条指令地址，后面直接在head.S里面找它 */</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    /* 符号 . 是一个定位器或位置指针，用于定位程序的地址或调整程序的布局位置，将定位器设置在地址0xffff800000100000处 </span><br><span class="line">     * 这里0xffff800000000000是线性地址，对应物理地址0，偏移100000也就和预期一样了*/</span><br><span class="line">. = 0xffff800000000000 + 0x100000;</span><br><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">_text = .;  /* 文本段起始地址0xffff800000100000 */</span><br><span class="line">*(.text)    /* 所有输入文件的文本段 */</span><br><span class="line">_etext = .;  /* 结尾线性地址  */</span><br><span class="line">&#125;</span><br><span class="line">. = ALIGN(8);  /* 将地址按向后8字节对齐 */</span><br><span class="line">.data :</span><br><span class="line">&#123;</span><br><span class="line">_data = .;</span><br><span class="line">*(.data)</span><br><span class="line"></span><br><span class="line">_edata = .;</span><br><span class="line">&#125;</span><br><span class="line">.bss :</span><br><span class="line">&#123;</span><br><span class="line">_bss = .;</span><br><span class="line">*(.bss)</span><br><span class="line">_ebss = .;</span><br><span class="line">&#125;</span><br><span class="line">_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SECTIONS部分描述了各程序段在输出文件中的部署以及它们在内存中的布局。ld命令链接各程序文件时，链接顺序大体是按照输入文件顺序来的，所以在系统内核程序的链接命令中，<code>head.o</code>必须作为第一个链接文件，也就是Makefile文件里面将header与kernel编译成system时，<code>head.o</code>要放在<code>kernel.o</code>前面</p><h1 id="2-内核头"><a href="#2-内核头" class="headerlink" title="2 内核头"></a>2 内核头</h1><p>接着链接脚本来看内核头文件<code>head.S</code>(这的S一定得是大写！)，第一条指令是文本段里面<code>_start</code>开头的，这块的汇编用的AT&amp;T格式的，因为要使用GNU提供的汇编器GAS，之前用的是Intel的，稍微有那么点区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.section .text  # 此处是文本段</span><br><span class="line">.globl _start  # 告诉编译器_start全局可见，不然链接器报warning</span><br><span class="line">_start:  # 内核第一条指令从此处开始</span><br><span class="line">    mov    $0x10,  %ax  # 将立即数0x10传给ax，和Intel汇编反了</span><br><span class="line">    mov    %ax,    %ds</span><br><span class="line">    mov    %ax,    %es</span><br><span class="line">    mov    %ax,    %fs</span><br><span class="line">    mov    %ax,    %ss  # 利用ax初始化各个段</span><br><span class="line">    mov    $0x7E00,    %esp</span><br><span class="line"></span><br><span class="line">    # 加载全局描述符表和中断描述符表 和Intel汇编不同lgdt [GdtPtr]</span><br><span class="line">    lgdt    GDT_POINTER(%rip)</span><br><span class="line">    lidt    IDT_POINTER(%rip)</span><br><span class="line"></span><br><span class="line">    mov    $0x10,  %ax</span><br><span class="line">    mov    %ax,    %ds</span><br><span class="line">    mov    %ax,    %es</span><br><span class="line">    mov    %ax,    %fs</span><br><span class="line">    mov    %ax,    %gs</span><br><span class="line">    mov    %ax,    %ss</span><br><span class="line">    movq    $0x7E00,    %rsp</span><br><span class="line"></span><br><span class="line">    # 00000000 00010000 00010000 00000000</span><br><span class="line">    movq    $0x101000,    %rax</span><br><span class="line">    movq    %rax,         %cr3  # 用了高20位作为页目录地址 顶层页表位置</span><br><span class="line">    </span><br><span class="line">    # 由于GAS不支持ljmp和lcall，所以这里是伪造调用lcall后的现场</span><br><span class="line">    # 先通过Relative rip寻址找到 entry64 地址，放到rax中</span><br><span class="line">    # 然后通过lretq恢复调用现场，即回到目标代码段的程序中</span><br><span class="line">    movq    switch_seg(%rip),    %rax</span><br><span class="line">    pushq    $0x08  # 是段选择子，对应下面gdt中的 1 KERNEL Code 64-bit Segment</span><br><span class="line">    pushq    %rax</span><br><span class="line">    lretq</span><br><span class="line"></span><br><span class="line">switch_seg:</span><br><span class="line">    .quad    entry64</span><br><span class="line">entry64:</span><br><span class="line">    movq    $0x10,    %rax</span><br><span class="line">    movq    %rax,    %ds</span><br><span class="line">    movq    %rax,    %es</span><br><span class="line">    movq    %rax,    %gs</span><br><span class="line">    movq    %rax,    %ss</span><br><span class="line">    movq    $0xffff800000007E00,    %rsp        /* rsp address */</span><br><span class="line"></span><br><span class="line">    movq    go_to_kernel(%rip),    %rax        /* movq address */</span><br><span class="line">    pushq    $0x08</span><br><span class="line">    pushq    %rax</span><br><span class="line">    lretq</span><br><span class="line"></span><br><span class="line">go_to_kernel:</span><br><span class="line">    .quad    Start_Kernel  # 这里就是内核程序入口了</span><br></pre></td></tr></table></figure><p>再回过头来看看全局描述表和段信息的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.section .data  # 此处是数据段</span><br><span class="line">.globl GDT_Table</span><br><span class="line">GDT_Table:</span><br><span class="line">    .quad 0x0000000000000000  /*0  NULL   descriptor 00*/</span><br><span class="line">    .quad 0x0020980000000000  /*1  KERNEL Code       64-bit Segment 08*/</span><br><span class="line">    .quad 0x0000920000000000  /*2  KERNEL Data       64-bit Segment 10*/</span><br><span class="line">    .quad 0x0020f80000000000  /*3  USER   Code       64-bit Segment 18*/</span><br><span class="line">    .quad 0x0000f20000000000  /*4  USER   Data       64-bit Segment 20*/</span><br><span class="line">    .quad 0x00cf9a000000ffff  /*5  KERNEL Code       32-bit Segment 28*/</span><br><span class="line">    .quad 0x00cf92000000ffff  /*6  KERNEL Data       32-bit Segment 30*/</span><br><span class="line">    # fill repeat, size, value 重复10次，每次8B，值是0</span><br><span class="line">    .fill 10,8,0     /*8 ~ 9 TSS (jmp one segment &lt;7&gt;) in long-mode 128-bit 40*/</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_POINTER:</span><br><span class="line">GDT_LIMIT:    .word    GDT_END - GDT_Table - 1</span><br><span class="line">GDT_BASE:     .quad    GDT_Table</span><br><span class="line"></span><br><span class="line">.globl IDT_Table</span><br><span class="line">IDT_Table:</span><br><span class="line">    .fill  512,8,0</span><br><span class="line">IDT_END:</span><br><span class="line">IDT_POINTER:</span><br><span class="line">IDT_LIMIT:    .word    IDT_END - IDT_Table - 1</span><br><span class="line">IDT_BASE:     .quad    IDT_Table</span><br><span class="line"></span><br><span class="line">.globl    TSS64_Table</span><br><span class="line">TSS64_Table:</span><br><span class="line">    .fill  13,8,0</span><br><span class="line">TSS64_END:</span><br><span class="line">TSS64_POINTER:</span><br><span class="line">TSS64_LIMIT:    .word    TSS64_END - TSS64_Table - 1</span><br><span class="line">TSS64_BASE:     .quad    TSS64_Table</span><br></pre></td></tr></table></figure><ul><li><p>64bit kernel code段</p><p>.quad 0x0020980000000000</p><p><font color="red">0000 0000</font> 0010 0000 1001 1000 <font color="red">0000 0000</font></p><p><font color="red">0000 0000 0000 0000</font> <font color="green">0000 0000 0000 0000</font></p><p>Base: 0000 0000 0000 0000 0000 0000 0000 0000，G&#x3D;0，E&#x3D;0，这是设置成平坦模式，段大小范围从1 byte到1 MByte，步长为一个字节</p><p>Limit: 0000 0000 0000 0000</p></li><li><p>64bit user code段</p><p>.quad 0x0020f80000000000</p><p><font color="red">0000 0000</font> 0010 0000 1111 1000 <font color="red">0000 0000</font>，G&#x3D;0，E&#x3D;0..</p><p><font color="red">0000 0000 0000 0000</font> <font color="green">0000 0000 0000 0000</font></p><p>Base: 0000 0000 0000 0000 0000 0000 0000 0000</p><p>Limit: 0000 0000 0000 0000</p></li><li><p>32bit kernel code段</p><p>.quad 0x00cf9a000000ffff</p><p><font color="red">0000 0000</font> 1100 1111 1001 1010 <font color="red">0000 0000</font>，G&#x3D;1，E&#x3D;1，4GB寻址能力</p><p><font color="red">0000 0000 0000 0000</font> <font color="green">1111 1111 1111 1111</font></p><p>Base: 0000 0000 0000 0000 0000 0000 0000 0000</p><p>Limit: 1111 1111 1111 1111</p></li></ul><p>这里有必要提一点的是，虽然code和data段描述符在32和64差不多；但是idt和tss的描述符64和32就不一样了，而是128bit，不过暂时看起来是用不上的</p><p>创建并初始化页表以及页表项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.align 8  # 将下一条语句进行内存对齐 和C语言中结构体内存对齐类似</span><br><span class="line">.org    0x1000  # 固定页目录起始位置，实际线性地址 0xffff800000000000 + 0x100000 + 0x1000;</span><br><span class="line">__PML4E:</span><br><span class="line">    .quad    0x102007  # 设置目录项属性</span><br><span class="line">    .fill    255,8,0</span><br><span class="line">    .quad    0x102007</span><br><span class="line">    .fill    255,8,0</span><br><span class="line">.org    0x2000</span><br><span class="line">__PDPTE:</span><br><span class="line">    .quad    0x103003</span><br><span class="line">    .fill    511,8,0</span><br><span class="line">.org    0x3000</span><br><span class="line">__PDE:</span><br><span class="line">    .quad    0x000083</span><br><span class="line">    .quad    0x200083</span><br><span class="line">    .quad    0x400083</span><br><span class="line">    .quad    0x600083</span><br><span class="line">    .quad    0x800083</span><br><span class="line">    .quad    0xe0000083        /*0x a00000*/</span><br><span class="line">    .quad    0xe0200083</span><br><span class="line">    .quad    0xe0400083</span><br><span class="line">    .quad    0xe0600083        /*0x1000000*/</span><br><span class="line">    .quad    0xe0800083</span><br><span class="line">    .quad    0xe0a00083</span><br><span class="line">    .quad    0xe0c00083</span><br><span class="line">    .quad    0xe0e00083</span><br><span class="line">    .fill    499,8,0</span><br></pre></td></tr></table></figure><p>显然这是一个4级分页，每个页表项是8B，每个页大小是2MB。页表项设置可参考 Intel手册第三卷 4.5 4-LEVEL PAGING AND 5-LEVEL PAGING</p><ul><li><p>PML4E</p><p>.quad    0x102007</p><p>0000 0000 0001 0000 0010 0000 0000 0111</p><p>P(bit0)：1，must be 1 to reference a PML4 table</p><p>R&#x2F;W(bit1)：1，Read&#x2F;write; if 0, writes may not be allowed to the 256-TByte region controlled by this entry</p><p>U&#x2F;S(bit2)：1，User&#x2F;supervisor; if 0, user-mode accesses are not allowed to the 256-TByte region controlled by this entry</p><p>M-1:12：1 0000 0010，Physical address of 4-KByte aligned PML4 table referenced by this entry</p></li><li><p>PDPTE</p><p>.quad    0x103003</p><p>0000 0000 0001 0000 0011 0000 0000 0011</p><p>P(bit 0)：must be 1 to reference a page directory</p><p>R&#x2F;W(bit1)：1，Read&#x2F;write; if 0, writes may not be allowed to the 1-GByte page referenced by this entry</p><p>U&#x2F;S(bit2)：0，User&#x2F;supervisor; if 0, user-mode accesses are not allowed to the 1-GByte page referenced by this entry</p><p>(M–1):12：1 0000 0011，Physical address of 4-KByte aligned page directory referenced by this entry</p></li><li><p>PDE</p><p>.quad    0xe0000083</p><p>1110 0000 0000 0000 0000 0000 1000 0011</p><p>P(bit 0)：1，must be 1 to map a 2-MByte page</p><p>R&#x2F;W(bit1)：1，Read&#x2F;write; if 0, writes may not be allowed to the 2-MByte page referenced by this entry</p><p>U&#x2F;S(bit2)：0，User&#x2F;supervisor; if 0, user-mode accesses are not allowed to the 2-MByte page referenced by this entry</p><p>(M–1):21：1110 0000 0000，Physical address of the 2-MByte page referenced by this entry</p></li></ul><p>PDE中的俩注释就是将物理地址0xe0000000映射到0x00a00000；将物理地址0xe0600000映射到0x1000000</p><h1 id="3-内核主函数"><a href="#3-内核主函数" class="headerlink" title="3 内核主函数"></a>3 内核主函数</h1><p>内核主函数相当于应用程序的主函数，不同之处在于这个内核主函数一般来说不会返回。内核主函数负责调用系统各个模块初始化函数，这些模块初始化结束后，会创建第一个进程init，并将控制权交给init进程(太激动了，终于到C了..不用再受汇编摧残了..)</p><p>下面的程序使得进入kernel显示彩条，为了在屏幕上显示颜色，则必须通过帧缓冲存储器(Frame Buffer)来完成，帧缓存的每个存储单元对应屏幕上的一个像素，整个帧缓存对应一幅帧图像，帧缓存是对每个像素点操作，详见VBE..</p><p>此前loader设置显示芯片的显示模式(模式号：0x180，分辨率：1440*900，颜色深度：32bit)，<code>head.S</code>将帧缓存物理基地址(0xe0000000)映射到0xffff800000a00000处。</p><p>32bit像素点帧缓存格式：0~7位表示蓝色，8~15代表绿色，16~23位代表红色，24~31保留</p><p>屏幕坐标原点(0, 0)位于左上角</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Start_Kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *addr = (<span class="type">int</span> *) <span class="number">0xffff800000a00000</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;  <span class="comment">// 红色条高度是20</span></span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">0</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">1</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">2</span>) = (<span class="type">char</span>) <span class="number">0xff</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">3</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        addr += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">0</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">1</span>) = (<span class="type">char</span>) <span class="number">0xff</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">2</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">3</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        addr += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">0</span>) = (<span class="type">char</span>) <span class="number">0xff</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">1</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">2</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">3</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        addr += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">0</span>) = (<span class="type">char</span>) <span class="number">0xff</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">1</span>) = (<span class="type">char</span>) <span class="number">0xff</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">2</span>) = (<span class="type">char</span>) <span class="number">0xff</span>;</span><br><span class="line">        *((<span class="type">char</span> *) addr + <span class="number">3</span>) = (<span class="type">char</span>) <span class="number">0x00</span>;</span><br><span class="line">        addr += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);  <span class="comment">// 一个死循环 啥也不干</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后瞅瞅编译文件Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: system</span></span><br><span class="line">objcopy -I elf64-x86-64 -S -R <span class="string">&quot;.eh_frame&quot;</span> -R <span class="string">&quot;.comment&quot;</span> -O binary system kernel.bin</span><br><span class="line"></span><br><span class="line"><span class="section">system:head.o main.o </span></span><br><span class="line">ld -b elf64-x86-64 -o system head.o main.o -T Kernel.lds</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">gcc  -mcmodel=large -fno-builtin -m64 -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">head.o:head.S</span></span><br><span class="line">gcc -E  head.S &gt; head.s</span><br><span class="line">as --64 -o head.o head.s</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *.s~ *.s *.S~ *.c~ *.h~ system  Makefile~ Kernel.lds~ kernel.bin</span><br></pre></td></tr></table></figure><p>没啥特别需要了解的..</p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4 实验"></a>4 实验</h1><p>执行完bochs后，显示了四条彩带</p><p><img data-src="/assets/06_Make-MyOS-Start-kernel/image-20220724225723024.png" alt="image-20220724225723024"></p><p>然后看了下gdt和cr3，完全都对的上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:33&gt; creg</span><br><span class="line">CR0=0xe0000011: PG CD NW ac wp ne ET ts em mp PE</span><br><span class="line">CR2=page fault laddr=0x0000000000000000</span><br><span class="line">CR3=0x000000101000</span><br><span class="line">    PCD=page-level cache <span class="built_in">disable</span>=0</span><br><span class="line">    PWT=page-level write-through=0</span><br><span class="line">CR4=0x00000020: pks cet pke smap smep keylock osxsave pcid fsgsbase smx vmx la57 umip osxmmexcpt osfxsr pce pge mce PAE pse de tsd pvi vme</span><br><span class="line">CR8: 0x0</span><br><span class="line">EFER=0x00000500: ffxsr nxe LMA LME sce</span><br><span class="line">XCR0=0x00000001: cet_s cet_u pkru hi_zmm zmm_hi256 opmask bndcfg bndregs ymm sse FPU</span><br><span class="line"></span><br><span class="line">&lt;bochs:34&gt; info gdt</span><br><span class="line">Global Descriptor Table (base=0xffff800000104170, <span class="built_in">limit</span>=135):</span><br><span class="line">GDT[0x0000]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0008]=Code segment, base=0x00000000, <span class="built_in">limit</span>=0x00000000, Execute-Only, Non-Conforming, Accessed, 64-bit</span><br><span class="line">GDT[0x0010]=Data segment, base=0x00000000, <span class="built_in">limit</span>=0x00000000, Read/Write, Accessed</span><br><span class="line">GDT[0x0018]=Code segment, base=0x00000000, <span class="built_in">limit</span>=0x00000000, Execute-Only, Non-Conforming, 64-bit</span><br><span class="line">GDT[0x0020]=Data segment, base=0x00000000, <span class="built_in">limit</span>=0x00000000, Read/Write</span><br><span class="line">GDT[0x0028]=Code segment, base=0x00000000, <span class="built_in">limit</span>=0xffffffff, Execute/Read, Non-Conforming, 32-bit</span><br><span class="line">GDT[0x0030]=Data segment, base=0x00000000, <span class="built_in">limit</span>=0xffffffff, Read/Write</span><br><span class="line">GDT[0x0038]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0040]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0048]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0050]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0058]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0060]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0068]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0070]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0078]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">GDT[0x0080]=??? descriptor hi=0x00000000, lo=0x00000000</span><br><span class="line">You can list individual entries with <span class="string">&#x27;info gdt [NUM]&#x27;</span> or <span class="built_in">groups</span> with <span class="string">&#x27;info gdt [NUM] [NUM]&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节loader程序装载完kernel后，执行了&lt;code&gt;jmp SelectorCode64:OffsetOfKernelFile&lt;/code&gt;命令跳转到kernel部分了，意味着Loader将处理的控制权交给了Kernel&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;处理器把控制权交给kernel后，kernel最先执行的是内核执行头程序。内核执行头程序是一段精心设计的汇编代码，而且必须借助特殊的编译链接方法才能得到最先执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内核头程序负责为操作系统创建段结构和页表结构，设置某些结构的默认处理函数、配置关键寄存器等工作。在完成上述工作后，依然要借助远跳指令才能进入系统内核主程序。&lt;/p&gt;
&lt;p&gt;如何将内核执行头程序编译生成到整个内核程序文件的起始处？手动编写内核程序的链接脚本，在内核程序的链接过程中，链接器会按照链接脚本描述的地址空间布局，把编译好的各个程序片段填充到内核程序文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看完有点懵，都是内核程序为啥要咱手动指定谁先谁后？大概是因为内核头是汇编写的，内核是c写的..要让head先执行就得在lds中指定第一条指令是啥..编译部分参考哈: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/504742628&quot;&gt;ld - 链接脚本学习笔记与实践过程&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Make OS" scheme="https://sidneyding.cn/categories/OS/Make-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>Optimize hexo</title>
    <link href="https://sidneyding.cn/posts/ebc737d8/"/>
    <id>https://sidneyding.cn/posts/ebc737d8/</id>
    <published>2022-07-04T15:26:03.000Z</published>
    <updated>2022-07-24T15:01:38.291Z</updated>
    
    <content type="html"><![CDATA[<p>之前gitee图床挂了，然后gitee想用pages也必须用身份证，折腾一整最后放弃了gitee，直接用github好了(还是github靠谱)，本想着研究一下hugo，但是新东西费时间啊，就继续使用hexo+next了，算是升了个级，并且添加了github CI，解决环境，部署问题，一个字，爽！</p><p>首先搭建hexo博客步骤还是和 <a href="https://sidneygod.github.io/posts/c969bad9/">Use hexo + github to build a blog | Sidney God</a> 一样，按照步骤做就好了，注意这里不要去改node_modules源码了(好像除了markdown和mathjax冲突，也没啥需要改的，kmarked不适用新版本hexo，别折腾了..)，环境部署麻烦</p><span id="more"></span><h1 id="1-Env"><a href="#1-Env" class="headerlink" title="1 Env"></a>1 Env</h1><p>1 创建 <code>your.github.io</code> 仓库用来存放博客源码和静态博客页面，不需要两个仓库，多麻烦啊</p><p>比如 <a href="https://github.com/SidneyGod/SidneyGod.github.io">https://github.com/SidneyGod/SidneyGod.github.io</a> 仓库整俩分支，一个master分支存储博客源码，一个blog-hexo分支存储静态博客页面</p><p>然后将master分支clone到本地<code>git clone git@github.com:SidneyGod/SidneyGod.github.io.git -b master blog</code></p><p>2 生成部署密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一直按回车就好</span></span><br><span class="line">ssh-keygen -f github-deploy-key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后就会有下面公钥和私钥俩文件</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">hexo-deploy-key hexo-deploy-key.pub</span><br></pre></td></tr></table></figure><p>3 配置密钥到仓库中</p><p>路径：Settings – Secrets – Actions – New repository secret</p><p>在<code>Name</code>输入框填写<code>HEXO_DEPLOY_PRI</code>；在<code>Value</code>输入框填写<code>github-deploy-key</code>文件内容</p><p>路径：Settings – Deploy keys – Add deploy key</p><p>在<code>Title</code>输入框填写<code>HEXO_DEPLOY_PUB</code>；在<code>Key</code>输入框填写<code>github-deploy-key.pub</code>文件内容；勾选<code>Allow write access</code>选项</p><p>4 编写github action</p><p>在<code>blog</code>仓库根目录下创建<code>.github/workflows/deploy.yml</code>文件，文件内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">DEPLOY_HEXO</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span>  <span class="comment"># 当push到master分支时触发</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">Sidney</span> <span class="string">Ding</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="string">sidneyding183@gmail.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span>  <span class="comment"># build任务，可以改名字叫job1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span> <span class="string">on</span> <span class="string">node</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span> <span class="string">and</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-18.04</span>  <span class="comment"># 运行的操作系统</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [<span class="string">ubuntu-18.04</span>]</span><br><span class="line">        <span class="attr">node_version:</span> [<span class="number">16.14</span><span class="number">.2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">        <span class="comment"># 将将master分支源码checkout下来，已经有v3版本了</span></span><br><span class="line">        <span class="comment"># https://github.com/marketplace/actions/checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 与上面的类似，安装nodejs环境</span></span><br><span class="line">      <span class="comment"># https://github.com/marketplace/actions/setup-node-js-environment</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 下面这些命令比较好理解，就是配置git环境</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 700 ~/.ssh</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name $GIT_USER</span></span><br><span class="line"><span class="string">          git config --global user.email $GIT_EMAIL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 这个是安装hexo以及美化hexo的插件啥的</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          test -e package.json &amp;&amp; npm install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 这仨命令很熟悉了 就是生成静态页面 并部署上去</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate</span></span><br><span class="line"><span class="string">          hexo deploy</span></span><br></pre></td></tr></table></figure><p>配置就这么些东西，然后再看blog源码..</p><h1 id="2-搭建blog"><a href="#2-搭建blog" class="headerlink" title="2 搭建blog"></a>2 搭建blog</h1><p>简单描述下搭建blog的过程</p><p>根据官方文档：<a href="https://hexo.io/zh-cn/docs/index.html">文档 | Hexo</a>，需要准备好git和nodejs(最新版本必须要12.13.0+，直接用nodejs推荐的版本就好)</p><p>想方便点就装个hexo-cli脚手架，这玩意没有也是行的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 这样安装好后 就可以直接使用 hexo命令了</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment"># 正常的初始化</span></span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 还可以直接clone https://github.com/hexojs/hexo-starter</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:hexojs/hexo-starter.git --depth=1 blogSrc</span><br><span class="line"><span class="built_in">cd</span> blogSrc</span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 想使用hexo命令 每次开shell执行一下</span></span><br><span class="line"><span class="built_in">alias</span> hexo=node_modules/.bin/hexo</span><br></pre></td></tr></table></figure><p>然后就是blog的一些美化操作，这些就不细说了</p><p>这里必须要安装的一个插件”hexo-deployer-git”配置deploy仓库，省事，然后在hexo的配置文件中配置下咱们的仓库</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:SidneyGod/SidneyGod.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">blog-hexo</span></span><br></pre></td></tr></table></figure><p>然后把blogSrc中除了<code>.git</code>和<code>.github</code>的所有文件挪到第一步中clone的blog文件夹，这个时候只需要将新的文件制作成commit push到github就能实现自动部署了</p><h1 id="3-图床问题"><a href="#3-图床问题" class="headerlink" title="3 图床问题"></a>3 图床问题</h1><p>思考良久，免费的图床总是不靠谱的，只有本地才靠谱，而markdown中插入的图片只要插到blog静态资源里面就好了..可能之后图片多了，性能不咋滴吧，但是目前不care了，并且刚好本地图片能兼容起来</p><p>解决方案比较简单，创建<code>blog/scripts/copyAssets.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">exec</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; existsSync, mkdirsSync, copyDir, listDirSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;hexo-fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Util</span> = <span class="built_in">require</span>(<span class="string">&#x27;@next-theme/utils&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> utils = <span class="keyword">new</span> <span class="title class_">Util</span>(hexo, __dirname);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use typora start new post</span></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;new&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="title function_">spawn</span>(<span class="string">&#x27;start  &quot;C:\Program Files\Typora\Typora.exe&quot; &#x27;</span> + data.<span class="property">path</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy md assets file to public!</span></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&#x27;generateBefore&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> srcAssetPath = utils.<span class="title function_">getFilePath</span>(<span class="string">&#x27;../source/_posts/&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> destAssetPath = utils.<span class="title function_">getFilePath</span>(<span class="string">&#x27;../public/assets/&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> assetsPattern = <span class="keyword">new</span> <span class="title class_">RegExp</span>(path.<span class="property">sep</span> + <span class="string">&quot;assets&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dingfs: assetsPattern: &quot;</span> + assetsPattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">existsSync</span>(destAssetPath)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dingfs: Destination Asset Path is not exists! Try to create!&quot;</span>);</span><br><span class="line">        <span class="title function_">mkdirsSync</span>(destAssetPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> assetsSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="title function_">listDirSync</span>(srcAssetPath).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">filePath</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (assetsPattern.<span class="title function_">test</span>(filePath)) &#123;</span><br><span class="line">            <span class="keyword">let</span> splits = filePath.<span class="title function_">split</span>(<span class="string">&#x27;assets&#x27;</span>);</span><br><span class="line">            assetsSet.<span class="title function_">add</span>(splits[<span class="number">0</span>] + <span class="string">&#x27;assets&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assetsSet.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dingfs: &quot;</span> + value);</span><br><span class="line">        <span class="title function_">copyDir</span>(utils.<span class="title function_">getFilePath</span>(srcAssetPath + path.<span class="property">sep</span> + value),</span><br><span class="line">                destAssetPath);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// match markdown image and covert to asset_img </span></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    data.<span class="property">content</span> = data.<span class="property">content</span>.<span class="title function_">replace</span>(<span class="regexp">/&lt;img src=&quot;assets\//g</span>,</span><br><span class="line">        <span class="keyword">function</span>(<span class="params">match_str, label, path</span>)&#123;</span><br><span class="line">            <span class="comment">//console.log(&quot;dingfs: match_str=&quot;+match_str+&quot;-label=&quot;+label+&quot;-path=&quot;+path);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&lt;img src=&quot;/assets/&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可解决了大问题</p><h1 id="4-marked和mathjax冲突"><a href="#4-marked和mathjax冲突" class="headerlink" title="4 marked和mathjax冲突"></a>4 marked和mathjax冲突</h1><p>这个也困扰了很久，用”hexo-filter-mathjax”插件显示数学公式，行内公式可以用单<code>$</code>，没问题；但是<code>\\</code>表示换行，但是marked直接整没了，没得换行了；数学公式中<code>_</code>表示下标，好家伙marked直接解析成<code>&lt;em&gt;</code>标签了..</p><p>百度大都是换kmarked，然后改源码，但是新版本hexo kmarked失效了并且改源码不优雅，主要action不好做；然后是pandoc啥的，感觉都不好用，最终选了</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 是的，没错，用raw来包裹..虽然在typora上看起来多了个这么个符号，但是也还好..</span><br><span class="line">&#123;%raw%&#125;$$这里是数学公式..$$&#123;%endraw%&#125;</span><br></pre></td></tr></table></figure><p>嫌麻烦可以直接<code>git clone https://github.com/SidneyGod/SidneyGod.github.io -b master</code>省事..</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前gitee图床挂了，然后gitee想用pages也必须用身份证，折腾一整最后放弃了gitee，直接用github好了(还是github靠谱)，本想着研究一下hugo，但是新东西费时间啊，就继续使用hexo+next了，算是升了个级，并且添加了github CI，解决环境，部署问题，一个字，爽！&lt;/p&gt;
&lt;p&gt;首先搭建hexo博客步骤还是和 &lt;a href=&quot;https://sidneygod.github.io/posts/c969bad9/&quot;&gt;Use hexo + github to build a blog | Sidney God&lt;/a&gt; 一样，按照步骤做就好了，注意这里不要去改node_modules源码了(好像除了markdown和mathjax冲突，也没啥需要改的，kmarked不适用新版本hexo，别折腾了..)，环境部署麻烦&lt;/p&gt;</summary>
    
    
    
    <category term="Other" scheme="https://sidneyding.cn/categories/Other/"/>
    
    
    <category term="blog" scheme="https://sidneyding.cn/tags/blog/"/>
    
    <category term="hexo" scheme="https://sidneyding.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>[Make MyOS] Find kernel</title>
    <link href="https://sidneyding.cn/posts/ffccb7c5/"/>
    <id>https://sidneyding.cn/posts/ffccb7c5/</id>
    <published>2022-01-16T13:54:41.000Z</published>
    <updated>2022-07-19T15:10:22.640Z</updated>
    
    <content type="html"><![CDATA[<p>《64位》比《32位》多了一步loader.bin似乎，《32位》的下一步直接就是导入C语言，开始搞系统了，《64位》还得再来个loader，接着干吧..这一节很重要，承上启下，甚至于内容也是</p><p>这次把书上的源码上传的gitee了: <a href="https://gitee.com/SidneyGod/make-os/tree/master/00_一个64位操作系统的设计与实现/一个64位操作系统的设计与实现-源代码/第二部分 初级篇/第3章/程序/程序3-4">00_一个64位操作系统的设计与实现/一个64位操作系统的设计与实现-源代码/第二部分 初级篇/第3章/程序/程序3-4 · Sidney/MakeOS - 码云 - 开源中国 (gitee.com)</a></p><p>书上说，Loader的作用很大，大概包括：</p><ul><li><p>检测硬件信息</p><p>主要是通过BIOS中断服务程序来获取和检测硬件信息。BIOS上电自检的大部分信息只能在实模式下获取，内核运行在非实模式下，所以需要在进入内核前将信息检测出来，再作为参数提供给内核程序使用。比如获取ROM，RAM，设备寄存器和内存空洞等资源的物理地址范围交给内存管理单元模块维护；通过VBE功能检测出显示器支持的分辨率，显示模式，刷新率以及显存物理地址以配置合理的显示模式</p></li><li><p>处理器模式切换</p><p>BIOS运行的实模式到32位操作系统用的保护模式，再到64位操作系统用的IA-32e模式(长模式)</p></li><li><p>向内核传递数据</p><p>向内核传递两种数据，控制信息：控制内核执行流程或限制内核某些功能；硬件数据信息：检测出来的硬件数据信息，保存在固定的内存地址中，并将数据其实内存地址和数据长度作为参数传递给内核。</p></li></ul><span id="more"></span><h1 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1 源码分析"></a>1 源码分析</h1><p>然后就是分析loader源码了，六百多行吧..但是其实和boot差不多，又是一个找kernel的过程，这下没画图了，感觉还好..</p><h2 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">; 程序从物理地址0x10000(1M)处 也就是boot加载loader的地址</span><br><span class="line">org 10000h</span><br><span class="line">jmp Label_Start</span><br><span class="line">; 相当于C语言中的include 也就是FAT12文件的系统结构</span><br><span class="line">%include    "fat12.inc"</span><br><span class="line"></span><br><span class="line">BaseOfKernelFile    equ 0x00</span><br><span class="line">OffsetOfKernelFile  equ 0x100000  ; kernel真正加载的位置</span><br><span class="line"></span><br><span class="line">BaseTmpOfKernelAddr equ 0x00</span><br><span class="line">; 内核程序临时转存空间 因为内核程序读取操作是通过BIOS中断服务int 13h实现的</span><br><span class="line">; BIOS在实模式下只支持上限为1MB的物理地址空间寻址，所以需要先搬到临时转存空间</span><br><span class="line">; 再通过特殊方式搬运到1MB以上的内存空间</span><br><span class="line">OffsetTmpOfKernelFile   equ 0x7E00</span><br><span class="line"></span><br><span class="line">; 真正用途 存储物理内存结构</span><br><span class="line">MemoryStructBufferAddr  equ 0x7E00</span><br><span class="line"></span><br><span class="line">; 32位段描述表</span><br><span class="line">[SECTION gdt]</span><br><span class="line">LABEL_GDT:      dd  0,0  ; 空描述符</span><br><span class="line">LABEL_DESC_CODE32:  dd  0x0000FFFF,0x00CF9A00  ; 代码段</span><br><span class="line">LABEL_DESC_DATA32:  dd  0x0000FFFF,0x00CF9200  ; 数据段</span><br><span class="line">GdtLen  equ $ - LABEL_GDT  ; GDT长度</span><br><span class="line">GdtPtr  dw  GdtLen - 1  ; 这个就是 limit</span><br><span class="line">        dd  LABEL_GDT  ; GDT基址</span><br><span class="line">SelectorCode32  equ LABEL_DESC_CODE32 - LABEL_GDT  ; 代码段选择子</span><br><span class="line">SelectorData32  equ LABEL_DESC_DATA32 - LABEL_GDT  ; 数据段选择子</span><br><span class="line"></span><br><span class="line">; 64位段描述表</span><br><span class="line">[SECTION gdt64]</span><br><span class="line">LABEL_GDT64:        dq  0x0000000000000000</span><br><span class="line">LABEL_DESC_CODE64:  dq  0x0020980000000000</span><br><span class="line">LABEL_DESC_DATA64:  dq  0x0000920000000000</span><br><span class="line">GdtLen64    equ $ - LABEL_GDT64</span><br><span class="line">GdtPtr64    dw  GdtLen64 - 1</span><br><span class="line">            dd  LABEL_GDT64</span><br><span class="line">SelectorCode64  equ LABEL_DESC_CODE64 - LABEL_GDT64</span><br><span class="line">SelectorData64  equ LABEL_DESC_DATA64 - LABEL_GDT64</span><br></pre></td></tr></table></figure><p>这里的转存空间只是临时用，用完可以另作他用了</p><h2 id="1-2-BITS伪指令"><a href="#1-2-BITS伪指令" class="headerlink" title="1.2 BITS伪指令"></a>1.2 BITS伪指令</h2><p>此处追加定义了一个名为<code>.s16</code>的段，BITS伪指令可以通知NASM编译器生成的代码，将运行在16位或32位的处理器上，语法是<code>BITS 16</code>或<code>BITS 32</code></p><p>当NASM编译器处于16位下，使用32位数据指令需要在指令前加前缀<code>0x66</code>，使用32位地址指令时需要在指令前加入前缀<code>0x67</code>。而在32位下，使用16位指令也需要加指令前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s16]  ; 定义一个名为 .s16 的段</span><br><span class="line">[BITS 16]  ; 通知NASM编译器生成的代码将运行在16位宽的处理器上</span><br><span class="line">Label_Start:</span><br><span class="line">    mov ax, cs</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, 0x7c00</span><br><span class="line"></span><br><span class="line">;=======    display on screen : Start Loader......</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000fh</span><br><span class="line">    mov dx, 0200h       ;row 2</span><br><span class="line">    mov cx, 12</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartLoaderMessage</span><br><span class="line">    int 10h  ; 屏幕上输出"Start Loader"</span><br></pre></td></tr></table></figure><h2 id="1-3-打开A20功能"><a href="#1-3-打开A20功能" class="headerlink" title="1.3 打开A20功能"></a>1.3 打开A20功能</h2><p>这个在第0天提到了，就是A20M# pin，参考Intel manual volume 3 chapter 8.7.13.4。</p><blockquote><p><strong>A20M# pin</strong> — On an IA-32 processor, the A20M# pin is typically provided for compatibility with the Intel 286 processor. Asserting this pin causes bit 20 of the physical address to be masked (forced to zero) for all external bus memory accesses. Processors supporting Intel Hyper-Threading Technology provide one A20M# pin, which affects the operation of both logical processors within the physical processor.<br>The functionality of A20M# is used primarily by older operating systems and not used by modern operating systems. On newer Intel 64 processors, A20M# may be absent.</p></blockquote><p>意思就是历史原因，最初处理器只有20根地址线，使得处理器只能寻址1MB以内物理地址空间，但是现在的处理器已经远超20位地址线了，但是为了兼容，出现了开启或禁止1MB以上地址空间开关(也就是只用20根地址线，还是用更多)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;=======    open address A20</span><br><span class="line">    push ax</span><br><span class="line">    in  al, 92h  ; 从92端口读入A20地址线的状态</span><br><span class="line">    or  al, 00000010b  ; 将第2位置1</span><br><span class="line">    out 92h, al  ; 写回92号端口 打开A20</span><br><span class="line">    pop ax</span><br><span class="line">    cli  ; 关中断 因为保护模式下中断处理的机制不同，不关中断会出现错误</span><br><span class="line">    db  0x66  ; 声明在16位情况下使用32位宽数据指令</span><br><span class="line">    ; 加载到gdtr，因为现在段描述符表在内存中，我们必须要让CPU知道段描述符表在哪个位置</span><br><span class="line">    ; 通过使用lgdt就可以将源加载到gdtr寄存器中</span><br><span class="line">    lgdt [GdtPtr]</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or  eax, 1</span><br><span class="line">    mov cr0, eax  ; 这3句将寄存器CR0的第0位置1开启保护模式</span><br><span class="line">    mov ax, SelectorData32</span><br><span class="line">    mov fs, ax  ; 这2句 将数据段的选择子加载到FS段寄存器</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    and al, 11111110b</span><br><span class="line">    mov cr0, eax  ; 这3句 将cr0的bit0置0，也就是关掉保护模式，重新进入实模式</span><br><span class="line">    sti  ; 与cli对应，恢复外部中断</span><br><span class="line">;=======    reset floppy</span><br><span class="line">    xor ah, ah</span><br><span class="line">    xor dl, dl</span><br><span class="line">    int 13h  ; 重置软盘</span><br></pre></td></tr></table></figure><p>开启A20功能可以通过键盘(8042键盘控制器上恰好有空闲的端口引脚，输出端口P2，引脚P21)，但是键盘是低速设备，开启较慢。所以**可以使用A20快速门，使用IO端口0x92处理A20信号线(注意0x92的0位用于向机器发送复位信号，置位会导致重启)**。还可以通过BIOS中断程序INT 15h主功能号AX=2401可开启A20地址线，功能号AX=2400可禁用A20地址线，功能号AX=2403可查询A20地址线当前状态。还有一种方法是通过读0xee端口来开启A20信号线，写该端口则会禁止。</p><p>当进入保护模式后，为FS段加载新的数据段值，一旦完成数据段加载就从保护模式退出，并开启外部中断，目的是为了让FS段寄存器可以在实模式下寻址能力超过1MB(扩展到32位4GB)，可以借助FS段寄存器的特殊寻址能力将内核程序转移到1MB以上的内存地址空间中。注意，在物理平台下，当段寄存器拥有这种特殊能力之后，如果对其重新赋值就会失去特殊能力，转变成原始的实模式段寄存器</p><h2 id="1-4-寻找kernel-bin"><a href="#1-4-寻找kernel-bin" class="headerlink" title="1.4 寻找kernel.bin"></a>1.4 寻找kernel.bin</h2><p>这段内容与<code>boot.asm</code>中找<code>loader.bin</code>类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">;=======    search kernel.bin</span><br><span class="line">    mov word [SectorNo], SectorNumOfRootDirStart  ; 依旧是从第19个扇区开始</span><br><span class="line">Lable_Search_In_Root_Dir_Begin:</span><br><span class="line">    cmp word [RootDirSizeForLoop], 0  ; RootDirSizeForLoop初始值为根目录扇区数 每找完一个扇区就-- 若等于0表示没找到</span><br><span class="line">    jz  Label_No_LoaderBin  ; 找不到就跳到Label_No_LoaderBin</span><br><span class="line">    dec word [RootDirSizeForLoop]  ; RootDirSizeForLoop--</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov es, ax  ; 不能通过立即数给es赋值，需要通过ax中转一下 es=00H</span><br><span class="line">    mov bx, 8000h  ; bx=8000H</span><br><span class="line">    mov ax, [SectorNo]  ; ax=19</span><br><span class="line">    mov cl, 1  ; cl=1</span><br><span class="line">    call Func_ReadOneSector  ; 调用Func_ReadOneSector 读取一个扇区的内容到bx开始的内存地址</span><br><span class="line">    mov si, KernelFileName  ; 将文件名"kernel.bin"加载到ds:si中</span><br><span class="line">    mov di, 8000h  ; 将es:di指向扇区内容起始地址</span><br><span class="line">    cld  ; 清除EFLAGS.DF置0，这样通过LODSB从ds:si加载内容到al后，si就会递增1</span><br><span class="line">    mov dx, 10h  ; dx记录一个扇区可容纳的目录项个数。一个扇区最多有512B/32B=16=0x10个目录项</span><br><span class="line"></span><br><span class="line">Label_Search_For_LoaderBin:</span><br><span class="line">    cmp dx, 0</span><br><span class="line">    jz  Label_Goto_Next_Sector_In_Root_Dir</span><br><span class="line">    dec dx  ; 上面三句就是一个扇区所有目录项都找完了 可以去下一个扇区找了</span><br><span class="line">    mov cx, 11  ; 文件名的长度11B 包括文件名和扩展名 但不包括分隔符"."</span><br><span class="line"></span><br><span class="line">Label_Cmp_FileName:</span><br><span class="line">    cmp cx, 0  ; 文件名都比较完了 都相等 那当然就是找到了 跳到Label_FileName_Found</span><br><span class="line">    jz  Label_FileName_Found</span><br><span class="line">    dec cx</span><br><span class="line">    lodsb  ; 从ds:si读取一个字节到寄存器AL 然后si+=1(取决于EFLAGS.DF)</span><br><span class="line">    cmp al, byte [es:di]  ; 一个字符一个字符去比较</span><br><span class="line">    jz  Label_Go_On  ; 如果相等 继续</span><br><span class="line">    jmp Label_Different  ; 如果不相等</span><br><span class="line"></span><br><span class="line">Label_Go_On:</span><br><span class="line">    inc di  ; di++</span><br><span class="line">    jmp Label_Cmp_FileName</span><br><span class="line"></span><br><span class="line">Label_Different:</span><br><span class="line">    and di, 0FFE0h</span><br><span class="line">    add di, 20h</span><br><span class="line">    mov si, KernelFileName</span><br><span class="line">    jmp Label_Search_For_LoaderBin</span><br><span class="line"></span><br><span class="line">Label_Goto_Next_Sector_In_Root_Dir:</span><br><span class="line">    add word    [SectorNo], 1</span><br><span class="line">    jmp Lable_Search_In_Root_Dir_Begin</span><br><span class="line">    </span><br><span class="line">;=======    display on screen : ERROR:No KERNEL Found</span><br><span class="line">Label_No_LoaderBin:  ; 没找到kernel.bin就会跳到这，结束</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0300h       ; row 3</span><br><span class="line">    mov cx, 21</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, NoLoaderMessage  ; 屏幕上输出"ERROR:No KERNEL Found"</span><br><span class="line">    int 10h</span><br><span class="line">    jmp $</span><br></pre></td></tr></table></figure><h2 id="1-5-加载kernel-bin"><a href="#1-5-加载kernel-bin" class="headerlink" title="1.5 加载kernel.bin"></a>1.5 加载kernel.bin</h2><p>找到<code>kernel.bin</code>，就将其读到内存中，与<code>boot.asm</code>找到<code>loader.bin</code>后的操作差不多，只是这里更加曲折一点，是先读取到0x7e00~0x7fff这段中，再通过FS段寄存器挪到0x100000之上的物理内存空间。但是这里段寄存器被重新赋值了，导致在实际物理平台上会出问题，书上说第7章再解决这个问题..</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">;=======    found kernel.bin name in root director struct</span><br><span class="line">Label_FileName_Found:  ; 找到了kernel.bin就到这..</span><br><span class="line">    mov ax, RootDirSectors</span><br><span class="line">    and di, 0FFE0h</span><br><span class="line">    add di, 01Ah</span><br><span class="line">    mov cx, word [es:di]</span><br><span class="line">    push cx</span><br><span class="line">    add cx, ax</span><br><span class="line">    add cx, SectorBalance  ; 得到实际起始扇区号</span><br><span class="line">    mov eax, BaseTmpOfKernelAddr ; eax=00H</span><br><span class="line">    mov es, eax</span><br><span class="line">    mov bx, OffsetTmpOfKernelFile   ; bx=7E00H</span><br><span class="line">    mov ax, cx  ; 将存储文件实际扇区号放到ax中</span><br><span class="line"></span><br><span class="line">Label_Go_On_Loading_File:</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    mov ah, 0Eh</span><br><span class="line">    mov al, '.'</span><br><span class="line">    mov bl, 0Fh</span><br><span class="line">    int 10h  ; 每读一个扇区就在屏幕上打印一个 .</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    mov cl, 1</span><br><span class="line">    call Func_ReadOneSector  ; 将一个扇区的内容读到0x7E00~0x7FF这段内存中</span><br><span class="line">    pop ax</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">    push cx</span><br><span class="line">    push eax</span><br><span class="line">    push fs</span><br><span class="line">    push edi</span><br><span class="line">    push ds</span><br><span class="line">    push esi</span><br><span class="line"></span><br><span class="line">    mov cx, 200h  ; 200h = 512</span><br><span class="line">    mov ax, BaseOfKernelFile  ; 00H</span><br><span class="line">    mov fs, ax</span><br><span class="line">    ; 目的地址 fs:edi = 0x00:0x100000，此处使用了FS段寄存器的超能力，它可以寻址到4G</span><br><span class="line">    mov edi, dword [OffsetOfKernelFileCount]  ; OffsetOfKernelFile 0x100000</span><br><span class="line">    mov ax, BaseTmpOfKernelAddr  ; 00H</span><br><span class="line">    mov ds, ax</span><br><span class="line">    ; 源地址 ds:esi = 0x00:0x7e00</span><br><span class="line">    mov esi, OffsetTmpOfKernelFile  ; 7E00H</span><br><span class="line"></span><br><span class="line">Label_Mov_Kernel:</span><br><span class="line">    ; 一个字节一个字节将0x7e00之后的512字节东西挪到0x100000</span><br><span class="line">    mov al, byte [ds:esi]</span><br><span class="line">    mov byte [fs:edi], al</span><br><span class="line">    inc esi</span><br><span class="line">    inc edi</span><br><span class="line">    loop Label_Mov_Kernel  ; 执行loop指令前，先要将cx--，若cx不为0则跳到Label_Mov_Kernel</span><br><span class="line"></span><br><span class="line">    mov eax, 0x1000  ; loader.bin起始于内存地址0x1000:0x00</span><br><span class="line">    mov ds, eax</span><br><span class="line">    ; 每移动512字节内容后，保存新的内存地址到内存OffsetOfKernelFileCount字段处</span><br><span class="line">    mov dword [OffsetOfKernelFileCount],  edi</span><br><span class="line"></span><br><span class="line">    pop esi</span><br><span class="line">    pop ds</span><br><span class="line">    pop edi</span><br><span class="line">    pop fs</span><br><span class="line">    pop eax</span><br><span class="line">    pop cx</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">    call    Func_GetFATEntry</span><br><span class="line">    cmp ax, 0FFFh  ; 直到读到文件尾</span><br><span class="line">    jz  Label_File_Loaded  ; 文件已加载..</span><br><span class="line">    push ax</span><br><span class="line">    mov dx, RootDirSectors</span><br><span class="line">    add ax, dx</span><br><span class="line">    add ax, SectorBalance</span><br><span class="line">    jmp Label_Go_On_Loading_File  ; 继续下一个扇区</span><br></pre></td></tr></table></figure><h2 id="1-6-加载完毕"><a href="#1-6-加载完毕" class="headerlink" title="1.6 加载完毕"></a>1.6 加载完毕</h2><p>加载完毕后会在屏幕上打印一个字符<code>G</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Label_File_Loaded:</span><br><span class="line">    mov ax, 0B800h</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ah, 0Fh             ; 0000: 黑底    1111: 白字</span><br><span class="line">    ; 将’G’这个字符放到了内存中gs:((80 * 0 + 39) * 2)的这个地方，这个gs在这里是0B800h以这里为起点，向后偏移一段区域的内存专门用于存储在屏幕上显示的字，每个字占位两个字节，每行最多显示80个字符，所以就有上面的公式：((80 * 0 + 39) * 2)这表示第0行的39列显示该字符</span><br><span class="line">    mov al, 'G'</span><br><span class="line">    mov [gs:((80 * 0 + 39) * 2)], ax    ; 屏幕第 0 行, 第 39 列。</span><br><span class="line"></span><br><span class="line">; 当Loader引导加载程序完成内核程序的加载工作后，软盘驱动器将不再使用</span><br><span class="line">KillMotor:  ; 关闭全部软盘驱动器</span><br><span class="line">    push dx</span><br><span class="line">    mov dx, 03F2h</span><br><span class="line">    mov al, 0</span><br><span class="line">    out dx, al</span><br><span class="line">    pop dx</span><br></pre></td></tr></table></figure><p>这段代码首先将GS段寄存器的基地址设置在0B800H地址处；并将AH寄存器赋值为0FH，表示黑底白字；将AL寄存器赋值为字母’G’，要打印的字符；然后将AX寄存器的值填充到0B800H向后偏移<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.845ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7445.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1611.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(2611.4,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(3333.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4333.9,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(5333.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5945.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(6945.3,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>处，每个字符占2个字节，每行最多显示80个字符，所以就是0行39列显示’G’。<strong>从内存地址0B800H开始，是一段专门用于显示字符的内存空间，其中每个字符占用两个字节的内存空间，低字节保存显示的字符，高字节保存字符的颜色属性</strong>。该方法相比于INT 10H中断相比更符合操作显卡内存的习惯，后面会通过像素内存在屏幕上作画或播放视频。</p><p>I/O端口3F2H控制着软盘驱动器不少硬件功能</p><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>7</td><td>MOT_EN3</td><td>控制软驱D马达，1：启动；0：关闭</td></tr><tr><td>6</td><td>MOT_EN2</td><td>控制软驱C</td></tr><tr><td>5</td><td>MOT_EN1</td><td>控制软驱B</td></tr><tr><td>4</td><td>MOT_EN0</td><td>控制软驱A</td></tr><tr><td>3</td><td>DMA_INT</td><td>1：允许DMA和中断请求；0：禁止DMA和中断请求</td></tr><tr><td>2</td><td>RESET</td><td>1：允许软盘控制器发送控制信息；0：复位软盘驱动器</td></tr><tr><td>1</td><td>DRV_SEL1</td><td>00~11用于选择软盘驱动器A~D</td></tr><tr><td>0</td><td>DRV_SEL0</td><td>同上</td></tr></tbody></table><h2 id="1-7-获取内存信息"><a href="#1-7-获取内存信息" class="headerlink" title="1.7 获取内存信息"></a>1.7 获取内存信息</h2><p>当内核程序不再借助临时转存空间后，这块临时转存空间将用于保存物理内存地址空间信息</p><p>物理地址空间信息由一个结构体数组构成，计算机平台地址划分情况都能从这个结构体数组成反映出来，它记录的地址空间类型包括可用物理内存地址空间、设备寄存器地址空间、内存空洞等。系统会在初始化内存管理单元时解析该结构数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">;=======    get memory address size type</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0400h       ;row 4</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetMemStructMessage</span><br><span class="line">    int 10h  ; 打印 "Start Get Memory Struct."</span><br><span class="line"></span><br><span class="line">    ; 当内核程序不再借助临时转存空间后，这块临时转存空间 0x7E00~0x7FFF将用于保存物理地址空间信息</span><br><span class="line">    mov ebx, 0  ; 指向内存区域，第一次调用时ebx=0，被称为continuation value</span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov di, MemoryStructBufferAddr  ; 设置填充地址es:di=0x00:0x7e00</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_Struct:</span><br><span class="line">    mov eax, 0x0E820  ; 功能号</span><br><span class="line">    mov ecx, 20       ; 固定读取20字节</span><br><span class="line">    mov edx, 0x534D4150  ; 固定值SMAP</span><br><span class="line">    int 15h  ; 使用INT 15H来获取物理地址空间信息</span><br><span class="line">    jc  Label_Get_Mem_Fail  ; 没有进位表示读取成功</span><br><span class="line"></span><br><span class="line">    add di, 20  ; 推进填充地址</span><br><span class="line">    cmp ebx, 0  ; 输出时，ebx表示下一个内存区域，当ebx=0 &amp;&amp; CF=0时，表示当前是内存最后一个区域</span><br><span class="line">    jne Label_Get_Mem_Struct  ; 循环读取</span><br><span class="line">    jmp Label_Get_Mem_OK</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_Fail:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0500h       ;row 5</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetMemStructErrMessage</span><br><span class="line">    int 10h  ; 输出 Get Memory Struct ERROR</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_OK:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0600h       ;row 6</span><br><span class="line">    mov cx, 29</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetMemStructOKMessage</span><br><span class="line">    int 10h ; 输出 Get Memory Struct SUCCESSFUL!</span><br></pre></td></tr></table></figure><p>INT 15H：每执行一次这个指令将会将一个描述内存区域的数据结构保存到<code>ES:DI</code>，然后返回一个ebx，用于确定下一个能够探测的内存区域，当ebx=0时，表示当前已经时最后一个内存区域了。那么ebx的初始值呢，就是设置成ebx=0。其中可能遇到检查发生错误的情况，这个指令就会直接将CF设置为1。</p><p>输入时各个寄存器作用：</p><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td>eax</td><td>功能码，当输入e820h时能够探测内存</td></tr><tr><td>ebx</td><td>主要用于指向内存区域，第一次调用时ebx=0，被称为continuation value</td></tr><tr><td>es:di</td><td>用于指令执行后，在指向的内存写入描述内存区域的数据结构ARDS(Address Range Descriptor Structure)</td></tr><tr><td>ecx</td><td>用于限制指令填充的ARDS的大小，实际上大多数情况这个是无效的，无论ecx设置为多少，BIOS始终会填充20字节的ARDS</td></tr><tr><td>edx</td><td>0534D4150h，表示4个ASCII字符(‘SMAP’)，只是个签名，输入时在edx，输出时将会在eax中</td></tr></tbody></table><p>输出时各个寄存器结果:</p><table><thead><tr><th>寄存器</th><th>结果</th></tr></thead><tbody><tr><td>CF</td><td>当没有发生错误时，CF=0，否则CF=1</td></tr><tr><td>eax</td><td>0534D4150h</td></tr><tr><td>ebx</td><td>指向下一个内存区域，而不是调用之前的内存区域，当ebx=0且CF=0时，表示当前是最后一个内存区域。</td></tr><tr><td>es:di</td><td>和调用之前一样，如果要保存多个ARDS，需要手动修改es:di</td></tr><tr><td>ecx</td><td>返回写入的ARDS的大小</td></tr></tbody></table><p>看一下Linux对E820H的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bionic/libc/kernel/uapi/asm-x86/asm/e820.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820entry</span> {</span></span><br><span class="line">    __u64 addr; <span class="comment">/* start of memory segment */</span></span><br><span class="line">    __u64 size; <span class="comment">/* size of memory segment */</span></span><br><span class="line">    __u32 type; <span class="comment">/* type of memory segment 能被OS使用的；保留的(不能被OS使用的)*/</span></span><br><span class="line">} __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> {</span></span><br><span class="line">    __u32 nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820entry</span> <span class="title">map</span>[<span class="title">E820_X_MAX</span>];</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>BIOS查找出一个一个的内存布局entry，并放入到一个保存地址范围描述符结构的缓冲区中</p><h2 id="1-8-获取SVGA信息"><a href="#1-8-获取SVGA信息" class="headerlink" title="1.8 获取SVGA信息"></a>1.8 获取SVGA信息</h2><p>这一段并不重要..</p><p>获取SVGA(Super Video Graphics Array) VBE相关信息，这玩意不百度不知道，一百度，tmd又是一门难搞的技术..参考《最新VESA SVGA图形图像编程秘技》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">;=======    get SVGA information</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0800h       ;row 8</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetSVGAVBEInfoMessage</span><br><span class="line">    int 10h</span><br><span class="line"></span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov di, 0x8000  ; 指向存放VbeInfoBlock结构体的缓冲区指针</span><br><span class="line">    mov ax, 4F00h  ; 返回VBE控制器信息</span><br><span class="line">    int 10h</span><br><span class="line">    cmp ax, 004Fh  ; VBE返回状态</span><br><span class="line">    jz  .KO</span><br><span class="line"></span><br><span class="line">;=======    Fail</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0900h       ;row 9</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAVBEInfoErrMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA VBE Info ERROR"</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">.KO:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0A00h       ;row 10</span><br><span class="line">    mov cx, 29</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAVBEInfoOKMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA VBE Info SUCCESSFUL!"</span><br></pre></td></tr></table></figure><p>VBE功能调用的共同点：</p><p>AH必须等于4F，表示是VBE标准；</p><p>AL是VBE功能号，其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="15.26ex" height="1.932ex" role="img" focusable="false" viewBox="0 -716 6745.1 854"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1833.6,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(2583.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(3542.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(4598.1,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mi" transform="translate(5098.1,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(5857.1,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>；</p><p>BL等于子功能号，可以没有子功能；</p><p>调用INT 10H；</p><p>返回值。</p><p>VBE功能调用返回值一般均在AX中：</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.089ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4901.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1708.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2764.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(3264.6,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(4013.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：支持该功能；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex;" xmlns="http://www.w3.org/2000/svg" width="11.089ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 4901.6 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1708.8,0)"><path data-c="2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"></path></g><g data-mml-node="mn" transform="translate(2764.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(3264.6,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(4013.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：不支持该功能；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.994ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4859.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1915.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2971.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(3971.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：功能调用成功；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.994ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4859.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1915.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2971.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(3971.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：功能调用失败；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.994ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4859.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1915.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2971.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(3971.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：当前硬件配置不支持该功能；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.994ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4859.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1915.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2971.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(3971.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：当前显示模式不支持该功能</p><p>这里使用的就是INT 10H AH=00H：返回VBE信息</p><p>输入：</p><p>AX=4F00H</p><p>ES:DI=指向VBE信息块的指针</p><p>输出：</p><p>AX=VBE返回值</p><p>其中VbeInfoBlock的定义参考Linux，<strong>VBE 1.x版本的信息块大小为256B；VBE 2.0+及后续版本VbeInfoBlock大小为512B</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/drivers/gpu/drm/radeon/atombios.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_INFO_BLOCK</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VBE_VERSION_UNION           UpdatableVBE_Info;</span><br><span class="line">    UCHAR                       Reserved[<span class="number">222</span>];  <span class="comment">// 保留</span></span><br><span class="line">    UCHAR                       OemData[<span class="number">256</span>];   <span class="comment">// VESA2.0版以上定义</span></span><br><span class="line">} VBE_INFO_BLOCK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">VBE_VERSION_UNION</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VBE_2_0_INFO_BLOCK_UPDATABLE    VBE_2_0_InfoBlock;</span><br><span class="line">    VBE_1_2_INFO_BLOCK_UPDATABLE    VBE_1_2_InfoBlock;</span><br><span class="line">} VBE_VERSION_UNION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_2_0_INFO_BLOCK_UPDATABLE</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VBE_1_2_INFO_BLOCK_UPDATABLE CommonBlock;</span><br><span class="line">    USHORT                       OemSoftRev;  <span class="comment">// VBE软件的OEM修订版本号，BCD码</span></span><br><span class="line">    PTR_32_BIT_UNION             OemVendorNamePtr;  <span class="comment">// 指向显示卡制造厂商的字符串指针</span></span><br><span class="line">    PTR_32_BIT_UNION             OemProductNamePtr;  <span class="comment">// 指向显示卡制造商的字符串的指针</span></span><br><span class="line">    PTR_32_BIT_UNION   OemProductRevPtr;  <span class="comment">// 指向显示卡修订版本号或唱片等级的字符串的指针</span></span><br><span class="line">} VBE_2_0_INFO_BLOCK_UPDATABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_1_2_INFO_BLOCK_UPDATABLE</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    UCHAR               VbeSignature[<span class="number">4</span>];  <span class="comment">// 字符串"VESA"  offset:0</span></span><br><span class="line">    USHORT              VbeVersion;       <span class="comment">// VBE版本号，BCD码  offset:4</span></span><br><span class="line">    PTR_32_BIT_UNION    OemStringPtr;     <span class="comment">// 指向OEM厂商的标志串的指针  offset:6</span></span><br><span class="line">    UCHAR               Capabilities[<span class="number">4</span>];  <span class="comment">// 显示卡特性  offset:10</span></span><br><span class="line">    PTR_32_BIT_UNION    VideoModePtr;     <span class="comment">// 指向所支持显示模式列表的指针  offset:14</span></span><br><span class="line">    USHORT              TotalMemory;      <span class="comment">// 显示内存大小，单位为64KB</span></span><br><span class="line">} VBE_1_2_INFO_BLOCK_UPDATABLE;</span><br></pre></td></tr></table></figure><h2 id="1-9-输出SVGA信息"><a href="#1-9-输出SVGA信息" class="headerlink" title="1.9 输出SVGA信息"></a>1.9 输出SVGA信息</h2><p>上面只是获取到了VBE信息，完了还得打印出来了呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">;=======    Get SVGA Mode Info</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0C00h       ;row 12</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetSVGAModeInfoMessage</span><br><span class="line">    int 10h  ; 输出 "Start Get SVGA Mode Info"</span><br><span class="line"></span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov si, 0x800e  ; es:si=0x0000:0x800e</span><br><span class="line">    mov esi, dword [es:si]  ; 取出指针存入esi</span><br><span class="line">    mov edi, 0x8200  ; es:di=0x0000:0x8200</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_Get:  ; 循环获取所有的svga_mode_info</span><br><span class="line">    mov cx, word [es:esi]</span><br><span class="line">;=======    display SVGA mode information</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov al, ch</span><br><span class="line">    call Label_DispAL  ; 显示16进制数值在屏幕上 后面再看</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov al, cl</span><br><span class="line">    call Label_DispAL</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    cmp cx, 0FFFFh  ; 如果是最后要给word则跳到Finish</span><br><span class="line">    jz  Label_SVGA_Mode_Info_Finish</span><br><span class="line"></span><br><span class="line">    mov ax, 4F01h</span><br><span class="line">    int 10h  ; 4F01H显示特定模式信息，获取成功则向ES:DI填充256字节</span><br><span class="line"></span><br><span class="line">    cmp ax, 004Fh</span><br><span class="line">    jnz Label_SVGA_Mode_Info_FAIL   </span><br><span class="line">    add esi, 2  ; 获取list中下一个word</span><br><span class="line">    add edi, 0x100  ; 刚填充了256字节，继续前进256字节</span><br><span class="line">    jmp Label_SVGA_Mode_Info_Get</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_FAIL:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0D00h       ;row 13</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAModeInfoErrMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA Mode Info ERROR"</span><br><span class="line"></span><br><span class="line">Label_SET_SVGA_Mode_VESA_VBE_FAIL:</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_Finish:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0E00h       ;row 14</span><br><span class="line">    mov cx, 30</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAModeInfoOKMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA Mode Info SUCCESSFUL!"</span><br></pre></td></tr></table></figure><p><strong>问题1：为什么是0x800e？为什么是dword？为什么从0x8200开始？</strong></p><p>因为VideoModePtr在VBE_INFO_BLOCK的偏移就是14，就是e；VideoModePtr大小是4B；因为VBE 2.0+版本之后的VbeInfoBlock大小是512B，所以还是往后挪256B稳妥点</p><p><strong>问题2：INT 10H AX=4F10H</strong></p><p>这个功能号的作用是返回VBE特定模式信息</p><p>输入：</p><p>AX=4F01H</p><p>CX=模式号</p><p>ES:DI=指向VBE特定模式信息块的指针</p><p>输出：</p><p>AX=VBE返回值</p><p>其中特定模式信息块数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/drivers/gpu/drm/radeon/atombios.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VESA_MODE_INFO_BLOCK</span></span></span><br><span class="line"><span class="class">{</span>  <span class="comment">// 共256B</span></span><br><span class="line"><span class="comment">// Mandatory information for all VBE revisions</span></span><br><span class="line">    USHORT ModeAttributes;  <span class="comment">// dw  ?   ; mode attributes</span></span><br><span class="line">    UCHAR  WinAAttributes;  <span class="comment">// db  ?   ; window A attributes</span></span><br><span class="line">    UCHAR  WinBAttributes;  <span class="comment">// db  ?   ; window B attributes</span></span><br><span class="line">    USHORT WinGranularity;  <span class="comment">// dw  ?   ; window granularity</span></span><br><span class="line">    USHORT WinSize;         <span class="comment">// dw  ?   ; window size</span></span><br><span class="line">    USHORT WinASegment;     <span class="comment">// dw  ?   ; window A start segment</span></span><br><span class="line">    USHORT WinBSegment;     <span class="comment">// dw  ?   ; window B start segment</span></span><br><span class="line">    ULONG  WinFuncPtr;      <span class="comment">// dd  ?   ; real mode pointer to window function</span></span><br><span class="line">    USHORT BytesPerScanLine;<span class="comment">// dw  ?   ; bytes per scan line</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 1.2 and above</span></span><br><span class="line">    USHORT XResolution;      <span class="comment">// dw  ?   ; horizontal resolution in pixels or characters</span></span><br><span class="line">    USHORT YResolution;      <span class="comment">// dw  ?   ; vertical resolution in pixels or characters</span></span><br><span class="line">    UCHAR  XCharSize;        <span class="comment">// db  ?   ; character cell width in pixels</span></span><br><span class="line">    UCHAR  YCharSize;        <span class="comment">// db  ?   ; character cell height in pixels</span></span><br><span class="line">    UCHAR  NumberOfPlanes;   <span class="comment">// db  ?   ; number of memory planes</span></span><br><span class="line">    UCHAR  BitsPerPixel;     <span class="comment">// db  ?   ; bits per pixel</span></span><br><span class="line">    UCHAR  NumberOfBanks;    <span class="comment">// db  ?   ; number of banks</span></span><br><span class="line">    UCHAR  MemoryModel;      <span class="comment">// db  ?   ; memory model type</span></span><br><span class="line">    UCHAR  BankSize;         <span class="comment">// db  ?   ; bank size in KB</span></span><br><span class="line">    UCHAR  NumberOfImagePages;<span class="comment">// db    ?   ; number of images</span></span><br><span class="line">    UCHAR  ReservedForPageFunction;<span class="comment">//db  1   ; reserved for page function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Direct Color fields(required for direct/6 and YUV/7 memory models)</span></span><br><span class="line">    UCHAR  RedMaskSize; <span class="comment">// db ? ; size of direct color red mask in bits</span></span><br><span class="line">    UCHAR  RedFieldPosition; <span class="comment">// db ? ; bit position of lsb of red mask</span></span><br><span class="line">    UCHAR  GreenMaskSize; <span class="comment">// db ? ; size of direct color green mask in bits</span></span><br><span class="line">    UCHAR  GreenFieldPosition; <span class="comment">// db  ? ; bit position of lsb of green mask</span></span><br><span class="line">    UCHAR  BlueMaskSize; <span class="comment">// db  ? ; size of direct color blue mask in bits</span></span><br><span class="line">    UCHAR  BlueFieldPosition; <span class="comment">// db  ? ; bit position of lsb of blue mask</span></span><br><span class="line">    UCHAR  RsvdMaskSize; <span class="comment">// db ? ; size of direct color reserved mask in bits</span></span><br><span class="line">    UCHAR  RsvdFieldPosition;  <span class="comment">// db ? ; bit position of lsb of reserved mask</span></span><br><span class="line">    UCHAR  DirectColorModeInfo;  <span class="comment">// db ? ; direct color mode attributes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 2.0 and above</span></span><br><span class="line">    ULONG  PhysBasePtr; <span class="comment">// dd ? ; physical address for flat memory frame buffer</span></span><br><span class="line">    ULONG  Reserved_1; <span class="comment">// dd 0 ; reserved - always set to 0</span></span><br><span class="line">    USHORT Reserved_2; <span class="comment">// dw 0 ; reserved - always set to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 3.0 and above</span></span><br><span class="line">    USHORT LinBytesPerScanLine;  <span class="comment">// dw ? ; bytes per scan line for linear modes</span></span><br><span class="line">    UCHAR  BnkNumberOfImagePages;<span class="comment">// db ? ; number of images for banked modes</span></span><br><span class="line">    UCHAR  LinNumberOfImagPages; <span class="comment">// db ? ; number of images for linear modes</span></span><br><span class="line">    UCHAR  LinRedMaskSize; <span class="comment">// db ? ; size of direct color red mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRedFieldPosition;  <span class="comment">// db ? ; bit position of lsb of red mask(linear modes)</span></span><br><span class="line">    UCHAR  LinGreenMaskSize;  <span class="comment">// db ? ; size of direct color green mask(linear modes)</span></span><br><span class="line">    UCHAR  LinGreenFieldPosition;<span class="comment">// db ? ; bit position of lsb of green mask(linear modes)</span></span><br><span class="line">    UCHAR  LinBlueMaskSize; <span class="comment">// db ? ; size of direct color blue mask(linear modes)</span></span><br><span class="line">    UCHAR  LinBlueFieldPosition; <span class="comment">// db ? ; bit position of lsb of blue mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRsvdMaskSize;  <span class="comment">// db ? ; size of direct color reserved mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRsvdFieldPosition; <span class="comment">// db  ?   ; bit position of lsb of reserved mask(linear modes)</span></span><br><span class="line">    ULONG  MaxPixelClock;   <span class="comment">// dd  ?   ; maximum pixel clock(in Hz) for graphics mode</span></span><br><span class="line">    UCHAR  Reserved;        <span class="comment">// db  190 dup (0)</span></span><br><span class="line">} VESA_MODE_INFO_BLOCK;</span><br></pre></td></tr></table></figure><p>至于每个属性啥意思，这就不列了，《最新VESA SVGA图形图像编程秘技》这本书上有..当然了《64位》这本书第7章也有说</p><p><strong>问题3：Label_DispAL作用</strong></p><p>这是放在后面的一段辅助函数，作用是将16进制数值显示在屏幕上，原理和Label_File_Loaded一样</p><p>输入：</p><p>AL=要显示的十六进制数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;=======    display num in al</span><br><span class="line">Label_DispAL:</span><br><span class="line">    push    ecx</span><br><span class="line">    push    edx</span><br><span class="line">    push    edi</span><br><span class="line"></span><br><span class="line">    mov edi, [DisplayPosition]  ; 字符的屏幕偏移量 初始值是0</span><br><span class="line">    mov ah, 0Fh  ; 字符属性 黑底白字</span><br><span class="line">    mov dl, al  ; 保存字符值到dl</span><br><span class="line">    shr al, 4  ; 右移4位 取字符高位</span><br><span class="line">    mov ecx, 2  ; 计算高位一次 计算低位一次 一共要loop两次</span><br><span class="line">.begin:</span><br><span class="line">    and al, 0Fh</span><br><span class="line">    cmp al, 9  ; 这里实际上比较的是高4位 右移了</span><br><span class="line">    ja  .1  ; 如果大于9直接跳到 .1</span><br><span class="line">    add al, '0'  ; 如果小于或等于9 与字符'0'相加</span><br><span class="line">    jmp .2</span><br><span class="line">.1:</span><br><span class="line">    sub al, 0Ah  ; 先减去 0AH</span><br><span class="line">    add al, 'A'  ; 再加上 字符'A'</span><br><span class="line">.2:</span><br><span class="line">    mov [gs:edi], ax  ; 将AX保存到gs为基址，DisplayPosition为偏移的显示字符内存空间中</span><br><span class="line">    add edi, 2  ; 下一个字符</span><br><span class="line"></span><br><span class="line">    mov al, dl</span><br><span class="line">    loop .begin</span><br><span class="line">    mov [DisplayPosition], edi  ; 保存字符偏移量到内存</span><br><span class="line"></span><br><span class="line">    pop edi</span><br><span class="line">    pop edx</span><br><span class="line">    pop ecx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="1-10-设置SVGA模式"><a href="#1-10-设置SVGA模式" class="headerlink" title="1.10 设置SVGA模式"></a>1.10 设置SVGA模式</h2><p>根据查询的信息配置芯片显示模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;=======    set the SVGA mode(VESA VBE)</span><br><span class="line">    mov ax, 4F02h</span><br><span class="line">    mov bx, 4180h ; mode: 0x180 or 0x143</span><br><span class="line">    int 10h</span><br><span class="line">    cmp ax, 004Fh</span><br><span class="line">    jnz Label_SET_SVGA_Mode_VESA_VBE_FAIL</span><br></pre></td></tr></table></figure><p>INT 10H AX=4F02H，设置VESA VBE模式</p><p>输入：</p><p>AX=4F02H</p><p>BX=模式号</p><p>输出：</p><p>AX=VBE返回值</p><p>其中模式号说明如下：</p><p>VESA 2.0版本以上增加了BX中D14、D15两个位定义</p><p>D0~D8：9位模式号</p><p>D9~D13：保留，必须为0</p><p>D14：置0，使用普通窗口页面缓存模式，使用VBE功能05H切换显示页面；置1，使用大的线性缓存区，其地址可从VBE功能01H的返回信息ModeInfo中获得</p><p>D15：置0，清除显示缓存；置1，不清除显示缓存</p><p>讲道理这个模式号，能百度到，但是资料好像不多..书上提供的两个0x180和0x143</p><table><thead><tr><th>模式</th><th>列</th><th>行</th><th>物理地址</th><th>像素点位宽</th></tr></thead><tbody><tr><td>0x180</td><td>1440</td><td>900</td><td>E0000000H</td><td>32 bit</td></tr><tr><td>0x143</td><td>800</td><td>600</td><td>E0000000H</td><td>32 bit</td></tr></tbody></table><p>这里D15 D14是01b</p><h2 id="1-11-切换模式"><a href="#1-11-切换模式" class="headerlink" title="1.11 切换模式"></a>1.11 切换模式</h2><h3 id="1-11-1-切换保护模式"><a href="#1-11-1-切换保护模式" class="headerlink" title="1.11.1 切换保护模式"></a>1.11.1 切换保护模式</h3><p>检测完硬件信息后，就该脱离实模式到保护模式了</p><p>在<strong>实模式</strong>下，程序可以操作任何地址空间，而且无法限制程序的执行权限。这种模式给设置硬件功能带来许多方便，但是给程序执行的安全性和稳定性带来了灾难性的后果。并且实模式寻址能力有限，所以需要切换到保护模式</p><p>在<strong>保护模式</strong>下，处理器按照程序执行级别分为0、1、2、3四个等级(由高到低)，目前Linux只使用了两个0内核级，3应用程序级。保护模式还引入了分页功能，有了分页，段机制就显得多余，然后又有了IA-32e模式(长模式)</p><p><strong>IA-32e模式</strong>简化段级保护措施的复杂性，升级内存寻址能力，同时还扩展页管理单元的组织结构和页面大小，推出新的系统调用方式和高级可编程中断控制器</p><p>在切换保护模式前，必须创建一段可在保护模式下执行的代码及必要的系统数据结构(IDT/GDT/LDT描述表可一个，任务状态段TSS结构，至少一个页目录和页表，至少一个异常/中断处理模块)，初始化GDTR寄存器、IDTR寄存器、控制寄存器CR1~4、MTTRs内存范围类型寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;=======    init IDT GDT goto protect mode </span><br><span class="line">    cli  ; 关中断</span><br><span class="line">    db  0x66</span><br><span class="line">    lgdt [GdtPtr]  ; 将GDT加载到GDTR中，这里的GDT就是初始化里面的</span><br><span class="line"></span><br><span class="line">    ; 已使用cli禁止外部中断，所以在切换到保护模式过程中不会产生中断和异常，不必完整初始化IDT，</span><br><span class="line">    ; 只要有相应的结构体即可。能够保证处理器在模式切换过程中不会产生一场，即使没有IDT也可以</span><br><span class="line">;   db  0x66</span><br><span class="line">;   lidt [IDT_POINTER]</span><br><span class="line"></span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or  eax, 1    ; CR0.PE，也可以同时开启CR0.PG，开启分页</span><br><span class="line">    mov cr0, eax  ; 执行后，就已经进入到保护模式</span><br><span class="line"></span><br><span class="line">    ; jmp 代码段选择子:偏移 = jmp 0x08:xxxx，目的是改变处理器的执行流水线，</span><br><span class="line">    ; 进而使处理器加载执行保护模式的代码段</span><br><span class="line">    jmp dword SelectorCode32:GO_TO_TMP_Protect</span><br></pre></td></tr></table></figure><p>详细解释一下，GDT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 32位段描述表</span><br><span class="line">[SECTION gdt]</span><br><span class="line">LABEL_GDT:      dd  0,0  ; 空描述符，offset +0H</span><br><span class="line">LABEL_DESC_CODE32:  dd  0x0000FFFF,0x00CF9A00  ; 代码段，offset +8H</span><br><span class="line">LABEL_DESC_DATA32:  dd  0x0000FFFF,0x00CF9200  ; 数据段，offset +10H</span><br><span class="line">GdtLen  equ $ - LABEL_GDT  ; GDT长度</span><br><span class="line">GdtPtr  dw  GdtLen - 1  ; 这个就是 limit</span><br><span class="line">        dd  LABEL_GDT  ; GDT基址</span><br><span class="line">SelectorCode32  equ LABEL_DESC_CODE32 - LABEL_GDT  ; 代码段选择子</span><br><span class="line">SelectorData32  equ LABEL_DESC_DATA32 - LABEL_GDT  ; 数据段选择子</span><br></pre></td></tr></table></figure><p>首先第一项LABEL_GDT必须是空描述符，dd两个，也就是占8字节</p><p>然后来看CODE32和DATA32，根据之前学习的段描述</p><p><img data-src="/assets/05_Make-MyOS-Find-kernel/202112072244745.png" alt="202112072244745"></p><p>其中CODE32：</p><p>0x00CF9A00，0000 0000 1100 1111 1001 1010 0000 0000</p><p>0x0000FFFF，0000 0000 0000 0000 1111 1111 1111 1111</p><p>得出Base=00000000H，Seg Limit=FFFFFH，G=1，D/B=1，P=1，S=1，Type=1010b</p><p>所以基址是0x00000000处；由于G=1，所以段限是0xffffffff，也就是4GB寻址能力；S=1且Type=1010b，表示代码段，可执行可读</p><p>其中DATA32：</p><p>0x00CF9200，0000 0000 1100 1111 1001 0010 0000 0000</p><p>0x0000FFFF，0000 0000 0000 0000 1111 1111 1111 1111</p><p>得出Base=00000000H，Seg Limit=FFFFFH，G=1，D/B=1，P=1，S=1，Type=0010b</p><p>所以基址是0x00000000处；由于G=1，所以段限是0xffffffff，也就是4GB寻址能力；S=1且Type=0010b，表示数据段，可读可写</p><p>GdtLen，每个表项占8字节，三个也就是24B</p><p>GdtPtr，前面是表界限，后面是表基地址</p><p>SelectorCode32，代码段选择子，这里具体数值就是0x8</p><p>SelectorData32，数据段选择子，这里具体数值就是0x10</p><p>完了再说IDT，虽然不需要IDT，但是还是要为IDT开辟存储空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;=======    tmp IDT</span><br><span class="line">IDT:</span><br><span class="line">    times   0x50    dq  0  ; Define Quadra Word，8B</span><br><span class="line">IDT_END:</span><br><span class="line">IDT_POINTER:</span><br><span class="line">        dw  IDT_END - IDT - 1</span><br><span class="line">        dd  IDT</span><br></pre></td></tr></table></figure><p>DB 定义的变量为字节型 Define Byte</p><p>DW 定义的变量为字类型（双字节）Define Word</p><p>DD 定义的变量为双字型（4字节）Define Double Word</p><p>DQ 定义的变量为4字型（8字节）Define Quadra Word</p><p>DT 定义的变量为10字节型 Define Ten Byte</p><p>书上总结的模式切换步骤，参考Intel卷3第9.9.1节Switching to Protected Mode</p><ol><li>执行CLI禁止可屏蔽硬件中断，对于不可屏蔽中断NMI只能借助外部电路才能禁止(模式切换过程中必须保证不能产生异常或中断)</li><li>执行LGDT将GDT的基地址和长度加载到GDTR寄存器</li><li>执行MOV CR0置CR0.PE标志位(可同时置位CR0.PG)</li><li>一旦MOV CR0执行结束，紧随其后必须执行一条跳转指令(JMP)或调用(CALL)指令，以切换到保护模式的代码段去执行</li><li>通过执行JMP或CALL指令，可以改变处理器执行流水线，进而使处理器加载执行保护模式的代码段</li><li>如果开启分页机制，那么MOV CR0指令和JMP/CALL指令必须位于identity mapped页面内，至于JMP/CALL指令的目标地址则无需是identity mapped</li><li>如需使用LDT，则必须借助LLDT指令将GDT内的LDT段选择子加载到LDTR寄存器中</li><li>执行LTR将一个TSS段描述符的选择子加载到TR任务寄存器</li><li>进入保护模式后，数据段寄存器仍旧保留着实模式的段数据，必须重新加载数据段选择子或使用JMP/CALL指令执行新任务，便可将其更新位保护模式</li><li>执行LIDT，将保护模式下的IDT表的基地址和长度加载到IDTR</li><li>执行STI指令是能可屏蔽硬件中断，并执行必要的硬件操作使能NMI不可屏蔽中断</li></ol><blockquote><ol><li>Disable interrupts. A CLI instruction disables maskable hardware interrupts. NMI interrupts can be disabled with external circuitry. (Software must guarantee that no exceptions or interrupts are generated during the mode switching operation.)</li><li>Execute the LGDT instruction to load the GDTR register with the base address of the GDT.</li><li>Execute a MOV CR0 instruction that sets the PE flag (and optionally the PG flag) in control register CR0.</li><li>Immediately following the MOV CR0 instruction, execute a far JMP or far CALL instruction. (This operation is typically a far jump or call to the next instruction in the instruction stream.)</li><li>The JMP or CALL instruction immediately after the MOV CR0 instruction changes the flow of execution and serializes the processor.</li><li>If paging is enabled, the code for the MOV CR0 instruction and the JMP or CALL instruction must come from a page that is identity mapped (that is, the linear address before the jump is the same as the physical address after paging and protected mode is enabled). The target instruction for the JMP or CALL instruction does not need to be identity mapped.</li><li>If a local descriptor table is going to be used, execute the LLDT instruction to load the segment selector for the LDT in the LDTR register.</li><li>Execute the LTR instruction to load the task register with a segment selector to the initial protected-mode task or to a writable area of memory that can be used to store TSS information on a task switch.</li><li>After entering protected mode, the segment registers continue to hold the contents they had in real-address mode. The JMP or CALL instruction in step 4 resets the CS register. Perform one of the following operations to update the contents of the remaining segment registers.<br>— Reload segment registers DS, SS, ES, FS, and GS. If the ES, FS, and/or GS registers are not going to be used, load them with a null selector.<br>— Perform a JMP or CALL instruction to a new task, which automatically resets the values of the segment registers and branches to a new code segment.</li><li>Execute the LIDT instruction to load the IDTR register with the address and limit of the protected-mode IDT.</li><li>Execute the STI instruction to enable maskable hardware interrupts and perform the necessary hardware operation to enable NMI interrupts.</li></ol></blockquote><h3 id="1-11-2-切换IA-32e模式"><a href="#1-11-2-切换IA-32e模式" class="headerlink" title="1.11.2 切换IA-32e模式"></a>1.11.2 切换IA-32e模式</h3><p>和进入保护模式差不多，只不过还要开启分页机制，参考Intel卷3第9.8.5 Initializing IA-32e Mode：</p><blockquote><ol><li>Starting from protected mode, disable paging by setting CR0.PG = 0. Use the MOV CR0 instruction to disable paging (the instruction must be located in an identity-mapped page).</li><li>Enable physical-address extensions (PAE) by setting CR4.PAE = 1. Failure to enable PAE will result in a #GP fault when an attempt is made to initialize IA-32e mode.</li><li>Load CR3 with the physical base address of the Level 4 page map table (PML4) or Level 5 page map table(PML5).</li><li>Enable IA-32e mode by setting IA32_EFER.LME = 1.</li><li>Enable paging by setting CR0.PG = 1. This causes the processor to set the IA32_EFER.LMA bit to 1. The MOV CR0 instruction that enables paging and the following instructions must be located in an identity-mapped page (until such time that a branch to non-identity mapped pages can be effected).</li></ol></blockquote><ol><li>在保护模式下，使用MOV CR0.PG指令关闭分页机制</li><li>置位CR4.PAE，开启物理地址扩展功能。若失败则产生#GP</li><li>PML4或PML5的物理基地址加载到CR3寄存器中</li><li>置位IA32_EFER.LME，打开IA-32e模式</li><li>置位CR0.PG开启分页机制，此时处理器会自动置位IA32_EFER.LMA。当执行MOV CR0指令开启分页时，其后续指令必须位于identity-mapped page(直到处理器进入IA-32e模式后，才能使用非identity-mapped page)</li></ol><p>在切到IA-32e模式之前应当先检查支不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s32]</span><br><span class="line">[BITS 32]</span><br><span class="line">GO_TO_TMP_Protect:</span><br><span class="line">;=======    go to tmp long mode</span><br><span class="line">    mov ax, 0x10</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov esp, 7E00h</span><br><span class="line">    call support_long_mode</span><br><span class="line">    test eax, eax  ; 目的操作数和源操作数按位与，与and不同的是test不改变目的操作数</span><br><span class="line">    jz no_support  ; 等于0时跳转 jmp $</span><br><span class="line"></span><br><span class="line">;=======    test support long mode or not</span><br><span class="line">support_long_mode:</span><br><span class="line">    mov eax, 0x80000000</span><br><span class="line">    cpuid</span><br><span class="line">    cmp eax, 0x80000001</span><br><span class="line">    setnb al  </span><br><span class="line">    jb support_long_mode_done</span><br><span class="line">    mov eax, 0x80000001</span><br><span class="line">    cpuid</span><br><span class="line">    bt edx, 29  ; bit test，将edx bit 29拷贝至CF</span><br><span class="line">    setc al  ; Set byte if carry，若CF=1，则al=1；否则al=0</span><br><span class="line">support_long_mode_done:</span><br><span class="line">    movzx eax, al  ; 将al全0扩展到eax，高位补0</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>进入保护模式首要任务是初始化各个寄存器以及栈指针，然后检测处理器是否支持IA-32e模式，这里是根据cpuid来判断的</p><p>CPUID指令分为两组，一组返回基本信息，一组返回扩展信息，Intel手册里面描述这个指令很复杂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 0</span><br><span class="line">cpuid</span><br></pre></td></tr></table></figure><p>执行完CPUID指令后，EAX中返回的值就是返回基本信息时，功能代码的最大值，在执行CPUID指令要求返回基本信息时，EAX中的值必须小于或等于该值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 80000000h</span><br><span class="line">cpuid</span><br></pre></td></tr></table></figure><p>执行完CPUID指令后，EAX中返回的值就是返回扩展信息时，功能代码的最大值，在执行CPUID指令要求返回扩展信息时，EAX中的值必须小于或等于该值。</p><p>如果这个号码大于等于0x80000001就说明可以支持long_mode，那么我们就直接跳转到support_long_mode_done，如果不行的话，需要检查这个号码的第29位，如果29位符合预期，那么说明也是可以支持的，否则就不行。</p><p>如果支持IA-32e模式，接下来就将为IA-32e模式配置临时页目录项和页表项。页目录首地址设置在0x90000地址处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;=======    init temporary page table 0x90000</span><br><span class="line">    mov dword   [0x90000],  0x91007</span><br><span class="line">    mov dword   [0x90004],  0x00000</span><br><span class="line">    mov dword   [0x90800],  0x91007</span><br><span class="line">    mov dword   [0x90804],  0x00000</span><br><span class="line"></span><br><span class="line">    mov dword   [0x91000],  0x92007</span><br><span class="line">    mov dword   [0x91004],  0x00000</span><br><span class="line"></span><br><span class="line">    mov dword   [0x92000],  0x000083</span><br><span class="line">    mov dword   [0x92004],  0x000000</span><br><span class="line">    mov dword   [0x92008],  0x200083</span><br><span class="line">    mov dword   [0x9200c],  0x000000</span><br><span class="line">    mov dword   [0x92010],  0x400083</span><br><span class="line">    mov dword   [0x92014],  0x000000</span><br><span class="line">    mov dword   [0x92018],  0x600083</span><br><span class="line">    mov dword   [0x9201c],  0x000000</span><br><span class="line">    mov dword   [0x92020],  0x800083</span><br><span class="line">    mov dword   [0x92024],  0x000000</span><br><span class="line">    mov dword   [0x92028],  0xa00083</span><br><span class="line">    mov dword   [0x9202c],  0x000000</span><br></pre></td></tr></table></figure><p>然后就是开启IA-32e模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">;=======    load GDTR</span><br><span class="line">    db  0x66</span><br><span class="line">    lgdt [GdtPtr64]  ; 加载64位的GDT到GDTR</span><br><span class="line">    mov ax, 0x10</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov esp,    7E00h</span><br><span class="line"></span><br><span class="line">;=======    open PAE</span><br><span class="line">    mov eax, cr4</span><br><span class="line">    bts eax, 5  ; Bit Test and Set，先将指定位的值存储到CF标志中然后设置该位 CR4.PAE</span><br><span class="line">    mov cr4, eax</span><br><span class="line">;=======    load    cr3</span><br><span class="line">    mov eax,    0x90000  ; 1001 0000...0000</span><br><span class="line">    mov cr3,    eax  ; 位12~位63，page directory base</span><br><span class="line">;=======    enable long-mode</span><br><span class="line">    mov ecx, 0C0000080h  ; IA32_EFER</span><br><span class="line">    rdmsr  ; 将MSR寄存器组中IA32_EFER值读到edx:eax</span><br><span class="line">    bts eax, 8  ; IA32_EFER.LME=1</span><br><span class="line">    wrmsr  ; 写回</span><br><span class="line">;=======    open PE and paging</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    bts eax, 0  ; CR0.PE=1</span><br><span class="line">    bts eax, 31 ; CR0.PG=1</span><br><span class="line">    mov cr0, eax</span><br><span class="line"></span><br><span class="line">    ; 使用JMP/CALL将CS段寄存器的更新为IA-32e模式的代码段描述符</span><br><span class="line">    jmp SelectorCode64:OffsetOfKernelFile</span><br></pre></td></tr></table></figure><p>IA32_EFER寄存器位于MSR寄存器组内，它的第8位是LME标志位，为了操作IA32_EFER寄存器必须借助特殊汇编指令RDMSR/WRMSR</p><p>在访问MSR寄存器前，必须向ECX寄存器(在64位模式下RCX寄存器高32位被忽略)传入寄存器地址。而目标寄存器则是由EDX:EAX组成的64位寄存器代表，其中EDX寄存器保存MSR寄存器高32位，EAX寄存器保存低32位</p><p>RDMSR/WRMSR必须在0特权级或实模式下执行。在使用这两条指令前，应该使用CPUID指令(CPUID.01H:EDX[5]=1)来检测处理器是否支持MSR寄存器组</p><p>这里的0C0000080h在Intel卷4有提到 Table 2-3. MSRs in Processors Based on Intel® Core™ Microarchitecture (Contd.)</p><p>C000_0080H IA32_EFER Unique Extended Feature Enables</p><p>IA32_EFER寄存器布局</p><table><thead><tr><th>63:12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7:1</th><th>0</th></tr></thead><tbody><tr><td>Reserved</td><td>Execute-disable bit enable (NXE)</td><td>IA-32e mode active (LMA)</td><td>Reserved</td><td>IA-32e mode enable (LME)</td><td>Reserved</td><td>SysCall enable (SCE)</td></tr></tbody></table><p>伴随着loader最后一条指令，处理器控制权已经交给了kernel.bin了，等着下一节的探索..</p><h1 id="2-实践"><a href="#2-实践" class="headerlink" title="2 实践"></a>2 实践</h1><p>代码看完了当然要动手了，这下文件比较多，主要是4个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fat12.inc   <span class="comment"># fat12格式文件</span></span><br><span class="line">boot.asm    <span class="comment"># 之前的boot.asm文件，主要功能是找loader.bin</span></span><br><span class="line">loader.asm  <span class="comment"># 这次的源码，主要功能是找kernel.bin，并开启临时IA-32e模式，进入kernel</span></span><br><span class="line">Makefile    <span class="comment"># 后面源文件越来越多，不能一个个敲 nasm boot.asm -o boot.bin</span></span><br></pre></td></tr></table></figure><p>简单看下Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: boot.bin loader.bin</span></span><br><span class="line"><span class="section">loader.bin:</span></span><br><span class="line">nasm loader.asm -o loader.bin</span><br><span class="line"><span class="section">boot.bin:</span></span><br><span class="line">nasm boot.asm -o boot.bin</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.bin *.asm~ Makefile~ loader.bin boot.bin</span><br></pre></td></tr></table></figure><p>执行make的时候会生成boot.bin和loader.bin，执行make clean的时候会删除bin文件和临时文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成bin文件</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个1.44MB的img软盘镜像</span></span><br><span class="line">sidney@ubuntu:~/Work/MyOS/day04$ bximage </span><br><span class="line">========================================================================</span><br><span class="line">                                bximage</span><br><span class="line">                  Disk Image Creation Tool <span class="keyword">for</span> Bochs</span><br><span class="line">          <span class="variable">$Id</span>: bximage.c 11315 2012-08-05 18:13:38Z vruppert $</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">Do you want to create a floppy disk image or a hard disk image?</span><br><span class="line">Please <span class="built_in">type</span> hd or fd. [hd] fd</span><br><span class="line"></span><br><span class="line">Choose the size of floppy disk image to create, <span class="keyword">in</span> megabytes.</span><br><span class="line">Please <span class="built_in">type</span> 0.16, 0.18, 0.32, 0.36, 0.72, 1.2, 1.44, 1.68, 1.72, or 2.88.</span><br><span class="line"> [1.44] 1.44</span><br><span class="line">I will create a floppy image with</span><br><span class="line">  cyl=80</span><br><span class="line">  heads=2</span><br><span class="line">  sectors per track=18</span><br><span class="line">  total sectors=2880</span><br><span class="line">  total bytes=1474560</span><br><span class="line"></span><br><span class="line">What should I name the image?</span><br><span class="line">[a.img] boot.img</span><br><span class="line"></span><br><span class="line">Writing: [] Done.</span><br><span class="line"></span><br><span class="line">I wrote 1474560 bytes to boot.img.</span><br><span class="line"></span><br><span class="line">The following line should appear <span class="keyword">in</span> your bochsrc:</span><br><span class="line">  floppya: image=<span class="string">"boot.img"</span>, status=inserted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建boot.img，dd 命令的 conv=notrunc 字段很重要，保证软盘文件不截断</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将boot.img挂载到/media，这个/media可以随便创建一个目录</span></span><br><span class="line">sudo mount boot.img /media/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于boot.img已经拥有了FAT12文件系统（说白了，就是可以解析FAT表项的能力，代码实现于Func_GetFATEntry部分），</span></span><br><span class="line"><span class="comment"># 并且mount命令可以实现FAT数据区与根目录区的联系，从而达到只需要操作media文件夹实质就是操作boot.img的效果</span></span><br><span class="line"><span class="comment">#（说白了，如果我们往挂载好之后的media分区复制数据，其实就是把数据复制到boot.img）</span></span><br><span class="line">sudo <span class="built_in">cp</span> loader.bin /media/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还没有写kernel，先弄个假的进去</span></span><br><span class="line"><span class="built_in">cp</span> loader.bin kernel.bin</span><br><span class="line">sudo <span class="built_in">cp</span> kernel.bin /media/</span><br><span class="line"><span class="comment"># 数据都写进boot.img就不需要挂载了</span></span><br><span class="line">sudo umount /media</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里不是用qemu-system-i386了，执行完一直在闪烁？</span></span><br><span class="line">qemu-system-x86_64 -drive file=boot.img,format=raw,<span class="keyword">if</span>=floppy</span><br></pre></td></tr></table></figure><p>讲道理，应该算成功了..</p><h2 id="2-1-安装bochs"><a href="#2-1-安装bochs" class="headerlink" title="2.1 安装bochs"></a>2.1 安装bochs</h2><p>在<strong>1.3 打开A20功能</strong>那段代码sti后面加一个<code>jmp $</code>看段寄存器状态，百度了下，qemu好像没招，乖乖安装bochs..</p><p>下载：<a href="https://sourceforge.net/projects/bochs/files/bochs/2.7/bochs-2.7.tar.gz/download">bochs-2.7.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf bochs-2.7.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bochs-2.7</span><br><span class="line"></span><br><span class="line">./confugure --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">./configure --with-x11 --with-wx --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-smp --enable-long-phy-address --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls --enable-handlers-chaining --enable-trace-linking --enable-configurable-msrs --enable-show-ips --enable-cpp --enable-debugger --enable-debugger-gui --enable-iodebug --enable-all-optimizations --enable-readline --enable-logging --enable-stats --enable-assert-checks --enable-fpu --enable-vmx --enable-svm --enable-protection-keys --enable-cet --enable-3dnow --enable-alignment-check --enable-monitor-mwait --enable-perfmon --enable-memtype --enable-avx --enable-evex --enable-x86-debugger --enable-pci --enable-pcidev --enable-usb --enable-usb-ohci --enable-usb-ehci --enable-usb-xhci --enable-ne2000 --enable-pnic --enable-e1000 --enable-raw-serial --enable-clgd54xx --enable-voodoo --enable-cdrom --enable-sb16 --enable-es1370 --enable-gameport --enable-busmouse --enable-xpm</span><br><span class="line"></span><br><span class="line">make -j8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时会报一些错 简单改改就好了</span></span><br><span class="line"><span class="built_in">cp</span> ./bx_debug/parser.cpp ./bx_debug/parser.cc</span><br><span class="line"><span class="built_in">cp</span> misc/bximage.cpp misc/bximage.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/hdimage.cpp iodev/hdimage/hdimage.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/vmware3.cpp iodev/hdimage/vmware3.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/vmware4.cpp iodev/hdimage/vmware4.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/vpc.cpp iodev/hdimage/vpc.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/vbox.cpp iodev/hdimage/vbox.cc</span><br><span class="line"><span class="built_in">cp</span> misc/bxhub.cpp misc/bxhub.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/network/netutil.cpp iodev/network/netutil.cc</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line">bochs -<span class="built_in">help</span> cpu</span><br></pre></td></tr></table></figure><p>然后根据书上在用户home目录创建bochs的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bochsrc</span><br><span class="line"></span><br><span class="line">plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1</span><br><span class="line">config_interface: textconfig</span><br><span class="line">display_library: x</span><br><span class="line">cpu: model=corei7_haswell_4770,count=1:1:1,ips=4000000,quantum=16,reset_on_triple_fault=1</span><br><span class="line">cpu: cpuid_limit_winnt=0,ignore_bad_msrs=1,mwait_is_nop=0,msrs=<span class="string">"msrs.def"</span></span><br><span class="line">cpuid: x86_64=1,level=6,mmx=1,sep=1,simd=avx512,apic=x2apic,aes=1,movbe=1,xsave=1,sha=1,adx=1,xsaveopt=1,</span><br><span class="line">cpuid: avx_f16c=1,avx_fma=1,bmi=bmi2,1g_pages=1,pcid=1,fsgsbase=1,smep=1,smap=1,mwait=1,vmx=1,family=6</span><br><span class="line">cpuid: model=0x1a, stepping=5, vendor_string=<span class="string">"GenuineIntel"</span>,brand_string=<span class="string">"Intel(R) Core(TM) i7-4770 CPU (Haswell)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#memory: guest=2048, host=2048</span></span><br><span class="line"></span><br><span class="line">romimage: file=/usr/local/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">vga: extension=vbe, update_freq=5</span><br><span class="line"><span class="comment">#voodoo: enabled=1, model=voodoo1</span></span><br><span class="line"></span><br><span class="line">keyboard: <span class="built_in">type</span>=mf, serial_delay=250, paste_delay=100000, user_shortcut=none</span><br><span class="line">mouse: <span class="built_in">type</span>=ps2,enabled=0,toggle=ctrl+mbutton</span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line">clock: <span class="built_in">sync</span>=none, time0=<span class="built_in">local</span>, rtc_sync=0</span><br><span class="line"><span class="comment">#cmosimage: file=cmos.img, rtc_init=time0</span></span><br><span class="line">private_colormap: enabled=0</span><br><span class="line"></span><br><span class="line">floppya: <span class="built_in">type</span>=1_44, 1_44=<span class="string">"boot.img"</span>, status=inserted, write_protected=0</span><br><span class="line"><span class="comment"># no floppyb</span></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: <span class="built_in">type</span>=none</span><br><span class="line">ata0-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata1-master: <span class="built_in">type</span>=none</span><br><span class="line">ata1-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line">boot: floppy</span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>: bochsout.log</span><br><span class="line">logprefix: %t-%e-@%i-%d</span><br><span class="line">panic: action=ask</span><br><span class="line">error: action=report</span><br><span class="line">info: action=report</span><br><span class="line">debug: action=ignore, pci=report</span><br><span class="line">debugger_log: -</span><br><span class="line"></span><br><span class="line">com1: enabled=1, mode=null</span><br><span class="line">com2: enabled=0</span><br><span class="line">com3: enabled=0</span><br><span class="line">com4: enabled=0</span><br><span class="line"></span><br><span class="line">parport1: enabled=1, file=none</span><br><span class="line">parport2: enabled=0</span><br><span class="line"></span><br><span class="line">sound: waveoutdrv=sdl, waveindrv=alsa, midioutdrv=dummy</span><br><span class="line">speaker: enabled=1, mode=system, volume=15</span><br><span class="line">sb16: enabled=0</span><br><span class="line">es1370: enabled=0</span><br><span class="line"></span><br><span class="line">usb_ehci: enabled=1</span><br><span class="line">usb_xhci: enabled=1</span><br><span class="line"></span><br><span class="line">magic_break: enabled=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug_symbols: file="kernel.sym"</span></span><br><span class="line">print_timestamps: enabled=0</span><br><span class="line">port_e9_hack: enabled=0</span><br><span class="line">fullscreen: enabled=0</span><br><span class="line"></span><br><span class="line">megs: 2048</span><br></pre></td></tr></table></figure><p>bochs的调试命令</p><table><thead><tr><th>命令</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>b address</td><td>在某物理地址上设置断点</td><td>b 0x7c00</td></tr><tr><td>c</td><td>继续执行，直到遇到断点</td><td>c</td></tr><tr><td>s</td><td>单步执行</td><td>s</td></tr><tr><td>info cpu</td><td>查看寄存器信息</td><td>info cpu</td></tr><tr><td>r</td><td>查看<strong>通用</strong>寄存器信息</td><td></td></tr><tr><td>sreg</td><td>查看<strong>段</strong>寄存器信息</td><td></td></tr><tr><td>creg</td><td>查看<strong>控制</strong>寄存器信息</td><td></td></tr><tr><td>xp /nuf addr</td><td>查看内存物理地址内容</td><td>xp /10bx 0x100000</td></tr><tr><td>x /nuf addr</td><td>查看线性地址内容</td><td>x /40wd 0x9000</td></tr><tr><td>u start end</td><td>反汇编一段内存</td><td>u 0x100000 0x100010</td></tr></tbody></table><h2 id="2-2-第一条指令"><a href="#2-2-第一条指令" class="headerlink" title="2.2 第一条指令"></a>2.2 第一条指令</h2><p>还是按照qemu的一套动作来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make  <span class="comment"># 编译</span></span><br><span class="line"><span class="built_in">cp</span> loader.bin kernel.bin  <span class="comment"># 没有kernel.bin，随便拷贝一个</span></span><br><span class="line">bximage  <span class="comment"># 创建floppy disk</span></span><br><span class="line"><span class="comment"># 将boot.bin写到floppy disk中</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br><span class="line"><span class="comment"># 将boot.img挂载到/media</span></span><br><span class="line">sudo mount boot.img /media/ -t vfat -o loop</span><br><span class="line">sudo <span class="built_in">cp</span> loader.bin /media/</span><br><span class="line">sudo <span class="built_in">cp</span> kernel.bin /media/</span><br><span class="line"><span class="built_in">sync</span>  <span class="comment"># 将loader.bin和kernel.bin写到floppy disk中</span></span><br><span class="line">sudo umount /media</span><br><span class="line"></span><br><span class="line">bochs  <span class="comment"># 启动bochs</span></span><br></pre></td></tr></table></figure><p>这个时候先不要急着执行c或s，想想第0天的内容，Intel卷3第9.1.1 Processor State After Reset，寄存器初始化的状态全在那张表了 Table 9-1. IA-32 and Intel 64 Processor States Following Power-up, Reset, or INIT</p><p>执行几条命令看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是bochs刚开始的时候，下一条指令是 jmpf 0xf000:e05b</span></span><br><span class="line"><span class="comment"># Next at t=0中t是执行的指令个数，也叫做内部时钟</span></span><br><span class="line"><span class="comment"># 0x0000fffffff0  物理地址</span></span><br><span class="line"><span class="comment"># f000:fff0 逻辑地址，好像算不出来上面的物理地址？</span></span><br><span class="line"><span class="comment"># jmpf 0xf000:e05b  汇编指令</span></span><br><span class="line"><span class="comment"># ea5be000f0  机器码</span></span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看控制寄存器 CR0=0x60000010 没毛病</span></span><br><span class="line">&lt;bochs:2&gt; creg</span><br><span class="line"><span class="comment"># 小写的表示标志位是0，大写的表示标志位是1</span></span><br><span class="line">CR0=0x60000010: pg CD NW ac wp ne ET ts em mp pe</span><br><span class="line">CR2=page fault laddr=0x0000000000000000</span><br><span class="line">CR3=0x000000000000</span><br><span class="line">    PCD=page-level cache <span class="built_in">disable</span>=0</span><br><span class="line">    PWT=page-level write-through=0</span><br><span class="line">CR4=0x00000000: pks cet pke smap smep keylock osxsave pcid fsgsbase smx vmx la57 umip osxmmexcpt osfxsr pce pge mce pae pse de tsd pvi vme</span><br><span class="line">CR8: 0x0</span><br><span class="line">EFER=0x00000000: ffxsr nxe lma lme sce</span><br><span class="line">XCR0=0x00000001: cet_s cet_u pkru hi_zmm zmm_hi256 opmask bndcfg bndregs ymm sse FPU</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看段寄存器 cs:0xf000，base=0xffff0000，limit=0x0000ffff和书上说的一样</span></span><br><span class="line">&lt;bochs:1&gt; sreg</span><br><span class="line">es:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">cs:0xf000, dh=0xff0093ff, dl=0x0000ffff, valid=7</span><br><span class="line">Data segment, base=0xffff0000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ds:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1</span><br><span class="line"><span class="built_in">tr</span>:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1</span><br><span class="line">gdtr:base=0x0000000000000000, <span class="built_in">limit</span>=0xffff</span><br><span class="line">idtr:base=0x0000000000000000, <span class="built_in">limit</span>=0xffff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看通用寄存器 rip: 00000000_0000fff0，eflags 0x00000002</span></span><br><span class="line">&lt;bochs:3&gt; r</span><br><span class="line">CPU0:</span><br><span class="line">rax: 00000000_00000000</span><br><span class="line">rbx: 00000000_00000000</span><br><span class="line">rcx: 00000000_00000000</span><br><span class="line">rdx: 00000000_00000000</span><br><span class="line">rsp: 00000000_00000000</span><br><span class="line">rbp: 00000000_00000000</span><br><span class="line">rsi: 00000000_00000000</span><br><span class="line">rdi: 00000000_00000000</span><br><span class="line">r8 : 00000000_00000000</span><br><span class="line">r9 : 00000000_00000000</span><br><span class="line">r10: 00000000_00000000</span><br><span class="line">r11: 00000000_00000000</span><br><span class="line">r12: 00000000_00000000</span><br><span class="line">r13: 00000000_00000000</span><br><span class="line">r14: 00000000_00000000</span><br><span class="line">r15: 00000000_00000000</span><br><span class="line">rip: 00000000_0000fff0</span><br><span class="line">eflags 0x00000002: <span class="built_in">id</span> vip vif ac vm rf nt IOPL=0 of <span class="built_in">df</span> <span class="keyword">if</span> tf sf zf af pf cf</span><br></pre></td></tr></table></figure><p>从这些寄存器的值来看，和Intel手册上的东西是一一对应了，那么问题来了</p><p><strong>1 为啥逻辑地址是<code>f000:fff0</code>，物理地址是<code>fffffff0</code>？</strong></p><p>实际上这个问题在第0天说过了，也就是Intel手册卷3第9.1.4 First Instruction Executed</p><p><img data-src="/assets/05_Make-MyOS-Find-kernel/202201182351351.png" alt="202201182351351"></p><p>大致意思就是上电后第一条指令，因为CS段寄存器基址是FFFF0000H，段选择子是F000H，在实模式下，一般来说基址是段选择子左移4位得来的，但这里显然不是，而是按照初始的基址。</p><p>硬件复位后第一次向CS寄存器加载新值时，处理器将遵循实地址模式下的正常地址转换规则(即[CS基地址=CS段选择器*16])，也就是到CS=0x7c00那个时候</p><p><strong>2 第一条指令到底是啥呢？为什么是<code>jmpf 0xf000:e05b</code>？</strong></p><p>回答这个问题之前，先看看实模式下1M内存的布局，截取自《操作系统真象还原》</p><p><img data-src="/./assets/05_Make-MyOS-Find-kernel/202201192313827.png"></p><p>第一条指令是<code>jmpf 0xf000:e05b</code>，在的地方刚好占了16B，也就是说第一条指令基本就是跳转，干不了别的事，跳转到哪？各家的BIOS程序开始，bochs是<code>0xf000:e05b</code>，别家的可不一样。至于BIOS做了什么，在第0天已经说过了，这里看个下面几条指令就过了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:1&gt; s</span><br><span class="line">Next at t=1</span><br><span class="line">(0) [0x0000000fe05b] f000:e05b (unk. ctxt): xor ax, ax                ; 31c0</span><br><span class="line">&lt;bochs:2&gt; s       </span><br><span class="line">Next at t=2</span><br><span class="line">(0) [0x0000000fe05d] f000:e05d (unk. ctxt): out 0x0d, al              ; e60d</span><br><span class="line">&lt;bochs:3&gt; s</span><br><span class="line">Next at t=3</span><br><span class="line">(0) [0x0000000fe05f] f000:e05f (unk. ctxt): out 0xda, al              ; e6da</span><br><span class="line">&lt;bochs:4&gt; s</span><br><span class="line">Next at t=4</span><br><span class="line">(0) [0x0000000fe061] f000:e061 (unk. ctxt): mov al, 0xc0              ; b0c0</span><br><span class="line">&lt;bochs:5&gt; s</span><br><span class="line">Next at t=5</span><br><span class="line">(0) [0x0000000fe063] f000:e063 (unk. ctxt): out 0xd6, al              ; e6d6</span><br></pre></td></tr></table></figure><p>S是单步调试，这里out命令实际上是给各个硬件端口设值，不关注</p><p>什么？你说BIOS程序是怎么加载到内存的？这个在第0天也提到过，硬件完成的，写在ROM中由硬件映射到低端1M内存中</p><p>然后BIOS会识别512B MBR(就是我们写的boot.asm)，并加载到7C00H~7DFF中，不再赘述</p><h2 id="2-3-执行MBR"><a href="#2-3-执行MBR" class="headerlink" title="2.3 执行MBR"></a>2.3 执行MBR</h2><p>跳过BIOS的操作，直接在0x7c00处打个断点，并单步调试看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:55&gt; b 0x7c00  <span class="comment"># 设断点</span></span><br><span class="line">&lt;bochs:56&gt; c         <span class="comment"># 执行到断点处</span></span><br><span class="line">(0) Breakpoint 1, 0x0000000000007c00 <span class="keyword">in</span> ?? ()</span><br><span class="line">Next at t=14034563</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): jmp .+60  (0x00007c3e)    ; eb3c</span><br><span class="line">&lt;bochs:57&gt; s</span><br><span class="line">Next at t=14034564</span><br><span class="line">(0) [0x000000007c3e] 0000:7c3e (unk. ctxt): mov ax, cs                ; 8cc8</span><br><span class="line">&lt;bochs:58&gt; s</span><br><span class="line">Next at t=14034565</span><br><span class="line">(0) [0x000000007c40] 0000:7c40 (unk. ctxt): mov ds, ax                ; 8ed8</span><br><span class="line">&lt;bochs:59&gt; s</span><br><span class="line">Next at t=14034566</span><br><span class="line">(0) [0x000000007c42] 0000:7c42 (unk. ctxt): mov es, ax                ; 8ec0</span><br><span class="line">&lt;bochs:60&gt; s</span><br><span class="line">Next at t=14034567</span><br><span class="line">(0) [0x000000007c44] 0000:7c44 (unk. ctxt): mov ss, ax                ; 8ed0</span><br><span class="line">&lt;bochs:61&gt; s</span><br><span class="line">Next at t=14034568</span><br><span class="line">(0) [0x000000007c46] 0000:7c46 (unk. ctxt): mov sp, 0x7c00            ; bc007c</span><br></pre></td></tr></table></figure><p>这里和boot.asm开头那段是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Label_Start:</span><br><span class="line">    mov ax, cs  ; 最开始cs是等于0的</span><br><span class="line">    mov ds, ax  ; ds es ss不能通过立即数赋值 需要ax中转</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, BaseOfStack  ; 栈指针设到0x7c00</span><br></pre></td></tr></table></figure><p>然后在boot.asm中是将loader.bin加载到0x10000地址处，从上面的表中可以看到从0x7E00到0x9FBFF都是保留区域，中间留的一些空后面用作临时转存kernel的东西了，当加载loader.bin之后，直接跳转过去<code>jmpBaseOfLoader:OffsetOfLoader</code>，所以下一个断点就是0x10000咯，和boot.asm是一样的东西，不看了</p><h2 id="2-4-loader-bin"><a href="#2-4-loader-bin" class="headerlink" title="2.4 loader.bin"></a>2.4 loader.bin</h2><p>书上loader.bin上的一些小测试，第一个在开启A20 pin之后，查看fs段的limit，需要在开启A20 pin那节sti命令后面加个<code>jmp $</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:2&gt; sreg</span><br><span class="line">es:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">Data segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">cs:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">Data segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ds:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">Data segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">fs:0x0010, dh=0x00cf9300, dl=0x0000ffff, valid=1</span><br><span class="line">Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed</span><br><span class="line">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1</span><br><span class="line">Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1</span><br><span class="line">tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1</span><br><span class="line">gdtr:base=0x0000000000010040, limit=0x17</span><br><span class="line">idtr:base=0x0000000000000000, limit=0x3ff</span><br></pre></td></tr></table></figure><p>可以看到开启A20 pin后，fs的limit变了，寻址能力变成4G了</p><p>打印SVGA相关信息，这个必须要在设置VGA模式(set the SVGA mode(VESA VBE))之前加个<code>jmp $</code>，因为设置完貌似就清屏了，啥信息也没有了，实际测试如下..</p><p><img data-src="/./assets/05_Make-MyOS-Find-kernel/202201231548556.png"></p><p>当按书上的源码执行完后，bochs的界面应当发生改变，并且bochs的log中有**CPU is in long mode (active)**以表示我们真的进入了64位模式</p><h1 id="3-阶段小结"><a href="#3-阶段小结" class="headerlink" title="3 阶段小结"></a>3 阶段小结</h1><p>一张图算是对前面几节的总结了，刚开机干的事还是比较简单的</p><p><img data-src="/./assets/05_Make-MyOS-Find-kernel/202201231746653.svg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《64位》比《32位》多了一步loader.bin似乎，《32位》的下一步直接就是导入C语言，开始搞系统了，《64位》还得再来个loader，接着干吧..这一节很重要，承上启下，甚至于内容也是&lt;/p&gt;
&lt;p&gt;这次把书上的源码上传的gitee了: &lt;a href=&quot;https://gitee.com/SidneyGod/make-os/tree/master/00_一个64位操作系统的设计与实现/一个64位操作系统的设计与实现-源代码/第二部分 初级篇/第3章/程序/程序3-4&quot;&gt;00_一个64位操作系统的设计与实现/一个64位操作系统的设计与实现-源代码/第二部分 初级篇/第3章/程序/程序3-4 · Sidney/MakeOS - 码云 - 开源中国 (gitee.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书上说，Loader的作用很大，大概包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检测硬件信息&lt;/p&gt;
&lt;p&gt;主要是通过BIOS中断服务程序来获取和检测硬件信息。BIOS上电自检的大部分信息只能在实模式下获取，内核运行在非实模式下，所以需要在进入内核前将信息检测出来，再作为参数提供给内核程序使用。比如获取ROM，RAM，设备寄存器和内存空洞等资源的物理地址范围交给内存管理单元模块维护；通过VBE功能检测出显示器支持的分辨率，显示模式，刷新率以及显存物理地址以配置合理的显示模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理器模式切换&lt;/p&gt;
&lt;p&gt;BIOS运行的实模式到32位操作系统用的保护模式，再到64位操作系统用的IA-32e模式(长模式)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;向内核传递数据&lt;/p&gt;
&lt;p&gt;向内核传递两种数据，控制信息：控制内核执行流程或限制内核某些功能；硬件数据信息：检测出来的硬件数据信息，保存在固定的内存地址中，并将数据其实内存地址和数据长度作为参数传递给内核。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Make OS" scheme="https://sidneyding.cn/categories/OS/Make-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>[Make MyOS] Basic execution env &amp; Interrupt</title>
    <link href="https://sidneyding.cn/posts/a4707db6/"/>
    <id>https://sidneyding.cn/posts/a4707db6/</id>
    <published>2021-12-21T15:31:33.000Z</published>
    <updated>2023-08-13T02:41:56.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-执行环境介绍"><a href="#1-执行环境介绍" class="headerlink" title="1 执行环境介绍"></a>1 执行环境介绍</h1><p>在find loader那一节之后，发现后面的代码真的看不懂了，直接抄也没有意义，于是补了一下相关的知识..希望能继续下去</p><h2 id="1-1-CPU工作模式"><a href="#1-1-CPU工作模式" class="headerlink" title="1.1 CPU工作模式"></a>1.1 CPU工作模式</h2><p>参考Intel手册卷3第2.2 MODES OF OPERATION</p><p>32位的支持三种工作模式和一种准工作模式</p><ul><li><p>实地址模式(Real-address mode)，处理器上电(power-up)或复位(reset)后处于该模式。这个模式实际上是为了兼容8086，因为地址线只有20根，限制了寻址只能是1M大小，也就是通过<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="26.774ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 11834 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">段</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">寄</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">存</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">器</text></g><g data-mml-node="mo" transform="translate(4277.8,0)"><g data-mml-node="text"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g></g><g data-mml-node="mn" transform="translate(6111.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(6833.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(7834,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">偏</text></g><g data-mml-node="mi" transform="translate(8834,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">移</text></g><g data-mml-node="mi" transform="translate(9834,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">地</text></g><g data-mml-node="mi" transform="translate(10834,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">址</text></g></g></g></svg></mjx-container>方式寻址。进入这个模式，也就只使用20根地址线，主要是因为A20M#引脚被屏蔽了</p></li><li><p>保护模式(Protected mode)，这个是80386时期引入的，也就是32位处理器原本的工作模式。在这个模式下不再使用<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="26.774ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 11834 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">段</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">寄</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">存</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">器</text></g><g data-mml-node="mo" transform="translate(4277.8,0)"><g data-mml-node="text"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g></g><g data-mml-node="mn" transform="translate(6111.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(6833.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(7834,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">偏</text></g><g data-mml-node="mi" transform="translate(8834,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">移</text></g><g data-mml-node="mi" transform="translate(9834,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">地</text></g><g data-mml-node="mi" transform="translate(10834,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">址</text></g></g></g></svg></mjx-container>的方式寻址，而是通过段描述符的方式描述基址和限长，并通过描述符中的属性设置实现对内存段的访问限制和数据保护。</p></li><li><p>虚拟8086模式(Virtual-8086 mode)，是一种准工作模式，目的是为了在保护模式下能够执行8086程序<span id="more"></span></p></li><li><p>系统管理模式(System management mode)，80386时期引入，提供了一种对操作系统或执行程序透明的机制实现平台特定功能，如电源管理或系统安全或oem差异化的feature。对操作系统透明(这个透明的意思在计算机组成原理里就可以理解为不知道为什么，它就..)，换句话说，就是操作系统不知道何时进入SMM的，也不知道SMM曾经执行过。进入SMM是通过给CPU引脚SMI#上电，或者可编程中断控制器(APIC)接收到SMI，进入SMM后，一切被都屏蔽，包括所有的中断，处理器切换到单独的地址空间(System Management RAM)，同时保存当前运行的程序或任务的上下文。然后可以透明地执行SMM特定的代码。可以通过设置SMBASE的寄存器来设置SMRAM的空间。SMM处理程序只能由系统固件实现。只能通过执行RSM指令退出，退出后，处理器将被置于SMI之前的状态。</p></li></ul><p>64位除了支持32位的几个模式，还支持IA-32e modes</p><ul><li>IA-32e模式(IA-32e mode)，在IA-32e模式下，处理器支持两种子模式：兼容模式和64位模式。64位模式提供64位线性寻址并支持大于64GBytes的物理地址空间。兼容模式允许大多数传统的保护模式应用程序不变地运行。AMD称之为长模式，参考AMD手册卷1第1.2节</li></ul><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112040019448.png" alt="202112040019448"></p><h2 id="1-2-基础执行环境"><a href="#1-2-基础执行环境" class="headerlink" title="1.2 基础执行环境"></a>1.2 基础执行环境</h2><p>处理器上运行的任何程序或资源都会被赋予一组资源，用于执行指令，存储代码、数据和状态信息。就是一些寄存器和内存的使用</p><ul><li>地址空间(Address space)，32位CPU，理论上单进程可以寻址<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>bytes，也就是4GB线性地址(虚拟地址)空间，而可用的地址线有36根(Intel)，所以支持最大物理内存是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>bytes，也就是64GB；64位CPU，理论上单进程可以寻址<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.904ex" role="img" focusable="false" viewBox="0 -841.7 1290.1 841.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>bytes线性地址，也就是???TB，只是实际上只有46根地址线(听说已经来到了48根)，所以支持最大物理地址是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.904ex" role="img" focusable="false" viewBox="0 -841.7 1290.1 841.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>byte，也就是???TB</li><li>基本程序执行寄存器(Basic program execution registers)，32位CPU，有8个通用寄存器(GPR)，6个段寄存器(SR)，1个EFLAGS寄存器，1个EIP(指令)寄存器；64位CPU有16个GPR，6个SR，1个EFLAGS(其中高32位保留，不使用)，一个RIP</li><li>x87 FPU寄存器，32位和64位都是8个，主要用于浮点计算的</li><li>MMX寄存器，32位和64位都是8个，主要用于矩阵运算？用于支持64bit的SIMD(single-instruction，multiple-data)单指令多数据</li><li>XMM寄存器，32位和64位都是8个，对MMX的扩展，用于支持128位的SIMD</li><li>YMM寄存器，32位和64位都是8个，对MMX的扩展，用于支持256位的SIMD，<a href="https://www.cnblogs.com/TaigaCon/p/7835340.html">PC平台主要SIMD扩展发展简史</a></li><li>边界寄存器(Bounds)，BND0-BND3寄存器存放的是内存缓冲区的上限指针，这些寄存器用于支持MPX指令。</li><li>BNDCFGU和BNDSTATUS寄存器，可以看出一个是配置寄存器，一个是状态寄存器，用于支持MPX指令。</li><li>堆栈(Stack)，为了支持过程或子例程调用以及过程或子例程之间的参数传递，在执行环境中包括堆栈和堆栈管理资源。它通过段寄存器SS指定位置，而实际指向的是一段内存或者Cache</li></ul><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112042113976.png" alt="202112042113976" style="zoom:70%;"><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112042114804.png" alt="202112042114804" style="zoom:70%;"></p><p>以上的运行环境是在CPU core级别的环境，另外处理器还提供了下列系统级别的运行环境，在多核处理器的环境中，处理器内部的多个CPU core共享这些运行环境。这个系统级别的运行环境主要包括：</p><ul><li>I/O端口，IA-32架构提供了64KB的地址空间，这些地址空间是被系统中的所有CPU core共用的。参考Intel手册卷1第18.3 I/O ADDRESS SPACE</li><li>控制寄存器，包括5个控制寄存器CR0-CR4，这些控制寄存器控制着当前的运行模式，并且是否使能处理器的某些功能，64位多一个CR8(task priority register，TPR)</li><li>内存管理寄存器(又被称为DTR，描述表寄存器)，包括GDTR(global descriptor table register)、IDTR(interrupt descriptor table register)、TR(task register)和LDTR(local descriptor table register)，这些寄存器用来指明在保护模式下，内存中数据结构的位置。</li><li>Debug寄存器，有8个寄存器，监视处理器调试操作</li><li>内存类型范围寄存器(MTRR)，用于指明系统内存的类型和区间</li><li>MSR(Machine specific registers)，主要用于控制处理器的配置并且汇报处理器的状态</li><li>Machine check registers，主要用于硬件错误的检测，它其实也是属于MSR寄存器</li><li>Performance monitoring counters，主要用于监测处理器的性能</li></ul><p>你说这环境像不像”线程”的概念？</p><h3 id="1-2-1-通用寄存器"><a href="#1-2-1-通用寄存器" class="headerlink" title="1.2.1 通用寄存器"></a>1.2.1 通用寄存器</h3><p>32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。</p><p>寄存器AX称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、除、输入/输出等操作，它们的使用频率很高；</p><p>寄存器BX称为基地址寄存器(BaseRegister)。它可作为存储器指针来使用；</p><p>寄存器CX称为计数寄存器(CountRegister)。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；</p><p>寄存器DX称为数据寄存器(DataRegister)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。</p><p>32位CPU有2个32位通用寄存器EBP和ESP。其低16位对应先前CPU中的BP和SP，对低16位数据的存取，不影响高16位的数据。BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。</p><p>32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI(源变址寄存器，suorce index)和DI(目的变址寄存器，destination index)，对低16位数据的存取，不影响高16位的数据。它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。</p><blockquote><ul><li><strong>EAX</strong> — Accumulator for operands and results data</li><li><strong>EBX</strong> — Pointer to data in the DS segment</li><li><strong>ECX</strong> — Counter for string and loop operations</li><li><strong>EDX</strong> — I/O pointer</li><li><strong>ESI</strong> — Pointer to data in the segment pointed to by the DS register; source pointer for string operations</li><li><strong>EDI</strong> — Pointer to data (or destination) in the segment pointed to by the ES register; destination pointer for<br>string operations</li><li><strong>ESP</strong> — Stack pointer (in the SS segment)</li><li><strong>EBP</strong> — Pointer to data on the stack (in the SS segment)</li></ul></blockquote><p>64位除此之外还有R8D-R15D/R8-R15 represent eight new general-purpose registers.</p><h3 id="1-2-2-指令指针寄存器"><a href="#1-2-2-指令指针寄存器" class="headerlink" title="1.2.2 指令指针寄存器"></a>1.2.2 指令指针寄存器</h3><p>32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。指令指针EIP、IP(InstructionPointer)是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。</p><p>EIP寄存器不能通过软件直接访问；它由控制传输指令（例如 JMP、Jcc、CALL 和 RET）、中断和异常隐式控制。读取 EIP 寄存器的唯一方法是执行 CALL 指令，然后从过程堆栈中读取返回指令指针的值。</p><h3 id="1-2-3-段寄存器"><a href="#1-2-3-段寄存器" class="headerlink" title="1.2.3 段寄存器"></a>1.2.3 段寄存器</h3><p><strong>段寄存器</strong>是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p><p>CS - 代码段寄存器(CodeSegmentRegister)，其值为代码段的段值，保存正在执行的指令，处理器使用CS:IP组合的逻辑地址从代码段中获取指令；</p><p>DS - 数据段寄存器(DataSegmentRegister)，其值为数据段的段值；</p><p>ES - 附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值；</p><p>FS - 附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值；</p><p>GS - 附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值。DS、ES、FS和GS寄存器指向四个数据段。四个数据段的可用性允许对不同类型的数据结构进行高效和安全的访问。例如，可能会创建四个单独的数据段：一个用于当前模块的数据结构，另一个用于从更高级别模块导出的数据，第三个用于动态创建的数据结构，第四个用于与另一个共享的数据程序。要访问附加数据段，应用程序必须根据需要将这些段的段选择器加载到DS、ES、FS和GS寄存器中。</p><p>SS - 堆栈段寄存器(StackSegmentRegister)，其值为堆栈段的段值；存储当前正在执行的程序、任务或处理程序的过程堆栈。所有堆栈操作都使用SS寄存器来查找堆栈段。与CS寄存器不同，SS寄存器可以显式加载，这允许应用程序建立多个堆栈并在它们之间切换</p><p>在16位CPU系统中，它只有4个段寄存器(CS, DS, SS, and ES)，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。</p><p><strong>每个段寄存器都分为两个部分，一个是可见部分(visible)，仅包括16bit的段选择子；一个是隐藏部分(hidden)，包括32bit的基址(base address)表示段从哪里开始，32bit的段长(limit)表示基址的长度，16bit的访问控制信息(attributes)表示当前段寄存器是可读可写可执行。所以段寄存器是96位的</strong></p><h3 id="1-2-4-EFLAGS寄存器"><a href="#1-2-4-EFLAGS寄存器" class="headerlink" title="1.2.4 EFLAGS寄存器"></a>1.2.4 EFLAGS寄存器</h3><p>64位称作RFLAGS寄存器，RFLAGS寄存器的高32位保留，RFLAGS的低32位与EFLAGS相同。EFLAGS包含一组状态标志、一个控制标志和一组系统标志。在处理器初始化之后（通过置位RESET引脚或INIT引脚），EFLAGS寄存器的状态为00000002H。该寄存器的位 1、3、5、15 和 22 至 31 被保留。软件不应使用或依赖任何这些位的状态。</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112051613300.png" alt="202112051613300"></p><p>EFLAGS寄存器中的某些标志可以使用专用指令直接修改，没有允许直接检查或修改整个寄存器的指令。以下指令可用于将标志组移入和移出过程堆栈或EAX寄存器：LAHF、SAHF、PUSHF、PUSHFD、POPF 和 POPFD。在EFLAGS寄存器的内容传输到过程堆栈或EAX寄存器后，可以使用处理器的位操作指令（BT、BTS、BTR 和 BTC）检查和修改标志。</p><p>当调用中断或异常处理程序时，处理器会自动将EFLAGS寄存器的状态保存在过程堆栈中。当使用任务切换处理中断或异常时，EFLAGS寄存器的状态将保存在TSS中以用于挂起的任务。</p><h4 id="Status-flags"><a href="#Status-flags" class="headerlink" title="Status flags"></a>Status flags</h4><p>EFLAGS寄存器的状态标志（bit 0、2、4、6、7和11）指示算术指令的结果，例如 ADD、SUB、MUL和DIV指令。参考AMD手册卷1第3.1.4节Flags Register</p><ul><li>CF(bit 0)，进位标志(Carry flag)，主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。</li><li>PF(bit 2)，奇偶标志(Parity flag)，用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。</li><li>AF(bit 4)，辅助进位标志(Auxiliary Carry flag)，如果算术运算或二进制编码的十进制 (BCD) 运算从结果的第3位生成进位（在加法的情况下）或借位（在减法的情况下），则硬件设置辅助进位标志。否则，AF清零。 </li><li>ZF(bit 6)，零标志(Zero flag)，如果最后一次算术运算的结果为零，则硬件将零标志设置为1。否则（对于非零结果），硬件将该标志清零。比较和测试指令也会影响零标志。零标志通常用于测试算术或逻辑运算的结果是否为零，或测试两个操作数是否相等。</li><li>SF(bit 7)，符号标志(Sign flag)，设置为等于最后一次运算结果的最高有效位，即有符号整数的符号位。（0表示正值，1表示负值。）</li><li>OF(bit 11)，溢出标志(Overflow flag)，硬件将溢出标志设置为1，以指示最后一个有符号整数运算结果的最高有效（符号）位与两个源操作数的符号不同。否则，硬件将该标志清除为0。设置溢出标志意味着正或负结果的幅度太大（溢出）或太小（下溢）以适合其定义的数据类型。在DIV指令之后和移位多于一位之后，OF标志是未定义的。逻辑指令清除溢出标志。</li></ul><h4 id="DF-Flag"><a href="#DF-Flag" class="headerlink" title="DF Flag"></a>DF Flag</h4><p>DF(bit 10)，方向标志(Direction flag)确定处理字符串的顺序。软件可以将方向标志<strong>设置为1</strong>，以指定<strong>递减下一条字符串指令</strong>（LODSx、STOSx、MOVSx、SCASx、CMPSx、OUTSx 或 INSx）的数据指针。 将方向标志<strong>清除为0指定递增</strong>数据指针。 指针存储在rSI或rDI寄存器中。软件可以分别<strong>使用STD和CLD指令设置或清除</strong>标志。</p><h4 id="System-Flags-and-IOPL-Field"><a href="#System-Flags-and-IOPL-Field" class="headerlink" title="System Flags and IOPL Field"></a>System Flags and IOPL Field</h4><p>EFLAGS寄存器中的系统标志和IOPL字段控制操作系统或执行操作，它们不应被应用程序修改。参考AMD手册卷2第3.1.6节RFLAGS Register</p><ul><li>TF(bit 8)，追踪标志(Trap)，置1为启用单步调试模式；清零以禁用单步模式。在单步调试模式下，处理器在每条指令后生成一个调试异常。这允许在每条指令之后检查程序的执行状态。如果应用程序使用POPF、POPFD或IRET指令设置TF标志，则在POPF、POPFD或IRET之后的指令后会产生调试异常。</li><li>IF(bit 9)，中断使能标志(Interrupt enable)，置为1以启用可屏蔽中断(INTR中断)，清零会导致处理器忽略可屏蔽中断。IF标志不影响异常或不可屏蔽中断（NMI中断）。CPL(当前特权级别)、IOPL(IO权限级别)和控制寄存器CR4中VME(虚拟8086模式扩展)及PVI(保护模式虚拟中断)标志的状态决定了IF标志是否可以被CLI、STI、POPF、POPFD和IRET修改。</li><li>IOPL(bit 13:12)，IO特权等级字段(I/O privilege level field)，IOPL字段指定执行I/O地址空间指令所需的权限级别（寻址I/O空间而不是内存映射I/O的指令，例如 IN、OUT、INS、OUTS等）。当前权限级别(CPL)必须等于或高于（低于数值）IOPL(CPL &lt;= IOPL)指定的权限。如果CPL低于（高于）IOPL指定的值（CPL &gt; IOPL），则当软件尝试执行 I/O 指令时，处理器会导致一般保护异常 (#GP)。当启用虚拟 8086 模式扩展 (CR4.VME=1) 时，虚拟 8086 模式使用 IOPL 来控制虚拟中断和 IF 位。保护模式虚拟中断机制 (PVI) 还使用 IOPL 来控制虚拟中断和启用 PVI 时的 IF 位（CR4.PVI=1）</li><li>NT(bit 14)，嵌套任务标志(Nested task)，IRET 读取 NT 位以确定当前任务是否嵌套在另一个任务中。当 NT 设置为 1 时，当前任务嵌套在另一个任务中。当 NT 清除为 0 时，当前任务处于顶层（非嵌套）。处理器在调用以 CALL 指令、中断或异常启动的任务时设置此标志。它在从使用 IRET 指令启动的任务返回时检查并修改此标志。可以使用 POPF/POPFD 指令显式设置或清除该标志；但是，更改此标志的状态可能会在应用程序中产生意外异常。</li><li>RF(bit 16)，恢复标志(Resume)，主要功能是允许在由指令断点条件引起的调试异常之后重新启动指令。置为 1 时，会暂时禁用指令断点报告，以防止发生重复的调试异常 (#DB)。处理器在每条指令成功执行后清除 RF 位，除非指令是：设置RF位的IRET；通过任务门执行的JMP、CALL或INTn。</li><li>VM(bit 17)，虚拟8086模式(Virtual-8086 mode)，软件将VM置为1以启用虚拟8086模式，清零以禁用虚拟8086模式(返回保护模式)。系统软件只能使用任务开关或IRET更改此位。它不能使用POPFD指令修改位。</li><li>AC(bit 18)，对齐检查或访问控制(Alignment check or access control)，当CR0.AM=1时，软件通过将 AC 位设置为 1 来启用自动对齐检查。可以通过将 AC 或 CR0.AM 清除为 0 来禁用对齐检查。当启用自动对齐检查并且当前特权级别(CPL)为3（最低特权）时，对未对齐操作数的内存引用会导致对齐检查异常 (#AC)。当启用超级用户模式访问阻止功能 (CR4.SMAP=1) 时，只有当 RFLAGS.AC=1 时，才允许某些超级用户模式数据访问用户模式可访问的页面。</li><li>VIF(bit 19)，虚拟中断(Virtual Interrupt)，</li><li>VIP(bit 20)，虚拟中断挂起(Virtual interrupt pending)，由软件置位以指示中断正在挂起；清零表示没有待处理的中断。此标志与 VIF 标志结合使用。这个标志是只读的。处理器仅在控制寄存器 CR4 中的 VME 标志或 PVI 标志置位且 IOPL 小于 3 时才识别 VIP 标志。VME 标志启用虚拟 8086 模式扩展；PVI 标志启用保护模式虚拟中断。</li><li>ID(bit 21)，身份标志(Identification)，软件修改该位的能力表明处理器实现支持 CPUID 指令。</li></ul><h3 id="1-2-5-内存管理寄存器"><a href="#1-2-5-内存管理寄存器" class="headerlink" title="1.2.5 内存管理寄存器"></a>1.2.5 内存管理寄存器</h3><p>当启用保护模式(CR0.PE=1)时，分段机制使用描述符表。这些表包含描述段的位置、大小和特权属性的描述符条目。保护模式下的所有内存引用访问一个描述符表条目。<br>x86分段机制支持三种类型的描述符表：全局描述符表(GDT)，本地描述符表(LDT)，中断描述符表(IDT)。软件通过初始化其对应的<strong>描述符表寄存器</strong>来建立描述符表在内存中的位置。</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112052009598.png" alt="202112052009598"></p><p>先把这些表当成一个数组，这些寄存器的作用就是存储这些数组..细节到内存管理再详细看。</p><h4 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h4><p>GDTR寄存器保存基地址(Base address)（在保护模式下为32位；在IA-32e模式下为64位）和GDT的16位表限(table limit)。基地址指定GDT第0字节的线性地址；表限指定表中的字节数。<br>LGDT和SGDT指令分别加载和存储GDTR寄存器。在处理器上电或复位时，基地址设置为默认值0，限制设置为0FFFFH。作为保护模式操作的处理器初始化过程的一部分，必须将新基址加载到GDTR中。</p><h4 id="LDTR"><a href="#LDTR" class="headerlink" title="LDTR"></a>LDTR</h4><p>LDTR寄存器保存LDT的16位段选择器、基地址（在保护模式下为32位；在IA-32e模式下为64位）、段限(Segment limit)和描述符属性。基地址指定LDT段第0字节的线性地址； 段限指定段中的字节数。</p><p>LLDT和SLDT指令分别加载和存储LDTR寄存器的段选择器部分。包含LDT的段必须在GDT中具有段描述符。当LLDT指令在LDTR中加载段选择器时：LDTR描述符中的基地址、段限和描述符属性会自动加载到LDTR中。</p><h4 id="IDTR"><a href="#IDTR" class="headerlink" title="IDTR"></a>IDTR</h4><p>IDTR寄存器保存基地址（在保护模式下为32位；在IA-32e模式下为64位）和IDT的16位表限(table limit)。基地址指定IDT第0字节的线性地址；表限指定表中的字节数。</p><p>LIDT和SIDT指令分别加载和存储IDTR寄存器。在处理器上电或复位时，基地址设置为默认值0，限制设置为0FFFFH。然后，作为处理器初始化过程的一部分，可以更改寄存器中的基址和限制。</p><h4 id="TR"><a href="#TR" class="headerlink" title="TR"></a>TR</h4><p>TR寄存器保存当前任务的TSS(task-state segment)的16位段选择器、基地址（在保护模式下为32位；在IA-32e模式下为64位）、段限制和描述符属性。选择器引用GDT中的TSS描述符。基地址指定TSS第0字节的线性地址；段限制指定TSS中的字节数。<br>LTR和STR指令分别加载和存储任务寄存器的段选择器部分。当LTR指令在任务寄存器中加载段选择器时，来自TSS描述符的基地址、限制和描述符属性会自动加载到任务寄存器中。在处理器上电或复位时，基地址设置为默认值0，限制设置为0FFFFH。<br>当任务切换发生时，任务寄存器会自动加载新任务的TSS段选择器和描述符。在将新的TSS信息写入寄存器之前，不会自动保存任务寄存器的内容。</p><h3 id="1-2-6-控制寄存器"><a href="#1-2-6-控制寄存器" class="headerlink" title="1.2.6 控制寄存器"></a>1.2.6 控制寄存器</h3><p>决定了处理器的工作模式和当前执行任务的特性，在64位模式下，控制寄存器扩展到64位。参考AMD手册卷2第3.1节System-Control Registers</p><ul><li><p>CR0 — 包含控制处理器的操作模式和状态的系统控制标志以及处理器特性的控制标志。</p></li><li><p>CR2 — 该寄存器由页面转换机制使用。 当页面错误异常发生时，它由处理器加载页面错误虚拟地址。</p></li><li><p>CR3 — 该寄存器也被页面转换机制使用。 它包含最高级别页转换表的基地址，还包含指定表的缓存控制。</p></li><li><p>CR4 — 该寄存器包含对各种操作模式功能的附加控制。</p></li><li><p>CR8 — 该寄存器仅在64位模式下可用，可以使用REX前缀在64位模式下访问。CR8 用于区分外部中断的优先级，称为任务优先级寄存器 (TPR)。</p></li></ul><p>Control registers CR1, CR5–CR7, and CR9–CR15 are reserved.</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112051942246.png" alt="202112051942246"></p><p>参考Intel手册卷2第2.5节CONTROL REGISTERS</p><p><strong>CR0.PG</strong> Paging (bit 31 of CR0) — Enables paging when set; disables paging when clear. When paging is disabled, all linear addresses are treated as physical addresses. The PG flag has no effect if the PE flag (bit 0 of register CR0) is not also set; setting the PG flag when the PE flag is clear causes a general-protection exception (#GP).</p><p><strong>CR0.PE</strong> Protection Enable (bit 0 of CR0) — Enables protected mode when set; enables real-address mode when clear. This flag does not enable paging directly. It only enables segment-level protection. To enable paging, both the PE and PG flags must be set.</p><p><strong>CR3.PCD</strong> Page-level Cache Disable (bit 4 of CR3) — 置1时，禁止某个页写入缓存，直接写内存。比如，做页表用的页，已经存储在<code>TLB</code>中了，可能不需要再缓存了。This bit is not used if paging is disabled, with PAE paging, or with 4-level paging or 5-level paging if CR4.PCIDE=1.</p><p><strong>CR3.PWT</strong> Page-level Write-Through (bit 3 of CR3) — 置1时，写Cache的时候也要将数据写入内存中。This bit is not used if paging is disabled, with PAE paging, or with 4-level paging or 5-level paging if CR4.PCIDE=1.</p><p><strong>CR4.PSE</strong> Page Size Extensions (bit 4 of CR4) — Enables 4-MByte pages with 32-bit paging when set; restricts 32-bit paging to pages of 4 KBytes when clear.</p><p><strong>CR4.PAE</strong> Physical Address Extension (bit 5 of CR4) — When set, enables paging to produce physical addresses with more than 32 bits. When clear, restricts physical addresses to 32 bits. PAE must be set before entering IA-32e mode.</p><p><strong>CR4.PGE</strong> Page Global Enable (bit 7 of CR4) — Enables the global page feature when set; disables the global page feature when clear. The global page feature allows frequently used or shared pages to be marked as global to all users (done with the global flag, bit 8, in a page-directory-pointer-table entry, a page-directory entry, or a page-table entry). Global pages are not flushed from the translation-lookaside buffer (TLB) on a task switch or a write to register CR3. When enabling the global page feature, paging must be enabled (by setting the PG flag in control register CR0) before the PGE flag is set. Reversing this sequence may affect program correctness, and processor performance will be impacted.</p><p><strong>CR4.UMIP</strong> User-Mode Instruction Prevention (bit 11 of CR4) — When set, the following instructions cannot be executed if CPL &gt; 0: SGDT, SIDT, SLDT, SMSW, and STR. An attempt at such execution causes a generalprotection exception (#GP).</p><p><strong>CR4.LA57</strong> 57-bit linear addresses (bit 12 of CR4) — When set in IA-32e mode, the processor uses 5-level paging to translate 57-bit linear addresses. When clear in IA-32e mode, the processor uses 4-level paging to translate 48-bit linear addresses. This bit cannot be modified in IA-32e mode.</p><p><strong>CR4.PCIDE</strong> PCID-Enable Bit (bit 17 of CR4) — Enables process-context identifiers (PCIDs) when set. Applies only in IA-32e mode (if IA32_EFER.LMA = 1).</p><p><strong>CR4.PKE</strong> Enable protection keys for user-mode pages (bit 22 of CR4) — 4-level paging and 5-level paging associate each user-mode linear address with a protection key. When set, this flag indicates (via CPUID.(EAX=07H,ECX=0H):ECX.OSPKE [bit 4]) that the operating system supports use of the PKRU register to specify, for each protection key, whether user-mode linear addresses with that protection key<br>can be read or written. This bit also enables access to the PKRU register using the RDPKRU and WRPKRU instructions.</p><p><strong>CR4.PKS</strong> Enable protection keys for supervisor-mode pages (bit 24 of CR4) — 4-level paging and 5-level paging associate each supervisor-mode linear address with a protection key. When set, this flag allows use of the IA32_PKRS MSR to specify, for each protection key, whether supervisor-mode linear addresses with that protection key can be read or written.</p><p><strong>CR8.TPL</strong> Task Priority Level (bit 3:0 of CR8) — This sets the threshold value corresponding to the highestpriority interrupt to be blocked. A value of 0 means all interrupts are enabled. This field is available in 64-bit mode. A value of 15 means all interrupts will be disabled.</p><h2 id="1-3-内存管理"><a href="#1-3-内存管理" class="headerlink" title="1.3 内存管理"></a>1.3 内存管理</h2><p>很久以前，计算机只能运行单个进程，所以直接用物理内存地址就ok了，大家的程序都从0开始没有问题；后来计算机可以同时运行多个程序了，大家的程序还是都从0开始，这时候不就相互影响了吗，这时候就有了<strong>分段机制</strong>，隔离单个代码、数据和堆栈模块的机制，以便多个程序（或任务）可以在同一处理器上运行而不会相互干扰；再后来发现这种分段机制对内存的使用不够精细，因为段是一块一块的，后来就有了<strong>分页机制</strong>，按需分页虚拟内存系统的机制，其中程序执行环境的部分根据需要映射到物理内存中。</p><p>IA-32架构的内存管理工具分为两部分：分段和分页，如下图，其中分段是必须的，分页是可选的。如果不使用分页，则将处理器的线性地址空间直接映射到处理器的物理地址空间。</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112050056150.png" alt="202112050056150"></p><h3 id="1-3-1-内存模型"><a href="#1-3-1-内存模型" class="headerlink" title="1.3.1 内存模型"></a>1.3.1 内存模型</h3><p>程序不直接寻址物理内存，需要通过下面三种内存模型之一来访问</p><ul><li>平面内存模型(Flat memory model)，又称之为线性内存模型，最好理解的一种，内存对于一个程序来说就是一个单一的，连续的地址空间。代码，数据，堆栈都包含在这个空间当中。线性地址空间中任何字节的地址都被称之为<strong>线性地址</strong>。The linear address space contains all the segments and system tables defined for a system.</li><li>分段内存模型(Segmented memory model)，内存在程序中表现为一组称为段(常说的代码段，数据段，堆栈段)的独立地址空间。为寻址段中的一个字节，程序需要发出一个<strong>逻辑地址</strong>(通常又称作远指针)，<strong>由一个段选择器和一个偏移地址构成</strong>，表示查找某个段的某个字节。在IA-32处理器上运行的程序最多可以寻址16383(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.816ex" height="2.09ex" role="img" focusable="false" viewBox="0 -841.7 3012.6 923.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>)个不同大小和类型的段，每个段可以大到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>byte。在内部，为系统定义的所有段都映射到处理器的线性地址空间。为了访问内存位置，处理器因此将每个逻辑地址转换为线性地址。这种转换对应用程序是透明的。使用分段内存的主要原因是为了增加程序和系统的可靠性。例如，将程序的堆栈放在单独的段中可以防止堆栈分别增长到代码或数据空间并覆盖指令或数据。</li><li>实地址模式内存模型(Real-address mode memory model)，8086的内存模型，是用分段特性实现的。段是64KB(数据总线只有16根，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>)固定大小，但是地址线有20根，所以最大线性地址空间是1MB(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>)。16位的段寄存器必然访问不到1M的空间，所以也是采用“段基址+段内偏移地址”访问的</li></ul><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112042302777.png" alt="202112042302777"></p><p>这里有线性地址，逻辑地址了，还缺一个<strong>物理地址</strong>，就是挂载CPU地址总线上的内存空间划分的地址呗，就和8086的1M是一个道理，这个前面也提到了32位一般36根，64位是46根，但是想要使用扩展的地址线，需要将CR4.PAE置1或者CR4.PSE置1。</p><p><strong>逻辑地址翻译成线性地址</strong>，处理器需要：</p><p>1 使用段选择子(segment selector)中的偏移量(offset)在GDT或LDT中定位段的段描述符(segment descriptor)并将其读入处理器（仅当新的段选择器加载到段寄存器中时才需要此步骤）</p><p>2 查看段描述符以检查段的访问权限和范围，以确保该段可访问且偏移量在该段的限制内。</p><p>3 将段描述符中的段基地址与偏移量相加，形成一个线性地址。</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112052253460.png" alt="202112052253460"></p><p>如果不使用分页，则处理器将线性地址直接映射到物理地址（即线性地址在处理器的地址总线上输出）。如果线性地址空间被分页，则使用第二级地址转换将线性地址转换为物理地址。</p><p>再说这个段选择子，A segment selector is a 16-bit identifier for a segment. 它不直接指向段，而是指向定义段的段描述符。由Index，Table Indicator，Requested Privilege Level三项组成</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112052305623.png" alt="202112052305623"></p><p>**Index(bit 15~3)**，选择GDT或LDT中的8192(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>)个描述符之一(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="21.08ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 9317.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(345,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(945,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(1465,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(1931,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(2725.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(3725.4,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mo" transform="translate(4447.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5447.9,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mi" transform="translate(6275.9,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(6979.9,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mi" transform="translate(7424.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(7853.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(8382.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(8851.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g></g></g></svg></mjx-container>)。处理器将索引值乘以8（段描述符中的字节数）并将其结果加上GDT或LDT的基地址（分别来自GDTR或LDTR寄存器）</p><p>**TI(bit 2)**，指定使用哪个描述表，0是GDT，1是LDT</p><p>**RPL(bit 1~0)**，指定选择子的权限级别。特权级别的范围可以从0到3，其中0是最高特权级别。</p><p>处理器不使用GDT的第一个条目。指向GDT的该条目的段选择子（即索引为0且TI标志设置为0的段选择子）用作“空段选择子”。当段寄存器（除了CS或SS寄存器）加载有空选择子时，处理器不会产生异常。但是，当使用包含空选择子的段寄存器访问内存时，它确实会产生异常。<strong>空选择子可用于初始化未使用的段寄存器</strong>。**使用空段选择子加载CS或SS寄存器会导致生成一般保护异常(#GP)**。段选择子作为指针变量的一部分对应用程序可见，但选择子的值通常由链接编辑器或链接加载器而不是应用程序分配或修改。</p><h3 id="1-3-2-段描述符"><a href="#1-3-2-段描述符" class="headerlink" title="1.3.2 段描述符"></a>1.3.2 段描述符</h3><p>这段直接看Intel手册卷3第3.4.5 Segment Descriptors就好了..</p><p>为什么只能同时使用6个寄存器？</p><blockquote><p>For a program to access a segment, the segment selector for the segment must have been loaded in one of the segment registers. So, although a system can define thousands of segments, only 6 can be available for immediate use. Other segments can be made available by loading their segment selectors into these registers during program execution.</p></blockquote><p>段描述符，当然就是描述段的了。当段选择子被加载到段寄存器的可见部分时，处理器还会从段选择子指向的段描述符中加载段寄存器的隐藏部分：基地址、段限和访问控制信息。两类指令可以加载段选择子</p><ol><li>Direct load instructions such as the MOV, POP, LDS, LES, LSS, LGS, and LFS instructions. These instructions explicitly reference the segment registers.</li><li>Implied load instructions such as the far pointer versions of the CALL, JMP, and RET instructions, the SYSENTER and SYSEXIT instructions, and the IRET, INT n, INTO, INT3, and INT1 instructions. These instructions change the contents of the CS register (and sometimes other segment registers) as an incidental part of their operation.</li></ol><p>The MOV instruction can also be used to store the visible part of a segment register in a general-purpose register.</p><p>接下来才是主题，段选择子且当成一个数组的index，那么段描述符就是这个数组中的一项了。具体的定义是：<strong>A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a segment, as well as access control and status information</strong>.段描述符通常由编译器、链接器、加载器或操作系统或执行程序创建，而不是由应用程序创建。</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112072244745.png" alt="202112072244745"></p><p>首先，我们知道段寄存器有96位，减去16位的段选择子，还剩80位，而attribute对应的就是高4字节的23:8(凑成16bit)；而base是三段(低4字节31:16+高4字节7:0+高4字节31:24)凑成32位；而limit由低4字节15:00+高4字节19:16，才20bit，也就是还缺12bit，这缺的根据G flag，在高位补0，或在低位补1。</p><ul><li><p>Base Address(高4字节bit 31:24+高4字节bit 7:0+低4字节bit 31:16)</p><p>将三个基地址字段凑一块形成一个32位的值，定义段的字节在0~4GB线性空间的位置</p></li><li><p>Segment Limit(高4字节bit 19:16+低4字节bit 15:0)</p><p>用于指定段的大小(应该是能访问段的大小)，由两截组成，高四位19:16加上低四位15:00，凑成20位。IA-32 architecture stacks always grow downwards, making this mechanism convenient for expandable stacks.</p></li><li><p>G flag(高4字节bit 23)</p><p>limit的粒度(granularity)标志。置0，limit以byte为单位，20位的limit则寻址范围是1MB(0x000FFFFF)；置1，limit以4KB为单位，20位的limit则寻址范围是4GB(0xFFFFFFFF)</p></li><li><p>D/B flag(高4字节bit 22)</p><p>根据段描述符是<strong>代码段</strong>、<strong>向下扩展数据段</strong>还是<strong>堆栈段</strong>执行不同的功能。（对于32位代码和数据段，此标志应始终设置为1，对于16位代码和数据段，应始终设置为0。）</p><ul><li>Executable code segment：这个flag称为D flag，表示段中指令引用的有效地址和操作数的默认长度。置1，假定为32位地址和32位或8位操作数(采用32位寻址方式)；置0，假定为16位地址和16位或8位操作数(采用16位寻址方式)。指令前缀 66H 可用于选择默认值以外的操作数大小，前缀 67H 可用于选择默认值以外的地址大小</li><li>Stack segment (data segment pointed to by the SS register)：这个flag称为B flag，指定用于隐式堆栈操作（例如入栈、出栈和调用）的堆栈指针的大小。B=1，隐式堆栈访问指令（如：PUSH POP CALL）使用32位堆栈指针寄存器ESP；B=0，隐式堆栈访问指令（如：PUSH POP CALL）使用16位堆栈指针寄存器SP。</li><li>Expand-down data segment：这个flag称为B flag，指定段的上限。B=1，上限为0xFFFFFFFF(4GB)；B=0，上限为0xFFFF(64KB)</li></ul></li><li><p>L flag(高4字节bit 21)</p><p>值为1时，以64位模式执行代码；值为0时，以兼容模式执行。当不在64位模式下或对于非代码段时，bit 21是保留的，应始终设置为0。如果设置了L位，则必须清除D位</p></li><li><p>AVL flag(高4字节bit 20)</p><p>供系统软件使用或作为保留段</p></li><li><p>P flag(高4字节bit 15)</p><p>置1表示该段存在内存中；置0表示该段不在内存中。(如果P=0，其他标志都不用看了，不起作用)</p></li><li><p>DPL field(高4字节bit 14:13)</p><p>表示段描述符特权级，只有想要加载这个段描述符的<strong>选择子的请求特权级别高于或者等于DPL</strong>才能加载这个段</p></li><li><p>S flag(高4字节bit 12)</p><p>置0，表示系统段描述符；置1，表示代码段或数据段</p></li><li><p>Type field(高4字节bit 11:8)</p><p>用于指定该段的访问类型(读写执行)和增长方向。代码，数据，系统段的编码方式不一样</p></li></ul><p>也就是说，这里描述符根据S flag和Type Field分为好几种，也就是</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112191304200.png" alt="202112191304200"></p><p>当S=1(bit 12)，为数据段或代码段，这个时候从type的取值(bit 11)可以区分是data还是code：</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112191848840.png" alt="202112191848840"></p><p>当S=0，表示系统描述符：Local descriptor-table (LDT) segment descriptor，Task-state segment (TSS) descriptor，Call-gate descriptor，Interrupt-gate descriptor，Trap-gate descriptor，Task-gate descriptor</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112202208933.png" alt="202112202208933"></p><p>再来说特权等级：CPL，DPL，RPL，参考Intel卷3第5.5 PRIVILEGE LEVELS</p><p>CPL，Current privilege level。它存储在CS和SS段寄存器的位0和1中。通常，CPL等于从中提取指令的代码段的特权级别。也就是CS或SS的段选择子中的RPL</p><p>DPL，Descriptor privilege level。访问该段所需要的特权级别是什么</p><p>RPL，Requested privilege level。用什么权限去访问一个段</p><h3 id="1-3-3-分页机制"><a href="#1-3-3-分页机制" class="headerlink" title="1.3.3 分页机制"></a>1.3.3 分页机制</h3><p>Intel手册卷3 CHAPTER 4 PAGING</p><p>通过上面一通操作，已经拿到了一个线性地址了，现在需要通过分页模型将这个线性地址与物理地址对应起来。简单介绍下分页的思想</p><p>一级分页，假设将线性地址分为两部分table(页表)，offset(页内偏移)，然后能页表里面包含entry(页项)，每个entry存的是一个起始地址(一个起始地址是32位也就是4B)，CPU从table中拿到对应的entry存储物理地址加上偏移，就得到实际的物理地址了。假设offset的范围是0~4KB，那么offset需要12位(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.461ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 4623.7 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1567.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2623.7,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(1000,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1500,0)"></path></g></g></g></svg></mjx-container>)来表示，假设是32位PC，剩下的20位用来表达entry，那么此时一个32位的线性地址能够表达<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="14.539ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 6426.3 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(2512.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(4080.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(5136.2,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>，可以映射4G，但是需要<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="16.776ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 7415.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(3012.6,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(4049.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5105.1,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(5605.1,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(6656.1,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>的物理内存来保存entry</p><p>二级分页，将线性地址分为三部分directory(页表目录)，table(页表)，offset(页内偏移)，假设offset的范围还是0~4KB用12位来表达，假设剩下来的20位，directory和table各占10位，那么此时一个32位线性地址能够表达<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="20.224ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 8938.9 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(2512.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(4024.9,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(5025.1,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(6593,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(7648.8,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>，但是只需要<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="27.708ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 12247.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(3012.6,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(3993.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msup" transform="translate(4994,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(6506.3,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(7506.5,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(8006.5,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(9043.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(10099.1,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mi" transform="translate(10599.1,0)"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"></path></g><g data-mml-node="mi" transform="translate(11488.1,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>来保存整个页表关系</p><p>N级页表..</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112192215822.png" alt="202112192215822"></p><p>通过上面解释可以看到，同样的32位线性地址，划分不同级别的页表所需要存储的页表关系的物理内存不一样，简单来说高级的分页占用的物理内存越小，但是CPU访问次数越多</p><p>Intel手册中提到了四种分页模式：32bit paging，PAE paging，4-level paging，5-level paging。其中前两个专门用于32位，后面两个专门用于64位</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112192210457.png" alt="202112192210457"></p><p>可以看到，经典的page size就是4KB了，至于每个entry存储的细节就不看了..具体的去手册找好了</p><p>分页级数太高会导致CPU处理变慢，解决效率问题，那就只有加缓存，于是有个新的东西TLB(Translation Lookaside Buffers)。首先了解几个名词：线性地址的高位（称为<strong>页号</strong>）决定了物理地址（称为<strong>页帧</strong>）的高位；线性地址的低位（称为<strong>页偏移</strong>）决定了物理地址的低位。页码和页偏移量之间的边界由page size决定。而TLB就是存储页号和页帧的映射。</p><h1 id="2-中断机制"><a href="#2-中断机制" class="headerlink" title="2 中断机制"></a>2 中断机制</h1><p>The processor provides two mechanisms for interrupting program execution, interrupts and exceptions:<br>• An interrupt is an asynchronous event that is typically triggered by an I/O device.<br>• An exception is a synchronous event that is generated when the processor detects one or more predefined conditions while executing an instruction. The IA-32 architecture specifies three classes of exceptions: faults, traps, and aborts.</p><p>处理器提供了两个打断程序执行的机制，中断和异常</p><ul><li><big><strong>中断</strong></big>是异步事件，通常由IO设备触发。Interrupts occur at random times during the execution of a program, in response to signals from hardware. System hardware uses interrupts to handle events external to the processor, such as requests to service peripheral devices. Software can also generate interrupts by executing the INT n instruction.Interrupts occur at random times during the execution of a program, in response to signals from hardware. System hardware uses interrupts to handle events external to the processor, such as requests to service peripheral devices. Software can also generate interrupts by executing the INT n instruction.<ul><li>External (hardware generated) interrupts：外部中断通过处理器上的引脚或通过本地APIC(Advanced Programmable Interrupt Controller)接收。当本地APIC启用时，LINT[1:0]引脚可以通过APIC的本地向量表(LVT)进行编程，以与任何处理器的异常或中断向量相关联。当本地APIC全局/硬件禁用时，这些引脚分别配置为INTR和NMI引脚。通过INTR引脚或通过本地APIC传递给处理器的任何外部中断称为<strong>可屏蔽硬件中断</strong>，EFLAGS寄存器中的IF标志允许将所有可屏蔽的硬件中断作为一组进行屏蔽。通过NMI引脚以及系统总线或APIC串行总线上以NMI传递模式传递给处理器的任何外部中断称为<strong>不可屏蔽中断</strong>，EFLAGS寄存器的IF标志对这个无效</li><li>Software-generated interrupts：通过INT指令+中断号直接触发对应的中断</li></ul></li><li><big><strong>异常</strong></big>是同步事件，处理器在执行指令时检测到一个或多个预定义条件生成的。异常分为三类：错误，陷阱，中止。Exceptions occur when the processor detects an error condition while executing an instruction, such as division by zero. The processor detects a variety of error conditions including protection violations, page faults, and internal machine faults.<ul><li>Program-Error Exceptions：The processor generates one or more exceptions when it detects program errors during the execution in an application program or the operating system or executive.</li><li>Software-Generated Exceptions: The INTO, INT1, INT3, and BOUND instructions permit exceptions to be generated in software.</li><li>Machine-Check Exceptions:</li></ul></li></ul><p>无论是外部中断，INT指令，触发异常，都是为了给CPU传一个中断号(也叫向量号)。为了帮助处理异常和中断，每个架构定义的异常和每个需要处理器特殊处理的中断条件都被分配了一个唯一的标识号，称为向量号。向量号的范围是0~255，其中0~31被系统保留，32~255可以由用户自己定义。</p><p><strong>当处理器拿到向量号后会以此作为索引去中断描述符表(IDT)查询对应的中断描述符，通过计算中断描述符得到处理异常或中断程序的入口点，之后处理器会挂起当前执行的程序或任务，执行中断或异常处理，执行完毕后再唤醒之前执行的程序</strong></p><blockquote><p>INTR只有一个引脚，怎么知道各种外设的中断呢？这个引脚级联了一堆中断控制器8259A..详情百度一下</p></blockquote><h2 id="2-1-中断描述符表"><a href="#2-1-中断描述符表" class="headerlink" title="2.1 中断描述符表"></a>2.1 中断描述符表</h2><p>interrupt descriptor table，就是一个大小为256的数组，这个数组保存的中断描述符。操作系统将这个数组保存到内存中，再通过LIDT指令将内存操作数中保存的基地址和限制(可以理解成中断描述表在内存的起始地址)加载到IDTR寄存器中。该指令只有在CPL为0时才能执行，一般操作系统的初始化代码在创建IDT时使用。通过SIDT指令将存储在IDTR中的基值和限值复制到内存中。</p><p>根据中断向量号去IDT中索引中断描述符，具体操作：取出IDTR中的IDT地址，加上<strong>中断向量号*8</strong>，得到的地址指向所要的中断描述符</p><p>就是下图这个感觉..</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112202310014.png" alt="202112202310014"></p><p>再说这数组中的数据中断描述符，分为三种：Task-gate descriptor，Interrupt-gate descriptor，Trap-gate descriptor</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112202312767.png" alt="202112202312767"></p><p>看起来和段描述差不多，其中task gate就与GDT或LDT中的task gate操作是差不多的；interrupt gate和trap gate与call gate差不多，中断门和陷阱门的区别是中断门不允许中断嵌套，处理中断的时候将EFLAGS.IF置1，屏蔽中断，陷阱门允许中断嵌套，不处理EFLAGS.IF值</p><p>也就是说从IDT中拿到中断描述符大致有两种处理方式，一种是类似任务门的(Intel手册卷3第7.3 TASK SWITCHING)，一种是类似调用门的(Intel手册卷3第5.8.2 Gate Descriptors到5.8.6 Returning from a Called Procedure)。这两种方式都已经能够拿到处理异常或中断程序的入口地址了</p><h2 id="2-2-中断-x2F-陷阱门"><a href="#2-2-中断-x2F-陷阱门" class="headerlink" title="2.2 中断/陷阱门"></a>2.2 中断/陷阱门</h2><p>根据中断描述符中的段选择子去GDT或LDT中索引段描述符，具体操作：取出GDTR/LDTR中的GDT/LDT地址。加上段选择子高13位*8，得到的地址为中断处理程序所在段的段基址；段基址加上中断描述符的段内偏移量得到的地址便为中断服务程序的地址。就是下图这个感觉：</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112202336597.png" alt="202112202336597"></p><p>拿到中断程序地址之后呢？最简单的办法就是，<strong>直接把中断描述符里的中断程序地址取出来，放在自己的CS:IP寄存器中</strong>，因为这里存的值就是下一跳指令的地址，只要放进去了，到下一个CPU指令周期时，就会去那里继续执行了，但CPU并没有这样简单粗暴。CPU据中断向量号去IDT中获取中断描述符，取出选择子中的DPL与当前特权级CPL进行比较，<strong>若特权级发生变化，则需要切换栈</strong>。（不同特权级有着不同的栈，如Linux使用了0，3特权级，则有两个栈，一个内核栈，一个用户栈）</p><blockquote><p>a. The segment selector and stack pointer for the stack to be used by the handler are obtained from the TSS for the currently executing task. On this new stack, the processor pushes the stack segment selector and stack pointer of the interrupted procedure.<br>b. The processor then saves the current state of the EFLAGS, CS, and EIP registers on the new stack (see Figure 6-4).<br>c. If an exception causes an error code to be saved, it is pushed on the new stack after the EIP value.</p></blockquote><p>处理器临时保存当前的旧栈SS和ESP的值，从TSS（每一个任务有一个TSS结构，其中保存着不同特权级栈的SS和ESP值）中获取与DPL特权级相同的栈信息加载到SS和ESP寄存器。再将旧栈SS和ESP的值压入新栈中。若没有特权级变化，则跳过此步骤。</p><p>然后处理器将EFLAGS、CS和EIP寄存器的当前状态保存在新堆栈上。</p><p>若该中断有错误码，压入错误码。</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112212305750.png" alt="202112212305750"></p><p>要从异常或中断处理程序过程返回，处理程序必须使用IRET（或IRETD）指令。IRET指令与RET指令类似，只是它将保存的标志恢复到EFLAGS寄存器中。EFLAGS寄存器的IOPL字段只有在CPL为0时才恢复。只有在CPL小于或等于IOPL时才改变IF标志。如果在调用处理程序过程时发生堆栈切换，则IRET指令在返回时切换回被中断过程的堆栈。</p><h2 id="2-3-任务门"><a href="#2-3-任务门" class="headerlink" title="2.3 任务门"></a>2.3 任务门</h2><p>这个在Linux上貌似没有使用..手册上提到使用task gate有三个优点</p><ul><li>被中断的程序或任务的整个上下文会自动保存</li><li>新的TSS允许处理程序在处理异常或中断时使用新的特权级别0堆栈。如果在当前权限级别0堆栈损坏时发生异常或中断，通过任务门访问处理程序可以通过为处理程序提供新的权限级别0堆栈来防止系统崩溃</li><li>处理程序可以通过给它一个单独的地址空间来进一步与其他任务隔离。这是通过给它一个单独的LDT来完成的</li></ul><p>优点即是缺点，使用单独的任务处理中断的缺点是必须在任务切换时保存的机器状态量使其比使用中断门慢，从而导致中断延迟增加。</p><p>这个逻辑与普通的task切换相同，错误码会被拷贝到新的TSS中..</p><p><img data-src="/assets/04_Make-MyOS-Basic-execution-env-and-Interrupt/202112212319287.png" alt="202112212319287"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-执行环境介绍&quot;&gt;&lt;a href=&quot;#1-执行环境介绍&quot; class=&quot;headerlink&quot; title=&quot;1 执行环境介绍&quot;&gt;&lt;/a&gt;1 执行环境介绍&lt;/h1&gt;&lt;p&gt;在find loader那一节之后，发现后面的代码真的看不懂了，直接抄也没有意义，于是补了一下相关的知识..希望能继续下去&lt;/p&gt;
&lt;h2 id=&quot;1-1-CPU工作模式&quot;&gt;&lt;a href=&quot;#1-1-CPU工作模式&quot; class=&quot;headerlink&quot; title=&quot;1.1 CPU工作模式&quot;&gt;&lt;/a&gt;1.1 CPU工作模式&lt;/h2&gt;&lt;p&gt;参考Intel手册卷3第2.2 MODES OF OPERATION&lt;/p&gt;
&lt;p&gt;32位的支持三种工作模式和一种准工作模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实地址模式(Real-address mode)，处理器上电(power-up)或复位(reset)后处于该模式。这个模式实际上是为了兼容8086，因为地址线只有20根，限制了寻址只能是1M大小，也就是通过&lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.452ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;26.774ex&quot; height=&quot;2.149ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -750 11834 950&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;段&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1000,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;寄&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2000,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;存&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3000,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;器&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4277.8,0)&quot;&gt;&lt;g data-mml-node=&quot;text&quot;&gt;&lt;path data-c=&quot;3C&quot; d=&quot;M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;text&quot; transform=&quot;translate(778,0)&quot;&gt;&lt;path data-c=&quot;3C&quot; d=&quot;M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6111.6,0)&quot;&gt;&lt;path data-c=&quot;34&quot; d=&quot;M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6833.8,0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(7834,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;偏&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(8834,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;移&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9834,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;地&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(10834,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;址&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;方式寻址。进入这个模式，也就只使用20根地址线，主要是因为A20M#引脚被屏蔽了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保护模式(Protected mode)，这个是80386时期引入的，也就是32位处理器原本的工作模式。在这个模式下不再使用&lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot;&gt;&lt;svg style=&quot;vertical-align: -0.452ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;26.774ex&quot; height=&quot;2.149ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -750 11834 950&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;段&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1000,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;寄&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2000,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;存&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3000,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;器&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4277.8,0)&quot;&gt;&lt;g data-mml-node=&quot;text&quot;&gt;&lt;path data-c=&quot;3C&quot; d=&quot;M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;text&quot; transform=&quot;translate(778,0)&quot;&gt;&lt;path data-c=&quot;3C&quot; d=&quot;M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6111.6,0)&quot;&gt;&lt;path data-c=&quot;34&quot; d=&quot;M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6833.8,0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(7834,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;偏&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(8834,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;移&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9834,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;地&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(10834,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;址&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/mjx-container&gt;的方式寻址，而是通过段描述符的方式描述基址和限长，并通过描述符中的属性设置实现对内存段的访问限制和数据保护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚拟8086模式(Virtual-8086 mode)，是一种准工作模式，目的是为了在保护模式下能够执行8086程序</summary>
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Make OS" scheme="https://sidneyding.cn/categories/OS/Make-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>[Make MyOS] Find loader</title>
    <link href="https://sidneyding.cn/posts/1d4ddf18/"/>
    <id>https://sidneyding.cn/posts/1d4ddf18/</id>
    <published>2021-10-31T15:05:46.000Z</published>
    <updated>2023-08-13T02:39:20.504Z</updated>
    
    <content type="html"><![CDATA[<p>说是第三天，我看了该一个星期了..发现之前看得有点浮躁，最近看了费曼读书法有了新的想法，不怕慢，就怕没看明白，所以听费曼的，每次看卡壳了，就返回去重新看..</p><p>看到这里，突然觉得还是以《64位》为主比较好，《32位》太老了，用的还是nask转换起来有点累，并且《64位》介绍得细啊，所以我悟了，《32位》用来打辅助吧..</p><h1 id="1-软盘与FAT12"><a href="#1-软盘与FAT12" class="headerlink" title="1 软盘与FAT12"></a>1 软盘与FAT12</h1><p>先来看软盘，一个PC里面可以有多个软盘，一个软盘里面包含2个磁头，80个柱面，18个扇区。因为软盘正反面都可以存储数据，所以有俩磁头去读取数据。柱面参考下图(注意编号0~79)，英文是cylinder；扇区参考下图(注意编号1~18)，英文是sector</p><span id="more"></span><p><img data-src="/assets/03_Make-MyOS-Find-loader/202110162308914.png" alt="202110162308914"></p><p>两本书用的都是 FAT12 文件系统来装载 Loader 程序和内核程序，将软盘格式化成 FAT12 文件系统时，FAT类文件系统会对软盘里的扇区进行结构化处理，把软盘<strong>扇区划分为引导扇区，FAT表，根目录区和数据区</strong> 4 部分</p><ul><li>引导扇区</li></ul><p>这一部分其实第一天的程序helloos2就已经介绍个大概了，再抄一遍《64位》里面的表格</p><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>内容</th><th>本引导程序数据</th></tr></thead><tbody><tr><td>BS_jmpBoot</td><td>0</td><td>3</td><td>跳转指令</td><td>jmp short Label_Start nop</td></tr><tr><td>BS_OEMName</td><td>3</td><td>8</td><td>生产厂商名</td><td>‘MINEboot’</td></tr><tr><td>BPB_BytesPerSec</td><td>11</td><td>2</td><td>每扇区字节数</td><td>512</td></tr><tr><td>BPB_SecPerClus</td><td>13</td><td>1</td><td>每簇扇区数</td><td>1</td></tr><tr><td>BPB_RsvdSecCnt</td><td>14</td><td>2</td><td>保留扇区数</td><td>1</td></tr><tr><td>BPB_NumFATs</td><td>16</td><td>1</td><td>FAT表的份数</td><td>2</td></tr><tr><td>BPB_RootEntCnt</td><td>17</td><td>2</td><td>根目录可容纳的目录份数</td><td>224</td></tr><tr><td>BPB_TotSec16</td><td>19</td><td>2</td><td>总扇区数</td><td>2880</td></tr><tr><td>BPB_Media</td><td>21</td><td>1</td><td>介质描述符</td><td>0xF0</td></tr><tr><td>BPB_FATs16</td><td>22</td><td>2</td><td>每FAT扇区数</td><td>9</td></tr><tr><td>BPB_SecPerTrk</td><td>24</td><td>2</td><td>每磁道扇区数</td><td>18</td></tr><tr><td>BPB_NumHeads</td><td>26</td><td>2</td><td>磁头数</td><td>2</td></tr><tr><td>BPB_HiddSec</td><td>28</td><td>4</td><td>隐藏扇区数</td><td>0</td></tr><tr><td>BPB_TotSec32</td><td>32</td><td>4</td><td>若BPB_TotSec16为0，则由该值记录扇区数</td><td>0</td></tr><tr><td>BS_DrvNum</td><td>36</td><td>1</td><td>int 13h的驱动器号</td><td>0</td></tr><tr><td>BS_Reserved1</td><td>37</td><td>1</td><td>未使用</td><td>0</td></tr><tr><td>BS_BootSig</td><td>38</td><td>1</td><td>扩展引导标记(29h)</td><td>0x29</td></tr><tr><td>BS_VolID</td><td>39</td><td>4</td><td>卷序列号</td><td>0</td></tr><tr><td>BS_VolLab</td><td>43</td><td>11</td><td>卷标</td><td>‘boot loader’</td></tr><tr><td>BS_FileSysType</td><td>54</td><td>8</td><td>描述文件系统类型</td><td>‘FAT12’</td></tr><tr><td>引导代码</td><td>62</td><td>448</td><td>引导代码，数据及其他信息</td><td></td></tr><tr><td>结束标志</td><td>510</td><td>2</td><td>结束标志0xAA55</td><td>0xAA55</td></tr></tbody></table><p>其中，</p><p>BPB_Media，对于不可移动存储介质而言，标准值是0xF8，对于可移动存储介质，常用值是0xF0。此域合法值是0xF0，0xF8，0xF9，0xFB，0xFC，0xFD，0xFE，0xFF。</p><p>BS_VolLab，就是Windows或Linux系统中显示的磁盘名</p><p>按照上述描述，可将软盘扇区描绘成下图，其中FAT2是对FAT1的备份</p><p><img data-src="/assets/03_Make-MyOS-Find-loader/202110162324743.png" alt="202110162324743"></p><ul><li>FAT表</li></ul><p>FAT12文件系统是以簇为单位来分配数据区的存储空间，每个簇的大小为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="39.33ex" height="2.059ex" role="img" focusable="false" viewBox="0 -705 17384 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(1510,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(2269,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(2769,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(3528,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4018,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(4379,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4845,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(5314,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(6065,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(6531,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6982,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(7627,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(8093,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(8526,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(9304,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(10063,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(10814,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(11573,0)"><path data-c="5F" d="M0 -62V-25H499V-62H0Z"></path></g><g data-mml-node="mi" transform="translate(12073,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(12718,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(13184,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(13617,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(14368,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(14834,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(15285,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(16045,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(16343,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(16915,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container>(扇区数×扇区字节数)字节，<strong>数据区的簇号与FAT表的表项是一一对应关系</strong>。文件在FAT类文件系统存储单位是簇，即使文件长度只有1字节，也是分配了一个簇。</p><blockquote><p>在该实例中，1簇=1扇区，数据区有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="70.82ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 31302.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(500,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1500,0)"></path></g><g data-mml-node="mo" transform="translate(2222.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3222.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3722.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4111.4,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mi" transform="translate(5162.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(5921.4,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(6680.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(7291.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8291.9,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path></g><g data-mml-node="mo" transform="translate(8791.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(9180.9,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(9929.9,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(10679.9,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mn" transform="translate(11383.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(11883.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(12495.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(13495.3,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path></g><g data-mml-node="mo" transform="translate(13995.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(14384.3,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(15133.3,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(15883.3,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mn" transform="translate(16587.3,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(17087.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(17698.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(18698.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(19698.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(20087.8,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mi" transform="translate(20846.8,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(21331.8,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(21816.8,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(22177.8,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mi" transform="translate(23005.8,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(23350.8,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(23801.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(24468.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(25524.3,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(500,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1500,0)"></path></g><g data-mml-node="mi" transform="translate(27524.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">扇</text></g><g data-mml-node="mi" transform="translate(28524.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">区</text></g><g data-mml-node="mo" transform="translate(29524.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(29913.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">簇</text></g><g data-mml-node="mo" transform="translate(30913.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，而FAT1表的大小是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="17.261ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 7629.6 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(1278,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"></path></g><g data-mml-node="mi" transform="translate(2778,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mo" transform="translate(3814.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(4870.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1500,0)"></path></g><g data-mml-node="mi" transform="translate(6870.6,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>，每个表项占12bit(1.5B)，一共有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="17.724ex" height="1.717ex" role="img" focusable="false" viewBox="0 -677 7834 759"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1500,0)"></path></g><g data-mml-node="mo" transform="translate(2222.2,0)"><path data-c="F7" d="M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z"></path></g><g data-mml-node="mn" transform="translate(3222.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(4778.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5834,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1500,0)"></path></g></g></g></svg></mjx-container>个表项，其中有两个表项不用，也就是3070个FAT表项，对应2847个簇是绰绰有余了</p></blockquote><p>FAT表由FAT表项构成。每个FAT表项的大小有12位、16位、和32位三种情况。每个FAT表项都有一个固定的编号，这个编号从0开始。</p><table><thead>  <tr>    <th>FAT项</th>    <th>实例值</th>    <th>描述</th>  </tr></thead><tbody>  <tr>    <td>0</td>    <td>FF0H</td>    <td rowspan="2">磁盘标识字，低字节与BPB_Media数值保持一致<br>第一个簇已经被占用</td>  </tr>  <tr>    <td>1</td>    <td>FFFH</td>  </tr>  <tr>    <td>2</td>    <td>003H</td>    <td rowspan="6">0x000：可用簇<br>0x002 ~ 0xFEF：已用簇标识下一个簇的簇号<br>0xFF0 ~ 0xFF6：保留簇<br>0xFF7：坏簇<br>0xFF8 ~ 0xFFF：文件的最后一个簇</td>  </tr>  <tr>    <td>3</td>    <td>004H</td>  </tr>  <tr>    <td>...</td>    <td>...</td>  </tr>  <tr>    <td>N</td>    <td>FFFH</td>  </tr>  <tr>    <td>N+1</td>    <td>000H</td>  </tr>  <tr>    <td>...</td>    <td>...</td>  </tr></tbody></table>FAT表的0号和1号FAT表项有专门的用途。0号FAT表项通常用来存放分区所在的介质类型；1号FAT表项用来存储文件系统的肮脏标志，表明文件系统被非法卸载或者磁盘表面存在错误。<p>每一个FAT表项都会映射FAT数据区的一个簇中。因为0号FAT表项和1号FAT表项有特殊用途，无法与数据区中的簇形成映射，所以从2号FAT表项开始跟数据区中的第一个簇映射，正因为如此，<strong>数据区中的第一个簇也就编号为2号簇，这也是没有0号簇和1号簇的原因</strong>。然后3号簇跟3号FAT表项映射，4号簇跟4号FAT表项映射，以此类推，直到数据区中的最后一个簇。比如说FAT[2]中实例值是003H(指向FAT[3])，表示对应数据区2号簇，实际上第(2-2=0)号扇区，并要在FAT[3]中找更后面的数据，<strong>实例值指的就是下一个FAT项</strong></p><p>在编写程序的时候我们直接跳过FAT[0]和FAT[1]即可，并不使用它们，不必要理会其中的值。</p><ul><li>根目录区和数据区</li></ul><p>根目录和数据区都保存着与文件相关的数据，只不过根目录只能保存目录项信息，而数据区不但可以保存目录项信息，还可以保存文件内的数据。此处所提及的<strong>目录项是由一个32B</strong>组成的结构体，它既可以 表示成一个目录，又可以表示成一个文件，其中<strong>字段DIR_FstClus描述了文件在磁盘存放的具体位置</strong></p><table><thead><tr><th align="center">名称</th><th align="center">偏移</th><th align="center">长度</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>DIR_Name</strong></td><td align="center"><strong>0x00</strong></td><td align="center"><strong>11</strong></td><td align="center"><strong>文件名8B，扩展名3B</strong></td></tr><tr><td align="center">DIR_Attr</td><td align="center">0x0B</td><td align="center">1</td><td align="center">文件属性</td></tr><tr><td align="center">保留</td><td align="center">0x0C</td><td align="center">10</td><td align="center">保留位</td></tr><tr><td align="center">DIR_WrtTime</td><td align="center">0x16</td><td align="center">2</td><td align="center">最后一次写入时间</td></tr><tr><td align="center">DIR_WrtDate</td><td align="center">0x18</td><td align="center">2</td><td align="center">最后一次写入日期</td></tr><tr><td align="center"><strong>DIR_FstClus</strong></td><td align="center"><strong>0x1A</strong></td><td align="center">2</td><td align="center"><strong>起始簇号</strong></td></tr><tr><td align="center">DIR_FileSize</td><td align="center">0x1C</td><td align="center">4</td><td align="center">文件大小</td></tr></tbody></table><p><img data-src="/assets/03_Make-MyOS-Find-loader/202112261614209.png" alt="Root Directory Entry Format"></p><p><a href="http://www.c-jump.com/CIS24/Slides/FAT/lecture.html#F01_0140_root_directory">The FAT File System</a></p><h1 id="2-boot-asm"><a href="#2-boot-asm" class="headerlink" title="2 boot.asm"></a>2 boot.asm</h1><p>了解了FAT文件系统知识后，再来瞅瞅《64位》中boot程序，感觉比《32位》那个解释得更加详细一点</p><p>引导代码<code>boot.bin</code>文件是放在引导扇区中的，<code>LOADER.BIN</code>文件是放在数据区中的一个个簇中，而文件的文件名是放在根目录区中的目录项的，根目录区的目录项就保存着文件起始簇号，而数据区中的每个簇都与FAT1表中每个FAT项对应的，每个FAT项的值标明了下一个簇号。</p><p>所以想将数据区的文件加载到内存，需要先去根目录区找文件名，根据文件名定位根目录区目录项，接着拿到文件在数据区的起始簇号，开始读取文件内容，因为簇号与FAT表项是对应关系，也就能得到起始FAT表项，根据起始FAT表项接着读下一个FAT表项，就能拿到下一个簇内容了，直到FAT表项的值为<code>0xFFF</code></p><p>整坨代码大概是这么个关系</p><p><img data-src="/assets/03_Make-MyOS-Find-loader/202112261616755.svg" alt="202112261616755"></p><h2 id="2-1-FAT12文件系统数据"><a href="#2-1-FAT12文件系统数据" class="headerlink" title="2.1 FAT12文件系统数据"></a>2.1 FAT12文件系统数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">; 告诉编译器这段代码要加载到0x7c00处的</span><br><span class="line">; 编译器在编译代码的时涉及到变量寻址(标号)会自动加上0x7c00这个基址</span><br><span class="line">; 但是并不会影响到CS DS ES SS</span><br><span class="line">    org 0x7c00</span><br><span class="line"></span><br><span class="line">BaseOfStack    equ  0x7c00  ; 相当于C语言的 #define</span><br><span class="line"></span><br><span class="line">BaseOfLoader    equ 0x1000</span><br><span class="line">OffsetOfLoader  equ 0x00</span><br><span class="line"></span><br><span class="line">RootDirSectors  equ 14</span><br><span class="line">SectorNumOfRootDirStart equ 19</span><br><span class="line">SectorNumOfFAT1Start    equ 1</span><br><span class="line">SectorBalance   equ 17</span><br><span class="line">    ; 段内短转移，以当前ip的相对跳转地址的偏依量作为转移量，但偏移量只允许在-128 ~ +127字节之间</span><br><span class="line">    jmp short Label_Start  ; 下面只是磁盘的元数据 真正程序开始是Label_Start</span><br><span class="line">    nop  ; fat12文件头格式中的BS_jmpBoot固定格式</span><br><span class="line">    BS_OEMName  db  'MINEboot'</span><br><span class="line">    BPB_BytesPerSec dw  512</span><br><span class="line">    BPB_SecPerClus  db  1</span><br><span class="line">    BPB_RsvdSecCnt  dw  1</span><br><span class="line">    BPB_NumFATs db  2</span><br><span class="line">    BPB_RootEntCnt  dw  224</span><br><span class="line">    BPB_TotSec16    dw  2880</span><br><span class="line">    BPB_Media   db  0xf0</span><br><span class="line">    BPB_FATSz16 dw  9</span><br><span class="line">    BPB_SecPerTrk   dw  18</span><br><span class="line">    BPB_NumHeads    dw  2</span><br><span class="line">    BPB_HiddSec dd  0</span><br><span class="line">    BPB_TotSec32    dd  0</span><br><span class="line">    BS_DrvNum   db  0</span><br><span class="line">    BS_Reserved1    db  0</span><br><span class="line">    BS_BootSig  db  0x29</span><br><span class="line">    BS_VolID    dd  0</span><br><span class="line">    BS_VolLab   db  'boot loader'</span><br><span class="line">    BS_FileSysType  db  'FAT12   '</span><br></pre></td></tr></table></figure><p><code>BaseOfLoader equ 0x1000</code>和<code>OffsetOfLoader equ 0x00</code>组合成了Loader的起始地址，这个组合必须经过实模式的地址变换公式才能生成物理地址，即<code>BaseOfLoader &lt;&lt; 4 + OffsetOfLoader = 0x10000</code></p><p><code>RootDirSectors equ 14</code>定义了根目录占用的扇区数，这个数值是根据FAT12文件系统提供的起始物理地址计算而得，即<code>(BPB_RootEntCnt * 32 + BPB_BytesPerSec - 1) / BPB_BytesPerSec = (224 * 32 + 512 - 1) / 512 = 14</code></p><p><code>SectorNumOfRootDirStart equ 19</code>定义了根目录的起始扇区号，这个数值是根据<code>保留扇区数 + FAT表扇区数 * FAT表份数 = 1 + 9 * 2 = 19</code>，因为扇区标号是从0开始计数，所以根目录起始扇区为19</p><p><code>SectorNumOfFAT1Start equ 1</code>表示FAT1表的起始扇区号，在FAT1表前有一个保留扇区</p><p><code>SectorBalance equ 17</code>用于平衡文件的起始簇号与数据区起始簇号的差值。数据区中的第一个簇为2号簇，所以把必须将FAT表项值减2以计算FAT表项对应的数据区起始扇区号，实际上是(19 - 2)</p><p>代码是在程序一开始就定义的，但是程序是从上往下顺序执行的，代码中有相当一部分是数据，并不是代码，所以我们一开始就需要使用无条件跳转指令<code>jmp short Label_Start</code>，跳转到<code>Label_Start</code>标签处开始执行代码。</p><h2 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Label_Start:</span><br><span class="line">    mov ax, cs  ; 最开始cs是等于0的</span><br><span class="line">    mov ds, ax  ; ds es ss不能通过立即数赋值 需要ax中转</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, BaseOfStack  ; 栈指针设到0x7c00</span><br><span class="line"></span><br><span class="line">;=======    clear screen</span><br><span class="line">    mov ax, 0600h</span><br><span class="line">    mov bx, 0700h</span><br><span class="line">    mov cx, 0</span><br><span class="line">    mov dx, 0184fh</span><br><span class="line">    int 10h           ; 0x10中断的AH=0x06号功能 清屏</span><br><span class="line"></span><br><span class="line">;=======    set focus</span><br><span class="line">    mov ax, 0200h</span><br><span class="line">    mov bx, 0000h</span><br><span class="line">    mov dx, 0000h</span><br><span class="line">    int 10h           ; 0x10中断的AH=0x2号功能 设置游标位置</span><br><span class="line"></span><br><span class="line">;=======    display on screen : Start Booting......</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000fh</span><br><span class="line">    mov dx, 0000h</span><br><span class="line">    mov cx, 10</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartBootMessage  ; 字符串定义在最后 Start Boot</span><br><span class="line">    int 10h          ; 0x10中断的AH=0x13号功能 写字符串</span><br><span class="line"></span><br><span class="line">;=======    reset floppy</span><br><span class="line">    xor ah, ah      ; ah=0</span><br><span class="line">    xor dl, dl      ; dl=0</span><br><span class="line">    int 13h         ; 0x13中断的AH=0号功能 复位磁盘</span><br></pre></td></tr></table></figure><p>这段没啥好说的..看第二天的就好了</p><h2 id="2-3-查找loader-bin文件"><a href="#2-3-查找loader-bin文件" class="headerlink" title="2.3 查找loader.bin文件"></a>2.3 查找loader.bin文件</h2><p>核心目标，从根目录中搜索出引导加载程序(文件名为loader.bin)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">;=======    search loader.bin</span><br><span class="line">    mov word [SectorNo], SectorNumOfRootDirStart  ; 根目录从第19个扇区开始</span><br><span class="line"></span><br><span class="line">Lable_Search_In_Root_Dir_Begin:</span><br><span class="line">    cmp word [RootDirSizeForLoop], 0  ; RootDirSizeForLoop初始值为根目录扇区数 一个扇区一个扇区找</span><br><span class="line">    jz  Label_No_LoaderBin  ; 找到剩0 就表示找不到</span><br><span class="line">    dec word [RootDirSizeForLoop]  ; RootDirSizeForLoop--</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov es, ax  ; 不能直接通过立即数赋值 需要通过ax中转以下 es=00h</span><br><span class="line">    mov bx, 8000h  ; bx=8000h</span><br><span class="line">    mov ax, [SectorNo]  ; ax=19</span><br><span class="line">    mov cl, 1  ; cl=1</span><br><span class="line">    ; call命令实际上是两条命令结合 push ip和mov ip, Func_ReadOneSector</span><br><span class="line">    ; 然后push ip又可以拆成两条指令 add sp, 2 和 mov sp, ip</span><br><span class="line">    ; 简单来说就是将当前的ip存到栈sp+2位置(向上增长，因为看到下面bp-2了)，并且将ip指向Func_ReadOneSector</span><br><span class="line">    ; 而ip的值表示下一条指令 也就是说下一条指令执行Func_ReadOneSector的东西</span><br><span class="line">    call Func_ReadOneSector</span><br><span class="line">    mov si, LoaderFileName  ; 通过ds:si指向文件名源地址</span><br><span class="line">    mov di, 8000h  ; es:di也指向了扇区内容起始地址</span><br><span class="line">    cld  ; DF复位=0，这样通过LODSB从ds:si加载内容到al后 si就会递增1</span><br><span class="line">    mov dx, 10h  ; dx记录一个扇区可容纳的目录项个数 一个扇区最多有512B/32B=16=0x10个目录项</span><br><span class="line"></span><br><span class="line">Label_Search_For_LoaderBin:</span><br><span class="line">    cmp dx, 0</span><br><span class="line">    jz  Label_Goto_Next_Sector_In_Root_Dir</span><br><span class="line">    dec dx  ; 上面三句就是一个扇区所有目录项都找完了 可以去下一个扇区找了</span><br><span class="line">    mov cx, 11  ; 文件名的长度11B 包括文件名和扩展名 但不包括分隔符 .</span><br><span class="line"></span><br><span class="line">Label_Cmp_FileName:</span><br><span class="line">    cmp cx, 0</span><br><span class="line">    jz  Label_FileName_Found</span><br><span class="line">    dec cx  ; 一样的道理 这里是比较文件名</span><br><span class="line">    lodsb  ; 从ds:si读取一个字节到寄存器AL 然后si+=1(取决于DF)</span><br><span class="line">    cmp al, byte [es:di]  ; 一个字符一个字符去比较</span><br><span class="line">    jz  Label_Go_On  ; 如果相等</span><br><span class="line">    jmp Label_Different  ; 如果不相等</span><br><span class="line"></span><br><span class="line">Label_Go_On:</span><br><span class="line">    inc di  ; di+=1</span><br><span class="line">    jmp Label_Cmp_FileName  ; 也就是比较下一个字符</span><br><span class="line"></span><br><span class="line">Label_Different:</span><br><span class="line">    and di, 0ffe0h  ; 将di后5位置0 消除比较文件名带来的影响</span><br><span class="line">    add di, 20h  ; di+=32B 下一个目录项</span><br><span class="line">    mov si, LoaderFileName  ; 重置要搜索的文件名的指针</span><br><span class="line">    jmp Label_Search_For_LoaderBin  ; 继续找</span><br><span class="line"></span><br><span class="line">Label_Goto_Next_Sector_In_Root_Dir:</span><br><span class="line">    add word  [SectorNo], 1  ; 扇区号+1</span><br><span class="line">    jmp Lable_Search_In_Root_Dir_Begin  ; 去下一个扇区去找</span><br><span class="line"></span><br><span class="line">;=======    display on screen : ERROR:No LOADER Found</span><br><span class="line">Label_No_LoaderBin:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008ch</span><br><span class="line">    mov dx, 0100h</span><br><span class="line">    mov cx, 21</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, NoLoaderMessage</span><br><span class="line">    int 10h  ; 如果找不到就在屏幕输出 ERROR:No LOADER Found</span><br><span class="line">    jmp $  ; 死循环在这里</span><br></pre></td></tr></table></figure><p>这里的Func_ReadOneSector可以先理解为一个函数，用于读取磁盘扇区内容的函数，参数是ax=磁盘起始扇区号，cl读入的扇区数量；返回值FALGS.CF，其中0表示没错误，并且扇区内容加载到es:bx上</p><p>1 为什么要使用循环去读取磁盘？AL不是能够直接指定读取多少个扇区麽</p><blockquote><p>指定处理的扇区数，范围在0x01~0xff(在指定0x02以上的数值时，要特别注意能够连续处理多个扇区的条件，如果是FD的话，似乎不能跨越多个磁道，也不能超过64KB界限)</p></blockquote><p>2 FAT12文件系统的文件名是不分大小写的，即是将小写字母命名的文件赋值到FAT12文件系统内，文件系统也会为其创建大写字母的文件名和目录项。而小写字母文件名只作为其显示名，而真正的数据内容皆保存在对应的大写字母目录项。所以这里应该搜索大写字母的文件名字符串。</p><p>3 关于 <strong>lodsb</strong> 指令，参考64-ia-32-architectures-software-developer-vol-2-manual的chapter 3.2指令介绍</p><p>LODS/LODSB/LODSW/LODSD/LODSQ—Load String</p><p>分别将源操作数中的字节、字或双字加载到AL、AX或EAX寄存器中。源操作数是一个内存位置，其地址从DS:ESI或DS:SI寄存器中读取（取决于指令的地址大小属性，分别为32或16）。DS段可以被段覆盖前缀覆盖。</p><p>字节、字或双字从内存位置传送到 AL、AX 或 EAX 寄存器后，(E)SI寄存器根据EFLAGS寄存器中DF标志的设置自动递增或递减。（如果DF标志为0，（E）SI寄存器递增；如果DF标志为1，ESI寄存器递减。）（E）SI寄存器递增或递减1为字节操作，递减2为字运算，或双字运算乘以4。</p><p>4 关于操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and di, 0ffe0h  ; 将di后5位置0 消除找文件名带来的影响</span><br><span class="line">add di, 20h  ; +32 下一个目录项</span><br></pre></td></tr></table></figure><p>因为文件名是11B，最大也就是<code>1011b</code>，一个目录项的大小是32B，也就是<code>100000b</code>，再看di初始值是<code>mov di, 8000h</code>，也就是说每个目录项的起始地址低5位都是0，而查找时加上11B顶多只会影响到低4位，所以将低5位置0是没有毛病的，乃至于只将低4位置0都是ok的，只要di的起始地址低4位别有1就好</p><h2 id="2-4-加载扇区内容到内存"><a href="#2-4-加载扇区内容到内存" class="headerlink" title="2.4 加载扇区内容到内存"></a>2.4 加载扇区内容到内存</h2><p>如果在根目录中发现了文件名(loader.bin)，那就表示磁盘中有这个文件，那么接下来的任务就是读出文件的数据到内存，最终将整个文件加载到内存中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;=======    found loader.bin name in root director struct</span><br><span class="line">Label_FileName_Found:  ; 如果找到了 那么现在es:di指向的是 包含文件的目录项+11B</span><br><span class="line">    mov ax, RootDirSectors  ; 根目录扇区数14</span><br><span class="line">    and di, 0ffe0h  ; 清除文件名的影响 现在es:di指向的是包含文件的目录项</span><br><span class="line">    add di, 01ah  ; 目录项偏移0x1A(DIR_FstClus)得到起始簇号(数据区的，数据区第一个簇是2)</span><br><span class="line">    mov cx, word [es:di]  ; 起始簇号(这里1簇只包含1个扇区 也可以理解为起始扇区号)占2B</span><br><span class="line">    push cx  ; 将起始簇号(也是FAT表项值)暂存到栈中</span><br><span class="line">    add cx, ax  ; cx += 14</span><br><span class="line">    add cx, SectorBalance  ; cx += 17  实际上是+19(FAT占的扇区)-2(数据区从2开始的)得到实际的起始扇区号</span><br><span class="line">    mov ax, BaseOfLoader  ; ax = 0x1000</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov bx, OffsetOfLoader  ; 通过es:bx=0x1000&lt;&lt;4+0x00=0x10000得到loader的起始地址</span><br><span class="line">    mov ax, cx  ; 存储文件的实际起始扇区号 放在ax中</span><br><span class="line"></span><br><span class="line">Label_Go_On_Loading_File:</span><br><span class="line">    push ax  ; 接着上面的说咯 将起始扇区号和加载文件内容起始地址保存起来 但是要注意cx也进栈了 并且没有出栈</span><br><span class="line">    push bx  ; 所以出栈顺序应当是 bx(内存加载起始地址)-&gt;ax(存储文件的实际起始扇区号)-&gt;cx(起始簇号)</span><br><span class="line">    mov ah, 0eh  ; 打印一个字符</span><br><span class="line">    mov al, '.'</span><br><span class="line">    mov bl, 0fh</span><br><span class="line">    int 10h  ; 调用中断int 10h在屏幕上打印一个"."</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax  ; 保存的起始扇区号和加载文件内容起始地址取出来</span><br><span class="line"></span><br><span class="line">    mov cl, 1  ; 读一个扇区</span><br><span class="line">    call Func_ReadOneSector  ; 将一个扇区的内容读出来</span><br><span class="line">    pop ax  ; 这里就是cx了 取出此扇区在FAT中的序号(和数据区的簇号是一一对应的)</span><br><span class="line">    call Func_GetFATEntry</span><br><span class="line">    cmp ax, 0fffh  ; 读出来FAT项值是否为0xFFF，如果是文件尾</span><br><span class="line">    jz  Label_File_Loaded  ; 就表示loader.bin文件加载到内存完毕</span><br><span class="line">    push ax  ; 将FAT表项值入栈</span><br><span class="line">    mov dx, RootDirSectors</span><br><span class="line">    add ax, dx</span><br><span class="line">    add ax, SectorBalance  ; 得到下一个起始扇区号</span><br><span class="line">    add bx, [BPB_BytesPerSec]  ; bx再向前进一个扇区 存储下一个</span><br><span class="line">    jmp Label_Go_On_Loading_File  ; 继续下一个扇区</span><br><span class="line"></span><br><span class="line">Label_File_Loaded:</span><br><span class="line">    jmp $  ; 因为还没有写loader.bin所以就停在这里</span><br></pre></td></tr></table></figure><p>这里又提到了另一个函数Func_GetFATEntry，这个函数的作用是根据当前FAT表项索引来获取当前FAT表项值(下一个表项索引或文件结尾标志0xfff)。这里会根据FAT表项指向的数据区的簇的内容加载到内存0x10000</p><h2 id="2-5-读取磁盘扇区模块"><a href="#2-5-读取磁盘扇区模块" class="headerlink" title="2.5 读取磁盘扇区模块"></a>2.5 读取磁盘扇区模块</h2><p>上面提到读取磁盘扇区的函数，该模块的作用就是读取软盘，每次读取一个扇区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;=======    read one sector from floppy</span><br><span class="line">Func_ReadOneSector:</span><br><span class="line">    push bp  ; 将原来的bp保存在栈sp=sp+2位置</span><br><span class="line">    mov bp, sp  ; 把当前的sp位置存在bp中 这两步就被称之为压栈操作</span><br><span class="line">    sub esp, 2  ; 再找栈要2B的空间 局部变量</span><br><span class="line">    mov byte [bp - 2], cl  ; 把cl的值存在刚才申请的栈空间中</span><br><span class="line">    push bx  ; bx将要被使用 先将bx保存在sp=sp+2位置</span><br><span class="line">    mov bl, [BPB_SecPerTrk]  ; bl = 18</span><br><span class="line">    div bl  ; ax / bl = al...ah</span><br><span class="line">    inc ah  ; ah+1 余数+1得到柱面的开始扇区号</span><br><span class="line">    mov cl, ah  ; 起始扇区号存到cl</span><br><span class="line">    mov dh, al  ; 将al存到dh</span><br><span class="line">    shr al, 1  ; al&gt;&gt;1 商右移1位得到柱面号</span><br><span class="line">    mov ch, al  ; 柱面号存到ch</span><br><span class="line">    and dh, 1  ; dh&amp;1 商和1与运算得到磁头号</span><br><span class="line">    ; pop实际上是push的逆运算 mov bx, sp 和 sub sp, 2</span><br><span class="line">    ; 意思就是将当前栈顶的值取出来放bx中，再将栈顶收缩</span><br><span class="line">    pop bx</span><br><span class="line">    mov dl, [BS_DrvNum]  ; 驱动器号 0表示A盘</span><br><span class="line">    ; 到这里参数都准备好了 ch=柱面号 cl=起始扇区号 dh=磁头号 dl=驱动器号 es:bx=读取内容存放的缓冲区位置</span><br><span class="line">Label_Go_On_Reading:</span><br><span class="line">    mov ah, 2  ; 表示要读磁盘</span><br><span class="line">    mov al, byte [bp - 2]  ; 要读多少个扇区 从栈中将数据取出来</span><br><span class="line">    int 13h  ; 0x13中断的AH=02号功能 读取扇区</span><br><span class="line">    jc  Label_Go_On_Reading  ; 如果读盘错误CF值会被置为1 跳过去继续读</span><br><span class="line">    add esp, 2  ; 栈顶+2 回收栈空间</span><br><span class="line">    pop bp  ; 将进入函数之前的bp取回来 再修正栈</span><br><span class="line">    ; 这条指令等于pop ip，也就是将存在当前栈顶的ip(调用函数之前的位置)取回来，再将修正栈顶</span><br><span class="line">    ; 也就等于是子函数结束 回到调用函数的位置 继续执行</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这个<code>Func_ReadOneSector</code>其实就可以理解为C语言中的函数，功能就是通过BIOS中断<code>int 13h</code>的主功能号<code>AH=02h</code>实现软盘扇区的读取操作</p><blockquote><p>INT 13h, AH=02h功能：读取磁盘扇区</p><p>AL=读入的扇区数(必须非0)</p><p>CH=磁道号(柱面号)的低8位</p><p>CL=扇区号1~63(bit 0~5)，磁道号(柱面号)的高2位(bit 6~7，只对硬盘有效)</p><p>DH=磁头号</p><p>DL=驱动器号(如果操作的是硬盘驱动器，bit 7必须被置位)</p><p>ES:BX=数据缓冲区</p><p>返回值:</p><p>FLAGS.CF=0，没有错误，AH=0</p><p>FLAGS.CF=1，有错误，错误号码存入AH内(与重置功能一样)</p></blockquote><p><strong>问题1，调用函数之前AX，CL的值代表什么，怎么来的？</strong></p><p>AX代表的是待读取的磁盘起始扇区号，CL代表的是读入的扇区数量，都来自另一段程序，下面会继续解释</p><p><strong>问题2，为什么要这么计算？</strong></p><p>因为磁盘扇区号是LBA(Logical Block Address，逻辑块寻址)格式的，而<code>INT 13h, AH=02h</code>中断服务程序只能受理CHS(Cylinder/Header/Sector，柱面/磁头/扇区)格式的磁盘扇区号，所以需要通过下面的公式将LBA格式转为CHS格式<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.506ex;" xmlns="http://www.w3.org/2000/svg" width="63.275ex" height="8.143ex" role="img" focusable="false" viewBox="0 -2049.5 27967.7 3599"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(681,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(1440,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(2190,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">扇</text></g><g data-mml-node="mi" transform="translate(3190,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">区</text></g><g data-mml-node="mi" transform="translate(4190,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">号</text></g><g data-mml-node="mo" transform="translate(5412.2,0)"><path data-c="F7" d="M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z"></path></g><g data-mml-node="mi" transform="translate(6412.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">每</text></g><g data-mml-node="mi" transform="translate(7412.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">磁</text></g><g data-mml-node="mi" transform="translate(8412.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">道</text></g><g data-mml-node="mi" transform="translate(9412.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">扇</text></g><g data-mml-node="mi" transform="translate(10412.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">区</text></g><g data-mml-node="mi" transform="translate(11412.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mo" transform="translate(12690.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mrow" transform="translate(13746,0)"><g data-mml-node="mo"><path data-c="23A7" d="M712 899L718 893V876V865Q718 854 704 846Q627 793 577 710T510 525Q510 524 509 521Q505 493 504 349Q504 345 504 334Q504 277 504 240Q504 -2 503 -4Q502 -8 494 -9T444 -10Q392 -10 390 -9Q387 -8 386 -5Q384 5 384 230Q384 262 384 312T383 382Q383 481 392 535T434 656Q510 806 664 892L677 899H712Z" transform="translate(0,1150.5)"></path><path data-c="23A9" d="M718 -893L712 -899H677L666 -893Q542 -825 468 -714T385 -476Q384 -466 384 -282Q384 3 385 5L389 9Q392 10 444 10Q486 10 494 9T503 4Q504 2 504 -239V-310V-366Q504 -470 508 -513T530 -609Q546 -657 569 -698T617 -767T661 -812T699 -843T717 -856T718 -876V-893Z" transform="translate(0,-650.5)"></path><path data-c="23A8" d="M389 1159Q391 1160 455 1160Q496 1160 498 1159Q501 1158 502 1155Q504 1145 504 924Q504 691 503 682Q494 549 425 439T243 259L229 250L243 241Q349 175 421 66T503 -182Q504 -191 504 -424Q504 -600 504 -629T499 -659H498Q496 -660 444 -660T390 -659Q387 -658 386 -655Q384 -645 384 -425V-282Q384 -176 377 -116T342 10Q325 54 301 92T255 155T214 196T183 222T171 232Q170 233 170 250T171 268Q171 269 191 284T240 331T300 407T354 524T383 679Q384 691 384 925Q384 1152 385 1155L389 1159Z" transform="translate(0,0)"></path><svg width="889" height="180.5" y="1060" x="0" viewBox="0 31.8 889 180.5"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,0.888)"></path></svg><svg width="889" height="180.5" y="-740.5" x="0" viewBox="0 31.8 889 180.5"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,0.888)"></path></svg></g><g data-mml-node="mtable" transform="translate(889,0)"><g data-mml-node="mtr" transform="translate(0,600)"><g data-mml-node="mtd"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">商</text></g><g data-mml-node="mi" transform="translate(1000,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mo" transform="translate(2068.8,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mrow" transform="translate(3346.6,0)"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7B" d="M618 -943L612 -949H582L568 -943Q472 -903 411 -841T332 -703Q327 -682 327 -653T325 -350Q324 -28 323 -18Q317 24 301 61T264 124T221 171T179 205T147 225T132 234Q130 238 130 250Q130 255 130 258T131 264T132 267T134 269T139 272T144 275Q207 308 256 367Q310 436 323 519Q324 529 325 851Q326 1124 326 1154T332 1205Q369 1358 566 1443L582 1450H612L618 1444V1429Q618 1413 616 1411L608 1406Q599 1402 585 1393T552 1372T515 1343T479 1305T449 1257T429 1200Q425 1180 425 1152T423 851Q422 579 422 549T416 498Q407 459 388 424T346 364T297 318T250 284T214 264T197 254L188 251L205 242Q290 200 345 138T416 3Q421 -18 421 -48T423 -349Q423 -397 423 -472Q424 -677 428 -694Q429 -697 429 -699Q434 -722 443 -743T465 -782T491 -816T519 -845T548 -868T574 -886T595 -899T610 -908L616 -910Q618 -912 618 -928V-943Z"></path></g><g data-mml-node="mtable" transform="translate(750,0)"><g data-mml-node="mtr" transform="translate(0,600)"><g data-mml-node="mtd"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">柱</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">面</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">号</text></g><g data-mml-node="mo" transform="translate(3277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(4333.6,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mo" transform="translate(5402.3,0)"><g data-mml-node="text"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="text" transform="translate(778,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g></g><g data-mml-node="mn" transform="translate(7236.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mtr" transform="translate(0,-600)"><g data-mml-node="mtd"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">磁</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">头</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">号</text></g><g data-mml-node="mo" transform="translate(3277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(4333.6,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g><g data-mml-node="mtd" transform="translate(8736.1,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(9986.1,0) translate(0 250)"></g></g></g></g><g data-mml-node="mtr" transform="translate(0,-1299.5)"><g data-mml-node="mtd"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">余</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(2000,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(3036.8,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(4314.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">起</text></g><g data-mml-node="mi" transform="translate(5314.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">始</text></g><g data-mml-node="mi" transform="translate(6314.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">扇</text></g><g data-mml-node="mi" transform="translate(7314.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">区</text></g><g data-mml-node="mi" transform="translate(8314.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">号</text></g><g data-mml-node="mo" transform="translate(9592.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(10648.1,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(11629.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(12629.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(14221.7,0) translate(0 250)"></g></g></g></g></svg></mjx-container><br><strong>问题3，返回值FLAGS.CF代表啥？</strong></p><p>表示进位标识符，jc指令与之搭配使用，当carry flag值为1时就会跳转。如果调用这个函数出错CF就会置为1。这里就是如果出错就一直读，个人觉得没有《32位》处理得好，读错了就尝试5次</p><p><strong>问题4，<code>ES:BX</code>代表什么？</strong></p><p>这个表示内存地址，表明把从软盘上读出的数据装载到内存的哪个位置。如果用一个寄存器BX来表示内存地址的话，只能表示0~0xffff的值，最大才64K，现在谁家内存条这么小？当然了，你可能会现在不是有ebx或者rbx麽，用这个当然没问题，但问题是设计BIOS的时代没有啊，所以设计了起辅助作用的段寄存器，在指定内存地址时，可以用这个段寄存器。所以使用段及寄存器时，以<code>ES:BX</code>这种方式来表示<code>ES * 16 + BX</code>的内存地址地址，这样就可以指定1M以内的内存地址，这在当时就满足要求了，当然现在为了兼容也要遵守这一规则</p><h2 id="2-6-FAT表项解析模块"><a href="#2-6-FAT表项解析模块" class="headerlink" title="2.6 FAT表项解析模块"></a>2.6 FAT表项解析模块</h2><p>如果从扇区中找到了loader.bin，那就根据FAT表提供的簇号顺序依次加载到扇区数据到内存中，这个加载过程会涉及FAT表项的解析工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;=======    get FAT Entry</span><br><span class="line">Func_GetFATEntry:</span><br><span class="line">    push es</span><br><span class="line">    push bx</span><br><span class="line">    push ax  ; 常规的保护操作</span><br><span class="line">    mov ax, 00</span><br><span class="line">    mov es, ax  ; 这里将es置为00，因为外面的es是0x1000</span><br><span class="line">    pop ax  ; 这里的ax就是FAT表项</span><br><span class="line">    mov byte [Odd], 0  ; 标志位Odd置0</span><br><span class="line">    mov bx, 3  ; bx=3</span><br><span class="line">    mul bx  ; ax = ax * bx(3)</span><br><span class="line">    mov bx, 2  ; bx=2</span><br><span class="line">    div bx  ; ax/bx(2)=ax...dx，ax=ax*3/2扩大1.5倍得到该FAT表项占用的字节数</span><br><span class="line">    cmp dx, 0  ; ax是否为偶数，是偶数直接去Label_Even，Odd=0</span><br><span class="line">    jz  Label_Even</span><br><span class="line">    mov byte [Odd], 1  ; 不是的话 先将标志位Odd置为1</span><br><span class="line"></span><br><span class="line">Label_Even:</span><br><span class="line">    xor dx, dx  ; 将dx置0</span><br><span class="line">    mov bx, [BPB_BytesPerSec]  ; bx=512</span><br><span class="line">    div bx  ; ax/512=ax(FAT表中的偏移扇区号)...dx(在扇区中的位置)</span><br><span class="line">    push dx</span><br><span class="line">    mov bx, 8000h  ; es:bx=读取内容存放的缓冲区位置</span><br><span class="line">    add ax, SectorNumOfFAT1Start  ; ax=ax+1 得到该FAT表项的起始扇区号</span><br><span class="line">    mov cl, 2  ; 读取FAT表项所在的扇区，一次读两个，避免在边界发生错误，因为一个FAT表项可能跨越两个扇区</span><br><span class="line">    call Func_ReadOneSector</span><br><span class="line"></span><br><span class="line">    pop dx</span><br><span class="line">    add bx, dx  ; bx=bx+dx 缓冲区起始地址+要读的内容长度(在扇区中的位置)</span><br><span class="line">    mov ax, [es:bx]  ; 读出FAT表项内容到ax中</span><br><span class="line">    cmp byte [Odd], 1  ; 是不是奇数</span><br><span class="line">    jnz Label_Even_2  ; Odd != 1跳到Label_Even_2</span><br><span class="line">    shr ax, 4  ; ax右移四位 也就是0.5B 把属于前一个表项的部分移除掉</span><br><span class="line"></span><br><span class="line">Label_Even_2:</span><br><span class="line">    and ax, 0fffh  ; 只保留低12bit，也就是截取该FAT表项</span><br><span class="line">    pop bx</span><br><span class="line">    pop es</span><br><span class="line">    ret  ; 函数调用结束 返回调用位置 返回值AX=要找的FAT表项值</span><br></pre></td></tr></table></figure><p><strong>1 这里AX代表什么？</strong></p><p>作为参数的时候是当前FAT表项索引，作为返回值的时候是下一个表项号</p><p><strong>2 为啥要把ax放大1.5倍？</strong></p><p>因为FAT12文件系统的每个FAT表项占用12bit，即每3B存两个FAT表项，所以需要先根据表项号转化成占用字节数，通过字节数除以每扇区字节数可以得到偏移的扇区号，以及FAT表项在该扇区中的偏移位置，再根据这个扇区号往后面读取两个扇区，根据奇偶位处理表项错位问题，这样就能得到下一扇区的表项号。</p><h2 id="2-7-Other"><a href="#2-7-Other" class="headerlink" title="2.7 Other"></a>2.7 Other</h2><p>这就是一些定义一些变量常量什么的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;=======    tmp variable</span><br><span class="line">RootDirSizeForLoop  dw  RootDirSectors</span><br><span class="line">SectorNo        dw  0</span><br><span class="line">Odd         db  0</span><br><span class="line"></span><br><span class="line">;=======    display messages</span><br><span class="line">StartBootMessage:   db  "Start Boot"</span><br><span class="line">NoLoaderMessage:    db  "ERROR:No LOADER Found"</span><br><span class="line">LoaderFileName:     db  "LOADER  BIN",0</span><br><span class="line"></span><br><span class="line">;=======    fill zero until whole sector</span><br><span class="line">    times   510 - ($ - $$)  db  0</span><br><span class="line">    dw  0xaa55</span><br></pre></td></tr></table></figure><p>NASM编译器中的单引号和双引号作用相同，并非C语言规定的双引号会在结尾添加字符<code>'\0'</code>，在NASM中必须自行添加</p><p>好了都解释完了，编译一下，并在qemu上跑一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm boot.asm -o boot.bin -l boot.lst</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br><span class="line">qemu-system-x86_64 -drive file=boot.img,format=raw,<span class="keyword">if</span>=floppy</span><br></pre></td></tr></table></figure><p>启动效果是这个死样子</p><p><img data-src="/assets/03_Make-MyOS-Find-loader/202110312044018.png" alt="202110312044018"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;说是第三天，我看了该一个星期了..发现之前看得有点浮躁，最近看了费曼读书法有了新的想法，不怕慢，就怕没看明白，所以听费曼的，每次看卡壳了，就返回去重新看..&lt;/p&gt;
&lt;p&gt;看到这里，突然觉得还是以《64位》为主比较好，《32位》太老了，用的还是nask转换起来有点累，并且《64位》介绍得细啊，所以我悟了，《32位》用来打辅助吧..&lt;/p&gt;
&lt;h1 id=&quot;1-软盘与FAT12&quot;&gt;&lt;a href=&quot;#1-软盘与FAT12&quot; class=&quot;headerlink&quot; title=&quot;1 软盘与FAT12&quot;&gt;&lt;/a&gt;1 软盘与FAT12&lt;/h1&gt;&lt;p&gt;先来看软盘，一个PC里面可以有多个软盘，一个软盘里面包含2个磁头，80个柱面，18个扇区。因为软盘正反面都可以存储数据，所以有俩磁头去读取数据。柱面参考下图(注意编号0~79)，英文是cylinder；扇区参考下图(注意编号1~18)，英文是sector&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Make OS" scheme="https://sidneyding.cn/categories/OS/Make-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>[Make MyOS] Make a boot</title>
    <link href="https://sidneyding.cn/posts/c0d78c8f/"/>
    <id>https://sidneyding.cn/posts/c0d78c8f/</id>
    <published>2021-09-05T14:48:41.000Z</published>
    <updated>2023-08-13T02:36:19.892Z</updated>
    
    <content type="html"><![CDATA[<p>第二天的内容本该是，学习一些汇编指令和Makefile，在这之前我觉得有必要好好看看CPU结构，自古操作系统和组成原理就分不开啊</p><p>面向总线的计算机组成示意图。中央处理器，从主存储器中逐条进行取指令，分析指令和执行指令。计算机各组件通过总线连在一起，总线是一些平行导线的集合，用来传递地址，数据和控制信号，可以在CPU之外连接CPU，存储器及IO设备；也可以在CPU内部连接CPU的各个组成部分。</p><span id="more"></span><p><img data-src="/assets/02_Make-MyOS-Make-a-boot/20210905095358.png" alt="面向总线的计算机组成"></p><h1 id="1-CPU简介"><a href="#1-CPU简介" class="headerlink" title="1 CPU简介"></a>1 CPU简介</h1><p>控制单元：控制各个子系统的操作，控制是通过从控制单元发送到其他子系统的信号来进行</p><p>算术逻辑单元：对数据进行算数，逻辑和移位运算</p><p>寄存器：用来临时存放数据的高速独立的存储单元</p><p>1 数据寄存器</p><p>数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。命名为R1到Rn</p><p>2 指令寄存器</p><p>CPU从内存中取出指令，存在指令寄存器中(IR)，解释并执行指令</p><p>3 程序计数器</p><p>保存着当前正在执行的指令，当前指令执行完成后，计数器将自动加1，指向下一条指令的内存地址</p><p><strong>通用32位CPU常用寄存器及其作用</strong></p><ul><li>4个数据寄存器(EAX、EBX、ECX和EDX)</li><li>2个变址和指针寄存器(ESI和EDI)</li><li>2个指针寄存器(ESP和EBP)</li><li>6个段寄存器(ES、CS、SS、DS、FS和GS)</li><li>1个指令指针寄存器(EIP)</li><li>1个标志寄存器(EFlags)</li></ul><table><thead>  <tr>    <th>31~16</th>    <th>15~8</th>    <th>7~0</th>  </tr></thead><tbody>  <tr>    <td></td>    <td>AH</td>    <td>AL</td>  </tr>  <tr>    <td></td>    <td>BH</td>    <td>BL</td>  </tr>  <tr>    <td></td>    <td>CH</td>    <td>CL</td>  </tr>  <tr>    <td></td>    <td>DH</td>    <td>DL</td>  </tr>  <tr>    <td></td>    <td colspan="2">BP</td>  </tr>  <tr>    <td></td>    <td colspan="2">SP</td>  </tr>  <tr>    <td></td>    <td colspan="2">SI</td>  </tr>  <tr>    <td></td>    <td colspan="2">DI</td>  </tr></tbody></table><p>32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字&#x2F;字节的信息。</p><p>寄存器AX称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、除、输入&#x2F;输出等操作，它们的使用频率很高；</p><p>寄存器BX称为基地址寄存器(BaseRegister)。它可作为存储器指针来使用；</p><p>寄存器CX称为计数寄存器(CountRegister)。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；</p><p>寄存器DX称为数据寄存器(DataRegister)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I&#x2F;O的端口地址。</p><p>32位CPU有2个32位通用寄存器EBP和ESP。其低16位对应先前CPU中的BP和SP，对低16位数据的存取，不影响高16位的数据。BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。</p><p>32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI(源变址寄存器，suorce index)和DI(目的变址寄存器，destination index)，对低16位数据的存取，不影响高16位的数据。它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。</p><p><strong>段寄存器</strong>是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p><p>CS——代码段寄存器(CodeSegmentRegister)，其值为代码段的段值；</p><p>DS——数据段寄存器(DataSegmentRegister)，其值为数据段的段值；</p><p>ES——附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值；</p><p>SS——堆栈段寄存器(StackSegmentRegister)，其值为堆栈段的段值；</p><p>FS——附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值；</p><p>GS——附加段寄存器(ExtraSegmentRegister)，其值为附加数据段的段值。</p><p>在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。</p><p>32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。指令指针EIP、IP(InstructionPointer)是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。</p><p><strong>标志寄存器(EFlags register)</strong></p><p><img data-src="/assets/02_Make-MyOS-Make-a-boot/20210905200924.png" alt="20210905200924"></p><p>进位标志CF(CarryFlag)主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。</p><p>奇偶标志PF(ParityFlag)用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。</p><p>辅助进位标志AF(AuxiliaryCarryFlag)。在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0：在字操作时，发生低字节向高字节进位或借位时；在字节操作时，发生低4位向高4位进位或借位时。</p><p>零标志ZF(ZeroFlag)用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。</p><p>符号标志SF(SignFlag)用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。</p><p>溢出标志OF(OverflowFlag)用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</p><p><strong>64&#x2F;128位寄存器图</strong></p><p><img data-src="/assets/02_Make-MyOS-Make-a-boot/20210905201223.jpg" alt="20210905201223"></p><p>一般寄存器了解完了还得去了解寻址方式，这里就大致了解一下得了..</p><p>立即寻址(直接操作立即数，即常数)，直接寻址(通过内存地址获得立即数)，寄存器寻址(通过寄存器获得立即数)，寄存器间接寻址(通过寄存器中内存地址获取立即数)，变址寻址(通过寄存器中内存地址加上一个偏移量得到新的内存地址获取立即数)，基址变址寻址(通过俩寄存器存的内存地址，一个是基址，另一个是变址，再加上一个偏移量得到内存地址获取立即数)</p><blockquote><p>冯诺依曼结构：</p><p>1 计算机主要由运算器，控制器，存储器，I&#x2F;O设备等五大部件组成；</p><p>2 各部件的作用是</p><p>2.1 存储器存放数据和指令，两者表现形式上没有什么区别，但是计算机应能区分是数据还是指令；</p><p>2.2 控制器应能自动取出指令来执行；</p><p>2.3 运算器应能进行加减乘除基本算数运算，并且也能进行一些逻辑运算和附加运算(移位运算)；</p><p>2.4 操作人员可以通过IO设备与计算机交互</p></blockquote><h1 id="2-新的指令"><a href="#2-新的指令" class="headerlink" title="2 新的指令"></a>2 新的指令</h1><p>这个时候再来看新一天的代码就会比较清晰了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">; hello-os</span><br><span class="line">; TAB=4</span><br><span class="line">        ORG     0x7c00          ; 指明程序的装载地址</span><br><span class="line">; 下面的代码用于描述标准FAT12格式的软盘</span><br><span class="line">        JMP     entry</span><br><span class="line">        DB      0x90</span><br><span class="line">; 略... </span><br><span class="line">entry:</span><br><span class="line">        MOV     AX,0            ; 初始化寄存器</span><br><span class="line">        MOV     SS,AX</span><br><span class="line">        MOV     SP,0x7c00</span><br><span class="line">        MOV     DS,AX</span><br><span class="line">        MOV     ES,AX</span><br><span class="line">        MOV     SI,msg          ; 将标号msg的地址存入SI中</span><br><span class="line">putloop:</span><br><span class="line">        MOV     AL,[SI]</span><br><span class="line">        ADD     SI,1            ; 给SI加1</span><br><span class="line">        CMP     AL,0</span><br><span class="line">        JE      fin</span><br><span class="line">        MOV     AH,0x0e         ; 显示一个文字</span><br><span class="line">        MOV     BX,15           ; 指定字符颜色</span><br><span class="line">        INT     0x10            ; 调用显卡BIOS</span><br><span class="line">        JMP     putloop</span><br><span class="line">fin:</span><br><span class="line">        HLT                     ; 让CPU停止，等待指令</span><br><span class="line">        JMP     fin             ; 无限循环</span><br><span class="line"></span><br><span class="line">msg:</span><br><span class="line">        DB      0x0a, 0x0a      ; 换行两次</span><br><span class="line">        DB      &quot;hello, world&quot;</span><br><span class="line">        DB      0x0a            ; 换行</span><br><span class="line">        DB      0</span><br><span class="line">; 略...</span><br></pre></td></tr></table></figure><p><strong>ORG</strong>: 即origin，在开始执行的时候告诉nask，程序要从指定的地址开始，也就是要把程序装载到内存中的指定地址（启动区内容的装载地址：0x7c00-0x7dff）</p><p><strong>JMP</strong>：即jump，跳转指令；</p><p>**entry:**：标签的声明，用于指定JMP指令的跳转目的地（入口）；</p><p><strong>MOV</strong>：即move，赋值指令。</p><p><strong>ADD</strong>：加法指令<br><strong>CMP</strong>：即compare，比较指令<br><strong>JE</strong>：即jump if equal，条件跳转指令之一，如果比较结果相等，则跳转到指定的地址；而如果比较结果不等，则不跳转，继续执行下一条指令<br><strong>fin</strong>：是个标号，表示结束（finish）的意思。<br><strong>INT</strong>：软件中断指令（interrupt），用来调用BIOS中的函数指令。暂时当作是函数调用来理解<br><strong>HLT</strong>：即halt，让CPU停止动作的指令，但并非彻底停止，而是进入待机状态。如果无HLT指令，CPU会在JMP fin无限循环，所以不写HLT指令也可以，但这样会使CPU无意义的空转，CPU负荷过大，耗费电能，所以加上HLT指令后使CPU处于休眠状态，降低能耗。</p><h1 id="3-BIOS中断向量表"><a href="#3-BIOS中断向量表" class="headerlink" title="3 BIOS中断向量表"></a>3 BIOS中断向量表</h1><p>对于这些本就定义好的东西，记录下来就好，这玩意还是啥时候用啥时候百度的好..</p><table><thead><tr><th>中断</th><th>描述</th></tr></thead><tbody><tr><td>INT 00h</td><td>CPU: 除零错,或商不合法时触发</td></tr><tr><td>INT 01h</td><td>CPU: 单步陷阱,TF标记为打开状态时,每条指令执行后触发</td></tr><tr><td>INT 02h</td><td>CPU: 非可屏蔽中断, 如 开机自我测试 时发生内存错误触发。</td></tr><tr><td>INT 03h</td><td>CPU: 第一个未定义的中断向量, 约定俗成仅用于调试程序</td></tr><tr><td>INT 04h</td><td>CPU: 算数溢出。通常由INTO指令在置溢出位时触发。</td></tr><tr><td>INT 05h</td><td>在按下Shift-Print Screen或BOUND指令检测到范围异常时触发。</td></tr><tr><td>INT 06h</td><td>CPU: 非法指令。</td></tr><tr><td>INT 07h</td><td>CPU: 没有数学协处理器时尝试执行浮点指令触发。</td></tr><tr><td>INT 08h</td><td>IRQ0: 可编程中断控制器每 55 毫秒触发一次，即每秒 18.2 次。</td></tr><tr><td>INT 09h</td><td>IRQ1: 每次键盘按下、按住、释放。</td></tr><tr><td>INT 0Ah</td><td>IRQ2:</td></tr><tr><td>INT 0Bh</td><td>IRQ3: COM2&#x2F;COM4。</td></tr><tr><td>INT 0Ch</td><td>IRQ4: COM1&#x2F;COM3。</td></tr><tr><td>INT 0Dh</td><td>IRQ5: 硬盘控制器（PC&#x2F;XT 下）或 LPT2。</td></tr><tr><td>INT 0Eh</td><td>IRQ6: 需要时由软碟控制器呼叫。</td></tr><tr><td>INT 0Fh</td><td>IRQ7: LPT1。</td></tr><tr><td>INT 10h</td><td>显示服务 - 由BIOS或操作系统设定以供软件调用。<br/>AH&#x3D;00h设定显示模式<br/>AH&#x3D;01h设定游标形态<br/>AH&#x3D;02h设定游标位置<br/>AH&#x3D;03h获取游标位置与形态<br/>AH&#x3D;04h获取光笔位置<br/>AH&#x3D;05h设定显示页<br/>AH&#x3D;06h清除或卷轴画面(上)<br/>AH&#x3D;07h清除或卷轴画面(下)<br/>AH&#x3D;08h读取游标处字符与属性<br/>AH&#x3D;09h更改游标处字符与属性<br/>AH&#x3D;0Ah更改游标处字符<br/>AH&#x3D;0Bh设定边界颜色<br/>AH&#x3D;0Eh在TTY模式下写字符<br/>AH&#x3D;0Fh取得目前显示模式<br/>AH&#x3D;13h写字符串</td></tr><tr><td>INT 11h</td><td>返回设备列表。</td></tr><tr><td>INT 12h</td><td>获取常规内存容量。</td></tr><tr><td>INT 13h</td><td>低阶磁盘服务。<br/>AH&#x3D;00h复位磁盘驱动器。<br/>AH&#x3D;01h检查磁盘驱动器状态。<br/>AH&#x3D;02h读扇区。<br/>AH&#x3D;03h写扇区。<br/>AH&#x3D;04h校验扇区。<br/>AH&#x3D;05h格式化磁道。<br/>AH&#x3D;08h取得驱动器参数。<br/>AH&#x3D;09h初始化硬盘驱动器参数。<br/>AH&#x3D;0Ch寻道。<br/>AH&#x3D;0Dh复位硬盘控制器。<br/>AH&#x3D;15h取得驱动器类型。<br/>AH&#x3D;16h取得软驱中盘片的状态。</td></tr><tr><td>INT 14h</td><td>串口通信例程。AH&#x3D;00h初始化串口。AH&#x3D;01h写出字符。AH&#x3D;02h读入字符。AH&#x3D;03h状态。</td></tr><tr><td>INT 15h</td><td>其它（系统支持例程）。<br/>AH&#x3D;4FH键盘拦截。<br/>AH&#x3D;83H事件等待。<br/>AH&#x3D;84H读游戏杆。<br/>AH&#x3D;85HSysRq 键。<br/>AH&#x3D;86H等待。<br/>AH&#x3D;87H块移动。<br/>AH&#x3D;88H获取扩展内存容量。<br/>AH&#x3D;C0H获取系统参数。<br/>AH&#x3D;C1H获取扩展BIOS 数据区段。<br/>AH&#x3D;C2H指针设备功能。<br/>AH&#x3D;E8h, AL&#x3D;01h (AX &#x3D; E801h)获取扩展内存容量（自从 1944 年引入的新功能），可获取到 64MB 以上的内存容量。<br/>AH&#x3D;E8h, AL&#x3D;20h (AX &#x3D; E820h)查询系统地址映射。该功能取代了 AX&#x3D;E801h 和 AH&#x3D;88h。</td></tr><tr><td>INT 16h</td><td>键盘通信例程。<br/>AH&#x3D;00h读字符。<br/>AH&#x3D;01h读输入状态。<br/>AH&#x3D;02h读 Shift 键（修改键）状态。<br/>AH&#x3D;10h读字符（增强版）。<br/>AH&#x3D;11h读输入状态（增强版）。<br/>AH&#x3D;12h读 Shift 键（修改键）状态（增强版）。</td></tr><tr><td>INT 17h</td><td>打印服务。<br/>AH&#x3D;00h打印字符。<br/>AH&#x3D;01h初始化打印机。<br/>AH&#x3D;02h检查打印机状态。</td></tr><tr><td>INT 18h</td><td>执行磁带上的 BASIC 程序：“真正的”IBM 兼容机在 ROM 里内置 BASIC 程序，当引导失败时由 BIOS 调用此例程解释执行。（例：打印“Boot disk error. Replace disk and press any key to continue…”这类提示信息）</td></tr><tr><td>INT 19h</td><td>加电自检之后载入操作系统。</td></tr><tr><td>INT 1Ah</td><td>实时钟服务。<br/>AH&#x3D;00h读取实时钟。<br/>AH&#x3D;01h设置实时钟。<br/>AH&#x3D;02h读取实时钟时间。<br/>AH&#x3D;03h设置实时钟时间。<br/>AH&#x3D;04h读取实时钟日期。<br/>AH&#x3D;05h设置实时钟日期。<br/>AH&#x3D;06h设置实时钟闹铃。<br/>AH&#x3D;07h重置实时钟闹铃。</td></tr><tr><td>INT 1Bh</td><td>Ctrl+Break，由 IRQ 9 自动调用。</td></tr><tr><td>INT 1Ch</td><td>预留，由 IRQ 8 自动调用。</td></tr><tr><td>INT 1Dh</td><td>不可调用：指向视频参数表（包含视频模式的数据）的指针。</td></tr><tr><td>INT 1Eh</td><td>不可调用：指向软盘模式表（包含关于软驱的大量信息）的指针。</td></tr><tr><td>INT 1Fh</td><td>不可调用：指向视频图形字符表（包含从 80h 到 FFh 的 ASCII 字符的数据）的信息。</td></tr><tr><td>INT 41h</td><td>地址指针：硬盘参数表（第一硬盘）。</td></tr><tr><td>INT 46h</td><td>地址指针：硬盘参数表（第二硬盘）。</td></tr><tr><td>INT 4Ah</td><td>实时钟在闹铃时调用。</td></tr><tr><td>INT 70h</td><td>IRQ8: 由实时钟调用。</td></tr><tr><td>INT 74h</td><td>IRQ12: 由鼠标调用</td></tr><tr><td>INT 75h</td><td>IRQ13: 由数学协处理器调用。</td></tr><tr><td>INT 76h</td><td>IRQ14: 由第一个 IDE 控制器所呼叫</td></tr><tr><td>INT 77h</td><td>IRQ15: 由第二个 IDE 控制器所呼叫</td></tr></tbody></table><h1 id="4-制作boot"><a href="#4-制作boot" class="headerlink" title="4 制作boot"></a>4 制作boot</h1><p>因为启动区只需要前512字节，所以只留下前面操作512字节的代码就好了，并将文件名改为<code>ipl.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">; hello-o</span><br><span class="line">; TAB=4</span><br><span class="line">        ORG     0x7c00</span><br><span class="line">        JMP     entry</span><br><span class="line">        DB      0x90</span><br><span class="line">        DB      &quot;HELLOIPL&quot;</span><br><span class="line">        DW      512</span><br><span class="line">        DB      1</span><br><span class="line">        DW      1</span><br><span class="line">        DB      2</span><br><span class="line">        DW      224</span><br><span class="line">        DW      2880</span><br><span class="line">        DB      0xf0</span><br><span class="line">        DW      9</span><br><span class="line">        DW      18</span><br><span class="line">        DW      2</span><br><span class="line">        DD      0</span><br><span class="line">        DD      2880</span><br><span class="line">        DB      0,0,0x29</span><br><span class="line">        DD      0xffffffff</span><br><span class="line">        DB      &quot;HELLO-OS   &quot;</span><br><span class="line">        DB      &quot;FAT12   &quot;</span><br><span class="line">        TIMES  18  DB 0</span><br><span class="line">entry:</span><br><span class="line">        MOV     AX,0</span><br><span class="line">        MOV     SS,AX</span><br><span class="line">        MOV     DS,AX</span><br><span class="line">        MOV     ES,AX</span><br><span class="line">        MOV     SP,0x7c00</span><br><span class="line">        MOV     SI,msg</span><br><span class="line">putloop:</span><br><span class="line">        MOV     AL,[SI]</span><br><span class="line">        ADD     SI,1</span><br><span class="line">        CMP     AL,0</span><br><span class="line">        JE      fin</span><br><span class="line">        MOV     AH,0x0e</span><br><span class="line">        MOV     BX,15</span><br><span class="line">        INT     0x10</span><br><span class="line">        JMP     putloop</span><br><span class="line">fin:</span><br><span class="line">        HLT</span><br><span class="line">        JMP     fin</span><br><span class="line">msg:</span><br><span class="line">        DB      0x0a, 0x0a</span><br><span class="line">        DB      &quot;hello, world&quot;</span><br><span class="line">        DB      0x0a</span><br><span class="line">        DB      0</span><br><span class="line">        TIMES  0x1fe-($-$$)  DB 0</span><br><span class="line">        DB      0x55, 0xaa</span><br></pre></td></tr></table></figure><p>执行命令<code>nasm ipl.asm -o ipl.bin -l ipl.lst</code>得到，其中bin文件只是将后缀名字改了，而lst文件是一个文本文件，记录着如何将指令翻译成机器语言的。然后书上说用作者写的工具<code>edimg.exe</code>制作img文件，在Linux显然没法弄了。但是咧，可以用<code>dd if=ipl.bin of=myos.img bs=512 count=1 conv=notrunc</code>，就弄好了，然后依然是执行<code>qemu-system-i386 -drive file=myos.img,format=raw,if=floppy</code>，还好，能跑起来..也就是说，不要后面那段0也是可以跑起来的，虽然不知道会不会有什么隐患..</p><p>扯完了这个，再看另一本书《一个64位操作系统的设计与实现》的boot程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">org0x7c00          ; 开始的位置是一样的</span><br><span class="line">BaseOfStackequ0x7c00    ; equ是伪指令，可以理解位 BaseOfStack = 0x7c00</span><br><span class="line">Label_Start:</span><br><span class="line">movax,cs            ; cs=0 所以和entry那块是一样的，ax,ds,es,ss置为0</span><br><span class="line">movds,ax</span><br><span class="line">moves,ax</span><br><span class="line">movss,ax</span><br><span class="line">movsp,BaseOfStack   ; 和 MOV SP,0x7c00是一个道理</span><br><span class="line">;=======clear screen</span><br><span class="line">movax,0600h         ; 即AH=06h清除或卷轴画面(上)</span><br><span class="line">movbx,0700h         ; 滚动后屏幕放入的属性 00000111，白色，bit0~2，颜色；bit3，亮度；bit4~6，背景颜色；bit7，闪烁</span><br><span class="line">movcx,0             ; 滚动范围的左上角行列号</span><br><span class="line">movdx,0184fh        ; 滚动范围的右上角行列号</span><br><span class="line">int10h</span><br><span class="line">;=======set focus</span><br><span class="line">movax,0200h         ; 设定光标位置 (0,0)</span><br><span class="line">movbx,0000h         ; 设定游标行数</span><br><span class="line">movdx,0000h         ; 列数</span><br><span class="line">int10h</span><br><span class="line">;=======display on screen : Start Booting......</span><br><span class="line">movax,1301h         ; AH=13打印字符串  AL=01 光标位置会放到字符串后面</span><br><span class="line">movbx,000fh         ; BH代表页码  BL表示字符属性参考AH=06</span><br><span class="line">movdx,0000h         ; 游标行列号</span><br><span class="line">movcx,10            ; 字符串长度</span><br><span class="line">pushax            ; 真的就是入栈？？？</span><br><span class="line">movax,ds</span><br><span class="line">moves,ax</span><br><span class="line">popax</span><br><span class="line">movbp,StartBootMessage  ; 放入字符串咯</span><br><span class="line">int10h</span><br><span class="line">;=======reset floppy</span><br><span class="line">xorah,ah</span><br><span class="line">xordl,dl</span><br><span class="line">int13h              ; 重置磁盘</span><br><span class="line">jmp$</span><br><span class="line">StartBootMessage:db&quot;Start Boot&quot;</span><br><span class="line">times510 - ($ - $$)db0</span><br><span class="line">dw0xaa55</span><br></pre></td></tr></table></figure><p>除了没有FAT12那个描述，其它基本上都是差不多的..这段程序通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm my64.asm -o my64.bin -l my64.lst</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=my64.bin of=my64.img bs=512 count=1 conv=notrunc</span><br><span class="line">qemu-system-i386 -drive file=my64.img,format=raw,<span class="keyword">if</span>=floppy</span><br></pre></td></tr></table></figure><p>也跑起来了..</p><h1 id="5-Makefile"><a href="#5-Makefile" class="headerlink" title="5 Makefile"></a>5 Makefile</h1><p>接下来是Makefile的一些介绍，推荐看经典啊</p><p><a href="https://seisman.github.io/how-to-write-makefile/introduction.html">makefile介绍 — 跟我一起写Makefile 1.0 文档</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第二天的内容本该是，学习一些汇编指令和Makefile，在这之前我觉得有必要好好看看CPU结构，自古操作系统和组成原理就分不开啊&lt;/p&gt;
&lt;p&gt;面向总线的计算机组成示意图。中央处理器，从主存储器中逐条进行取指令，分析指令和执行指令。计算机各组件通过总线连在一起，总线是一些平行导线的集合，用来传递地址，数据和控制信号，可以在CPU之外连接CPU，存储器及IO设备；也可以在CPU内部连接CPU的各个组成部分。&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Make OS" scheme="https://sidneyding.cn/categories/OS/Make-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>[Make MyOS] Hello MyOS!</title>
    <link href="https://sidneyding.cn/posts/307d30a/"/>
    <id>https://sidneyding.cn/posts/307d30a/</id>
    <published>2021-08-21T13:20:47.000Z</published>
    <updated>2022-07-03T09:09:39.492Z</updated>
    
    <content type="html"><![CDATA[<p>这是30天的第一天内容，也不知道自己能坚持到几天，有几天就几天了，活这么久了，半途而废的事情还少吗？</p><p>首先需要准备几个工具</p><h1 id="1-qemu"><a href="#1-qemu" class="headerlink" title="1 qemu"></a>1 qemu</h1><p>不可能真去买个软盘什么的，所以我们需要一个虚拟计算机的东西——QEMU</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># qemu编译可能要用到的东西</span></span><br><span class="line">sudo apt-get install ninja-build pkg-config build-essential zlib1g-dev \</span><br><span class="line">  libglib2.0-dev binutils-dev libboost-all-dev autoconf libtool libssl-dev \</span><br><span class="line">  libpixman-1-dev libpython-dev python-pip python-capstone virtualenv</span><br><span class="line"><span class="comment"># qemu显示要的东西 没有这个只能通过VNC去看了</span></span><br><span class="line">sudo apt install libsdl2-dev -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载qemu源码 其实安装qemu倒没必要这么麻烦 只是我想着可能会顺带研究一下qemu</span></span><br><span class="line">wget https://download.qemu.org/qemu-6.1.0-rc3.tar.xz</span><br><span class="line">tar xvJf qemu-6.1.0-rc3.tar.xz</span><br><span class="line"><span class="built_in">cd</span> qemu-6.1.0-rc3</span><br><span class="line">./configure  <span class="comment"># 默认安装路径是/usr/local/bin/，这里注意 SDL support: YES 不为YES 后面就只能通过VNC查看了</span></span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>遇到的问题，当安装apt遇到下列错误时</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E: Could <span class="keyword">not</span> <span class="keyword">get</span> <span class="keyword">lock</span> /var/lib/dpkg/<span class="keyword">lock</span>-frontend - <span class="keyword">open</span> (<span class="number">11</span>: Resource temporarily unavailable)</span><br><span class="line">E: Unable <span class="keyword">to</span> acquire the dpkg frontend <span class="keyword">lock</span> (/var/lib/dpkg/<span class="keyword">lock</span>-frontend), <span class="keyword">is</span> another process <span class="keyword">using</span> it?</span><br></pre></td></tr></table></figure><p>建议直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /var/lib/apt/lists/lock</span><br><span class="line">sudo <span class="built_in">rm</span> /var/cache/apt/archives/lock</span><br><span class="line">sudo <span class="built_in">rm</span> /var/lib/dpkg/lock*</span><br><span class="line">sudo dpkg --configure -a</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h1 id="2-nasm"><a href="#2-nasm" class="headerlink" title="2 nasm"></a>2 nasm</h1><p>写操作系统嘛，总不可能真的就用01来干，那得累死，所以需要用汇编，书中用的是nask，nask和nasm同为汇编编译器。nasm支持win、linux和MacOS，mask仅支持win。这两个差别不大，由于我们是在Ubuntu18下进行试验，所以必然选择nasm了，差距就是</p><table><thead><tr><th>nask代码</th><th>nasm代码</th></tr></thead><tbody><tr><td><code>JMP entry</code></td><td><code>JMP SHORT entry</code></td></tr><tr><td><code>RESB &lt;填充字节数&gt;</code></td><td><code>TIMES &lt;填充字节数&gt; DB &lt;填充数据&gt;</code></td></tr><tr><td><code>RESB 0x7dfe-$</code></td><td><code>TIMES 0x1fe-($-$) DB 0</code></td></tr><tr><td><code>ALIGNB 16</code></td><td><code>ALIGN 16, DB 0</code></td></tr></tbody></table><p>我觉得这个就没必要再通过二进制包安装了，直接<code>sudo apt install nasm</code>就好了，然后用<code>nasm --version</code>检测一下是否安装好就ok了</p><h1 id="3-hex-editor"><a href="#3-hex-editor" class="headerlink" title="3 hex editor"></a>3 hex editor</h1><p>不说用01去写代码吧，看看01代码还是有必要的，所以还是需要一个趁手的十六进制编辑器的，这玩意我就随意百度了俩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install wxhexeditor <span class="comment"># 这玩意好久没更新了 官网都没了 但是挺好用的</span></span><br><span class="line">sudo apt-get install bless       <span class="comment"># 这个倒在更新 但是感觉一般吧</span></span><br><span class="line">sudo apt-get install hexedit     <span class="comment"># 这个是命令行版本</span></span><br></pre></td></tr></table></figure><p>我觉得还是wxHexEditor比较强大，因为16进制能转成汇编..</p><h1 id="4-helloos0"><a href="#4-helloos0" class="headerlink" title="4 helloos0"></a>4 helloos0</h1><p>这个时候可以尝试实验了，直接把光盘中的<code>projects/01_day/helloos0/helloos.img</code>拷到我们自己的目录下，然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sidney@ubuntu:~/Work/MyOS/day01$ qemu-system-i386 helloos.img</span><br><span class="line">WARNING: Image format was not specified <span class="keyword">for</span> <span class="string">'helloos.img'</span> and probing guessed raw.</span><br><span class="line">         Automatically detecting the format is dangerous <span class="keyword">for</span> raw images, write operations on block 0 will be restricted.</span><br><span class="line">         Specify the <span class="string">'raw'</span> format explicitly to remove the restrictions.</span><br></pre></td></tr></table></figure><p>虽然有warning，但是至少系统跑起来了，而想让这段警告消失，也很简单，将命令改为<code>qemu-system-i386 -drive file=helloos.img,format=raw,if=floppy</code>就ok了</p><p>按照书上说的，使用十六进制编写OS，神经病..我才不抄，浪费时间</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0000000:</span> <span class="string">EB4E</span> <span class="number">9048 </span><span class="string">454C</span> <span class="string">4C4F</span> <span class="number">4950 </span><span class="string">4C00</span> <span class="number">0201 </span><span class="number">0100</span> </span><br><span class="line"><span class="attr">0000016:</span> <span class="number">02E0</span> <span class="number">0040 </span><span class="string">0BF0</span> <span class="number">0900 </span><span class="number">1200 </span><span class="number">0200 </span><span class="number">0000 </span><span class="number">0000</span> </span><br><span class="line"><span class="attr">0000032:</span> <span class="string">400B</span> <span class="number">0000 </span><span class="number">0000 </span><span class="string">29FF</span> <span class="string">FFFF</span> <span class="string">FF48</span> <span class="string">454C</span> <span class="string">4C4F</span> </span><br><span class="line"><span class="attr">0000048:</span> <span class="string">2D4F</span> <span class="number">5320 </span><span class="number">2020 </span><span class="number">4641 </span><span class="number">5431 </span><span class="number">3220 </span><span class="number">2020 </span><span class="number">0000</span> </span><br><span class="line"><span class="attr">0000064:</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span> </span><br><span class="line"><span class="attr">0000080:</span> <span class="string">B800</span> <span class="string">008E</span> <span class="string">D0BC</span> <span class="string">007C</span> <span class="string">8ED8</span> <span class="string">8EC0</span> <span class="string">BE74</span> <span class="string">7C8A</span> </span><br><span class="line"><span class="attr">0000096:</span> <span class="number">0483 </span><span class="string">C601</span> <span class="string">3C00</span> <span class="number">7409 </span><span class="string">B40E</span> <span class="string">BB0F</span> <span class="string">00CD</span> <span class="string">10EB</span> </span><br><span class="line"><span class="attr">0000112:</span> <span class="string">EEF4</span> <span class="string">EBFD</span> <span class="string">0A0A</span> <span class="number">6865 </span><span class="string">6C6C</span> <span class="string">6F2C</span> <span class="number">2077 </span><span class="string">6F72</span> </span><br><span class="line"><span class="attr">0000128:</span> <span class="string">6C64</span> <span class="string">0A00</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span> </span><br><span class="line"><span class="string">.......:</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span></span><br><span class="line"><span class="attr">0000496:</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="string">55AA</span></span><br><span class="line"><span class="attr">0000512:</span> <span class="string">F0FF</span> <span class="string">FF00</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span></span><br><span class="line"><span class="string">.......:</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span></span><br><span class="line"><span class="attr">0005120:</span> <span class="string">F0FF</span> <span class="string">FF00</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span></span><br><span class="line"><span class="string">.......:</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span></span><br><span class="line"><span class="attr">1474544:</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span></span><br><span class="line"><span class="attr">1474560:</span> <span class="comment"># 因为我们是从0开始计数的哦</span></span><br></pre></td></tr></table></figure><p>剩下的内容全为0，文件大小为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="28.283ex" height="1.717ex" role="img" focusable="false" viewBox="0 -677 12500.9 759"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1222.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(2222.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(3444.7,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(4444.9,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1000,0)"></path></g><g data-mml-node="mo" transform="translate(6167.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(7167.3,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(7945.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9000.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(2000,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(2500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(3000,0)"></path></g></g></g></svg></mjx-container>字节，这个很重要，一定要保证大小正确</p><h1 id="5-helloos1"><a href="#5-helloos1" class="headerlink" title="5 helloos1"></a>5 helloos1</h1><p>按照书上第二步，稍微高级一点的东西，涉及到汇编，直接<code>vim myos.asm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DB  0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f</span><br><span class="line">DB  0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00</span><br><span class="line">DB  0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00</span><br><span class="line">DB  0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">DB  0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff</span><br><span class="line">DB  0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4f</span><br><span class="line">DB  0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41</span><br><span class="line">DB  0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00</span><br><span class="line">; RESB 16  ;这里和书上不一样 因为我们的环境是nasm而不是nask</span><br><span class="line">TIMES 16 DB 0x00</span><br><span class="line">DB  0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c</span><br><span class="line">DB  0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a</span><br><span class="line">DB  0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09</span><br><span class="line">DB  0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb</span><br><span class="line">DB  0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65</span><br><span class="line">DB  0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72</span><br><span class="line">DB  0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">; RESB    368</span><br><span class="line">TIMES  368 DB 0x00</span><br><span class="line">DB0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa</span><br><span class="line">DB0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">; RESB  4600</span><br><span class="line">TIMES  4600 DB 0x00</span><br><span class="line">DB  0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">; RESB  1469432</span><br><span class="line">TIMES  1469432 DB 0x00</span><br></pre></td></tr></table></figure><p>通过命令<code>nasm myos.asm -o myos.img</code>得到我们编译出的操作系统，依旧是执行<code>qemu-system-i386 -drive file=myos.img,format=raw,if=floppy</code>，运行我们的操作系统，出现个hello world。不过这玩意还是不大能看懂什么意思</p><h1 id="6-helloos2"><a href="#6-helloos2" class="headerlink" title="6 helloos2"></a>6 helloos2</h1><p>再按书中的汇编，写个能看懂的操作系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">; hello-os</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">; 以下这段是标准FAT12格式软盘专用代码</span><br><span class="line">DB  0xeb, 0x4e, 0x90 ; 这里eb4e是jmp 0x00000050，而90是nop</span><br><span class="line">DB  "HELLOIPL"       ; 启动区的名称 可以是任意的字符串(8字节)</span><br><span class="line">DW  512              ; 每个扇区(sector)的大小(必须是512字节)</span><br><span class="line">DB  1                ; 簇(cluster)的大小(必须为1个扇区)</span><br><span class="line">DW  1                ; FAT的起始位置(一般从第一个扇区开始)</span><br><span class="line">DB  2                ; FAT的个数(必须为2)</span><br><span class="line">DW  224              ; 根目录的大小(一般设置为224项)</span><br><span class="line">DW  2880             ; 该磁盘的大小(必须是2880扇区)</span><br><span class="line">DB  0xf0             ; 磁盘的种类(必须是0xf0)</span><br><span class="line">DW  9                ; FAT的长度(必须是9扇区)</span><br><span class="line">DW  18               ; 1个磁道(track)有几个扇区(必须是18)</span><br><span class="line">DW  2                ; 磁头数(必须是2)</span><br><span class="line">DD  0                ; 不使用分区(必须是0)</span><br><span class="line">DD  2880             ; 重写一次磁盘大小</span><br><span class="line">DB  0,0,0x29         ; 意义不明 固定</span><br><span class="line">DD  0xffffffff       ; (可能是)卷标号码</span><br><span class="line">DB  "HELLO-OS   "    ; 磁盘的名称(11字节)</span><br><span class="line">DB  "FAT12   "       ; 磁盘格式名称(8字节)</span><br><span class="line">;RESB  18             ; 先空出18字节</span><br><span class="line">TIMES  18  DB 0</span><br><span class="line"></span><br><span class="line">; 程序主体</span><br><span class="line">DB  0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c</span><br><span class="line">DB  0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a</span><br><span class="line">DB  0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09</span><br><span class="line">DB  0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb</span><br><span class="line">DB  0xee, 0xf4, 0xeb, 0xfd</span><br><span class="line"></span><br><span class="line">; 信息显示部分</span><br><span class="line">DB  0x0a, 0x0a       ; 两个换行</span><br><span class="line">DB  "This is my first OS!"</span><br><span class="line">DB  0x0a             ; 换行</span><br><span class="line">DB  0</span><br><span class="line">;RESB  0x1fe-$       ; 填写0x00，直到0x001fe</span><br><span class="line">TIMES  0x1fe-($-$)  DB 0</span><br><span class="line">DB  0x55, 0xaa       ; 必须保证510字节处是55aa</span><br><span class="line"></span><br><span class="line">; 以下是启动区以外部分的输出</span><br><span class="line">DB  0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">;RESB  4600</span><br><span class="line">TIMES   4600  DB  0</span><br><span class="line">DB  0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00</span><br><span class="line">;RESB  1469432</span><br><span class="line">TIMES  1469432  DB  0</span><br></pre></td></tr></table></figure><p>DB: define byte，往文件里直接写入1字节的指令</p><p>DW: define word，16位</p><p>DD: define double-word，32位</p><p>$ : 代表一个变量，表示当前行的偏移地址</p><p>$$: 代表一个变量，表示当前段(汇编的section，数据段，代码段..)的起始偏移地址</p><p>TIMES: 重复定义数据或指令</p><p>RESB：reserve byte的缩写，RESB 10这一指令的含义是：从现在的地址开始空出10个字节，且nask（编译器）会自动在空出的部分填充上0x00，这就极大的节省了输入大量0x00的时间。</p><p>启动区(boot sector): 软盘第一个扇区称为启动区。计算机读写软盘时，是以512字节为一个单位进行读写的，因此软盘的512字节就称为一个扇区。一张软盘共有1440KB，也就是1474560字节，除以512得2880，也就是一张软盘有2880个扇区。计算机从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。如果最后2个字节不是55AA，计算机就认为这张盘上没有所需要启动的程序，就会报一个不能启动的错误。如果是55AA，那它就认为这个扇区的开头是启动程序，并开始执行这个程序。55AA没啥特殊含义..人家发明的时候定的</p><p>IPL(initial program loader): 启动程序加载器。启动区只有512字节，正常的操作系统不可能这么小，所以几乎所有的操作系统都是把加载操作系统本身的程序放在启动区里的。启动区的名字必须是8字节，不够得用空格补</p><p>感觉有上一篇的操作系统启动流程扫盲，有很多知识点还是比较清晰的..但是还是有几个疑惑点没去尝试，软盘能改成hdd？FAT12给整成FAT32？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是30天的第一天内容，也不知道自己能坚持到几天，有几天就几天了，活这么久了，半途而废的事情还少吗？&lt;/p&gt;
&lt;p&gt;首先需要准备几个工具&lt;/p&gt;
&lt;h1 id=&quot;1-qemu&quot;&gt;&lt;a href=&quot;#1-qemu&quot; class=&quot;headerlink&quot; title=&quot;1 qemu&quot;&gt;&lt;/a&gt;1 qemu&lt;/h1&gt;&lt;p&gt;不可能真去买个软盘什么的，所以我们需要一个虚拟计算机的东西——QEMU&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Make OS" scheme="https://sidneyding.cn/categories/OS/Make-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>[Make MyOS] After power on</title>
    <link href="https://sidneyding.cn/posts/32699cc/"/>
    <id>https://sidneyding.cn/posts/32699cc/</id>
    <published>2021-08-21T13:09:12.000Z</published>
    <updated>2023-08-13T02:32:28.813Z</updated>
    
    <content type="html"><![CDATA[<p>学习嘛，当然要有浓厚的兴趣先，所以需要百度学习了一下，按下电源键之后的故事。操作系统这玩意虽说玄乎，但是参考资料还是很多的</p><p>参考书籍是《30天自制操作系统》和《一个64位操作系统的设计与实现》，以30天为主，但是这玩意用的是Windows环境，这显然是不友好的，最终选择环境位Ubuntu18，能换的都换换呗</p><p>Intel手册：<a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></p><p>Vol1：用来介绍Intel x86平台的基本架构和执行环境。</p><p>Vol2：介绍x86指令，学汇编的时候可以参考啊</p><p>Vol3：介绍x86系统编程的基础，包括内存管理、保护、任务管理、中断和异常处理、多处理器支持、散热和电源管理功能、调试、性能监控、系统管理模式、虚拟机扩展(VMX)指令、英特尔虚拟化技术(Intel VT)和英特尔软件防护扩展(Intel SGX)。</p><p>Vol4：介绍x86 CPU上的MSR，是CPU内部的一组特殊的寄存器（这个是从原来的Vol3中独立出来的）。</p><span id="more"></span><h1 id="1-Why-Booting-is-called-Booting"><a href="#1-Why-Booting-is-called-Booting" class="headerlink" title="1 Why Booting is called Booting"></a>1 Why Booting is called Booting</h1><p>为什么计算机的启动叫boot，兴奋把这个疑问敲向了Google，我就知道肯定会有这个疑问的</p><p>参考：</p><p><a href="https://people.cs.rutgers.edu/~pxk/416/notes/02-boot.html">Booting an Operating System</a></p><p><a href="https://desktopreality.com/why-booting-is-called-booting/">Why Booting is called “Booting”</a></p><p>操作系统的启动为什么被称之为booting，而实际的程序又被称之为loading。这个原因要追溯到1950年代，booting是实际上是bootstrapping的缩写，而bootstrapping又是来自美国的一句谚语</p><blockquote><p>pull oneself up by one’s bootstraps</p></blockquote><p>字面意思就是用自己额鞋带把自己拉起来，这可能吗？这要可以，我左脚踩右脚直接起飞。但是计算机它得可以，因为计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序。所以必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。久而久之就被称之为booting了..</p><p>接着再看计算机整个启动过程</p><h1 id="2-BIOS"><a href="#2-BIOS" class="headerlink" title="2 BIOS"></a>2 BIOS</h1><blockquote><p>参考：Intel manual volume 3 chapter 9.1</p></blockquote><p>当按下电源键或者 RESET 引脚被触发时，系统总线上每个CPU都会执行初始化(硬件复位)和可选的内置自检(build-in self-test)。硬件复位将每个处理器的寄存器设置为已知状态并<strong>将处理器置于实地址模式</strong>。它还会使内部缓存、转换后备缓冲区(TLB)和分支目标缓冲区(BTB)失效。此时，采取的操作取决于处理器系列，Intel手册上举了四类，三大类，比较古老的就不看了，IA-32 and Intel 64 processors，系统总线上的所有处理器（包括单处理器系统中的单个处理器）都执行<strong>多处理器（MP）初始化协议</strong>。通过该协议被选为自举处理器(BSP)的处理器然后立即开始<strong>执行从EIP寄存器中的偏移量开始的当前代码段中的软件初始化代码</strong>。</p><p>这一段描述RESET引脚相关启动，还有一种INIT引脚，这俩差别不大，只是INIT是从保护模式转到实地址模式，抛开上电之后的BIST(毕竟是可选的)，来瞅瞅第一行代码是怎么被执行的</p><p>参考Intel手册卷3第9.1.1节，首先上电之后，寄存器CR0被设为60000010H，用以确保CPU进入<strong>实地址模式</strong>。EIP被设定为0000FFF0H，CS基地址被设定为FFFF0000H(选择器是F000H)，通过<code>CS.BASE+EIP</code>得出第一条指令的地址FFFFFFF0H。</p><p>参考Intel手册卷3第9.1.4节，硬件复位后取出并执行的第一条指令位于物理地址FFFFFFF0H。该地址比处理器的最高物理地址低16个字节。包含软件初始化代码的EPROM必须位于该地址。在实地址模式下，地址FFFFFFF0H超出了处理器的<strong>1MB</strong>可寻址范围。CS寄存器有两部分：可见段选择器部分和隐藏基地址部分。在实地址模式下，基地址通常是通过将16位段选择器值向左移动4位以产生20位基地址来形成的。但是，在硬件复位期间，CS寄存器中的段选择器装入F000H，基地址装入FFFF0000H。因此，起始地址是通过将基地址与EIP寄存器中的值相加而形成的（即，FFFF0000 + FFF0H &#x3D; FFFFFFF0H）。为确保CS寄存器中的基地址在基于EPROM的软件初始化代码完成之前保持不变，代码不得包含远跳转或远调用或允许发生中断。</p><p>那么为啥地址要是FFFFFFF0H呢？我们知道开机第一件事是读取BIOS，其实FFFFFFF0H的位置就是BIOS ROM的末尾，并且包含一条跳转指令，跳转到包含启动代码的BIOS区域。因为每家计算机生产厂商生产的机器外设不同，所以其BIOS程序大小不尽相同，有的可能是1K，有的可能是2K，如果把BIOS程序放在0x0000处，那么会造成在机器A上用户写的程序是从0x0400开始，机器B上用户写的程序就是0x0800开始，非常不统一。如果把这程序放在1M内存的顶部，再规定计算机第一条指令位置是FFFFFFF0H，然后就跳到各家BIOS开始处，那么用户写的程序都可以从0x0000开始了。</p><blockquote><p>CPU工作模式：实模式、保护模式、长模式。CPU同时在安全性上也要提升，从只有实模式【可以随意执行全部CPU指令，内存可以直接通过物理地址访问，随意访问随意读写】，到了32的保护模式【将指令划分为ring0到ring3，CPU指令不是你想调用就能调用；内存不是你想访问就能访问，首先CPU要允许，而且操作系统允许】，而64的长模式在安全方面与32并没有本至区别；</p><p>实模式又称实地址模式，实，即真实，这个真实分为两个方面，一个方面是运行真实的指令，对指令的动作不作区分，直接执行指令的真实功能，另一方面是发往内存的地址是真实的，对任何地址不加限制地发往内存。另外16位CPU是没有实模式这一说的，在实模式下地址总线只使用了20根，<strong>寻址范围为2^20^B&#x3D;1MB</strong>。可参考Intel manual volume 3 chapter 8.7.13.4，有个A20M# pin，会屏蔽掉</p><p>保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是32位的，还可以单独使用低16位，这个低16位又可以拆分成两个8位寄存器</p><p>长模式又名AMD64，因为这个标准是AMD公司最早定义的，它使CPU在现有的基础上有了64位的处理能力，既能完成64位的数据运算，也能寻址64位的地址空间。这在大型计算机上犹为重要，因为它们的物理内存通常有几百GB。</p><p>更多查看：Intel manual volume 3 chapter 2.2</p></blockquote><p>经过上面的解释，终于到了BIOS了，BIOS执行过程如下：</p><ol><li><p>开机自检(POST)，如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止</p></li><li><p>检测显卡（芯片）的BIOS并执行其代码以初始化视频硬件</p></li><li><p>检测任何其他设备BIOS并调用它们的初始化函数</p></li><li><p>显示BIOS启动画面</p></li><li><p>执行简短的内存测试（确定系统中有多少内存）</p></li><li><p>设置内存和驱动参数</p></li><li><p>配置即插即用设备（传统上是PCI总线设备）</p></li><li><p>分配资源（DMA通道和IRQ）</p></li><li><p>识别引导设备，此时BIOS需要知道，“下一阶段的启动程序”具体存放在哪一个设备。当BIOS识别引导设备（通常是被标记为可引导磁盘的几个磁盘之一）时，它从该设备读取块0到内存位置<strong>0x7c00</strong>并跳转到那里。</p></li></ol><h1 id="3-MBR"><a href="#3-MBR" class="headerlink" title="3 MBR"></a>3 MBR</h1><p>MBR(Master Boot Record)，硬盘的0柱面、0磁头、1扇区称为主引导扇区，FDISK程序写到该扇区的内容称为主引导记录（MBR）。该记录占用512个字节，它用于硬盘启动时将系统控制权交给用户指定的，并在分区表中登记了的某个操作系统区。BIOS中启动顺序排第一的存储设备，软盘，硬盘，U盘等..不管什么盘，一般都是读取其第一个扇区，也就是512字节，加载到0x7c00处，如果这512字节的最后两个字节是0x55AA，那么就表示这个设备可以启动，如果不是，那就用下一个储存设备。512字节太小了，所以作用很明确，就是指明操作系统的入口在哪。MBR的内容是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一阶段引导加载程序（≤ 440字节）</span><br><span class="line">磁盘签名（4字节）</span><br><span class="line">磁盘分区表，用于标识磁盘的不同区域（每个分区16字节 × 4个分区）</span><br></pre></td></tr></table></figure><p>一个扇区的硬盘主引导记录MBR由4个部分组成。</p><table><thead>  <tr>    <th>字节</th>    <th>内容</th>    <th>分类</th>  </tr></thead><tbody>  <tr>    <td>0000H~0088H</td>    <td>主引导程序</td>    <td>主引导程序</td>  </tr>  <tr>    <td>0089H~00E1H</td>    <td>出错信息</td>    <td rowspan="2">数据区</td>  </tr>  <tr>    <td>00E2H~01BDH</td>    <td>全为0</td>  </tr>  <tr>    <td>01BEH~01CDH</td>    <td>分区项1</td>    <td rowspan="4">分区表</td>  </tr>  <tr>    <td>01CEH~01DDH</td>    <td>分区项2</td>  </tr>  <tr>    <td>01DEH~01EDH</td>    <td>分区项3</td>  </tr>  <tr>    <td>01EEH~01FDH</td>    <td>分区项4</td>  </tr>  <tr>    <td>01FEH</td>    <td>0x55</td>    <td rowspan="2">结束标志</td>  </tr>  <tr>    <td>01FFH</td>    <td>0xAA</td>  </tr></tbody></table><p>占用512个字节的MBR中，偏移地址01BEH~01FDH的64个字节，为4个分区项内容（分区信息表）。它是由磁盘介质类型及用户在使用FDISK定义分区时确定的。在实际应用中，FDISK对一个磁盘划分的主分区可少于4个，但最多不超过4个。每个分区表的项目是16个字节，其内容含义如下表所示。</p><table><thead><tr><th>存贮字节位</th><th>内容及含义</th></tr></thead><tbody><tr><td>第1字节</td><td>引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。</td></tr><tr><td>第2、3、4字节</td><td>本分区的起始磁头号、扇区号、柱面号。其中：磁头号——第2字节；扇区号——第3字节的低6位；柱面号——为第3字节高2位+第4字节8位。</td></tr><tr><td>第5字节</td><td>分区类型符。00H——表示该分区未用（即没有指定）；06H——FAT16基本分区；0BH——FAT32基本分区；05H——扩展分区；07H——NTFS分区；0FH——（LBA模式）扩展分区（83H为Linux分区等）</td></tr><tr><td>第6、7、8字节</td><td>本分区的结束磁头号、扇区号、柱面号。其中：磁头号——第6字节；扇区号——第7字节的低6位；柱面号——第7字节的高2位+第8字节。</td></tr><tr><td>第9、10、11、12字节</td><td>本分区已用的扇区数。</td></tr><tr><td>第13、14、15、16字节</td><td>本分区的总扇区数。</td></tr></tbody></table><p>最后的四个字节（“主分区的扇区总数”），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2^32^。</p><p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p><p>BIOS完了以后就到了硬盘的某个分区了，在进硬盘分区之前，先来看一个疑问。</p><p>为什么是0x7c00？这玩意在Intel手册没搜到，所以应当和CPU啥的没关系。觉知此事要Google：<a href="https://www.glamenv-septzen.net/en/view/6">Why BIOS loads MBR into 0x7C00 in x86 ?</a></p><blockquote><p>“0x7C00” First appeared in IBM PC 5150 ROM BIOS INT 19h handler.</p><p>When power on, BIOS processes “POST”(Power On Self Test) procedure, and after, <strong>call INT 19h</strong>.<br>In INT 19h handler, BIOS checks that PC has any of floppy&#x2F;hard&#x2F;fixed diskette or not have.<br>If PC has any of available diskkete, BIOS loads a first sector(512B) of diskette into 0x7C00.</p><p>Now, you understand why you couldn’t find out this magic number in x86 documents. <strong>This magic number belongs to BIOS specification.</strong></p><p>“0x7C00” was decided by IBM PC 5150 BIOS developer team (Dr. David Bradley).</p></blockquote><p>BIOS开发团队决定0x7C00是因为：他们希望为操作系统在32KB内加载自己留下尽可能多的空间。8086&#x2F;8088使用0x0~0x3FF作为中断向量，BIOS数据区在它之后。引导扇区为512字节，引导程序的堆栈&#x2F;数据区需要更多的512字节。因此，选择了0x7C00，即32KB的最后1024B。一旦操作系统加载并启动，引导扇区将永远不会使用，直到电源重置。因此，操作系统和应用程序可以自由使用32KB的最后1024B。</p><p>系统加载后，内存布局</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">--------------------- 0x0</span></span><br><span class="line">| <span class="type">Interrupts</span> vectors</span><br><span class="line">+<span class="comment">--------------------- 0x400</span></span><br><span class="line">| <span class="type">BIOS</span> <span class="class"><span class="keyword">data</span> area</span></span><br><span class="line">+<span class="comment">--------------------- 0x5??</span></span><br><span class="line">| <span class="type">OS</span> load area</span><br><span class="line">+<span class="comment">--------------------- 0x7C00</span></span><br><span class="line">| <span class="type">Boot</span> sector</span><br><span class="line">+<span class="comment">--------------------- 0x7E00</span></span><br><span class="line">| <span class="type">Boot</span> <span class="class"><span class="keyword">data</span>/stack</span></span><br><span class="line">+<span class="comment">--------------------- 0x7FFF</span></span><br><span class="line">| (not used)</span><br><span class="line">+<span class="comment">--------------------- (...)</span></span><br></pre></td></tr></table></figure><p>相对MBR，还有一种应该不会用到的EBR(Extended Boot Record)..</p><h1 id="4-VBR"><a href="#4-VBR" class="headerlink" title="4 VBR"></a>4 VBR</h1><p>一旦BIOS将控制权转移到加载到内存中的MBR的开头，MBR代码就会扫描其分区表并加载该分区的卷引导记录(VBR)。VBR是从指定分区的第一个磁盘块开始的一系列连续块。VBR的第一个块标识分区类型和大小并包含初始程序加载器(IPL)，该代码将加载构成第二阶段引导加载器的附加块。在Windows NT派生系统（例如，Windows Server 2012、Windows 8）上，IPL加载一个名为NTLDR 的程序，然后该程序加载操作系统。</p><p>低级引导加载程序难以加载完整操作系统（尤其是可能由多个文件组成的操作系统）的一个原因是，这样做需要解析文件系统结构的能力。这意味着了解目录和文件名的布局方式以及如何找到与特定文件对应的数据块。没有太多代码，只读取连续的块要容易得多。更高级别的加载程序，例如Microsoft的NTLDR，可以读取NTFS、FAT和ISO 9660(CD)文件格式。</p><p>简单来说，VBR的下一步才是加载操作系统</p><p>这里除了VBR，还有Boot Manager，比如说Windows Boot Manager，GRUB等等，就是计算机上装了多个操作系统，让用户选择启动哪一个的东西，也就是说从MBR过来，控制权不给VBR了，而是给启动管理器这么个程序</p><h1 id="5-OS"><a href="#5-OS" class="headerlink" title="5 OS"></a>5 OS</h1><p>VBR指明了操作系统在哪，接下来就是把操作系统给加载起来，比如说Linux就会先把kernel加载起来，完了再到用户空间init进程，init再加载各个进程模块，窗口，网络啥的，至此操作系统就起来了</p><h1 id="6-UEFI"><a href="#6-UEFI" class="headerlink" title="6 UEFI"></a>6 UEFI</h1><p>B站大佬：<a href="https://space.bilibili.com/41036636/channel/collectiondetail?sid=54177">谭玉刚的个人空间</a> 讲UEFI的，先mark下，后面可以学习学习..</p><p>随着64位架构取代32位架构的出现，BIOS开始显得过时了。英特尔着手创建BIOS后继产品的规范，该规范对必须以20位寻址的16位模式运行启动代码没有任何限制。此规范称为统一可扩展固件接口或UEFI。尽管由英特尔开发，但自2005年起由统一EFI论坛管理。许多较新的64位系统都使用它，包括Mac，这些系统也支持运行Windows的旧版BIOS。</p><p>EFI支持的一些功能包括：</p><p>保留了BIOS中的一些组件，包括电源管理（高级配置和电源接口，ACPI）和系统管理组件（例如，读取和设置日期）。</p><p>支持更大的磁盘BIOS仅支持每个磁盘四个分区，每个分区的容量高达2.2TB。UEFI支持的最大分区大小为9.4ZB（9.4 × 10^21字节）。</p><p>无需在16位（实）模式下启动，预引导执行环境可以直接访问所有系统内存。</p><p>UEFI包括设备驱动程序，包括解释与体系结构无关的EFI字节代码(EBC)的能力。然而，操作系统使用它们自己的驱动程序，因此与BIOS一样，驱动程序通常仅用于引导过程。 </p><p>旧的BIOS只能加载单个块，这需要多阶段启动过程。UEFI有自己的命令解释器和完整的引导管理器。不再需要专用的引导加载程序。只要将可引导文件放入UEFI引导分区，该分区被格式化为FAT文件系统（旧Windows系统中的标准文件系统格式；几乎每个操作系统都知道如何处理的文件系统格式）。 </p><p>固件是可扩展的，UEFI 的扩展可以加载到非易失性内存中。</p><h1 id="7-Non-Intel-Systems"><a href="#7-Non-Intel-Systems" class="headerlink" title="7 Non-Intel Systems"></a>7 Non-Intel Systems</h1><p>上面的依据都是Intel的，向Android(嵌入式)和MAC就不一定一样了</p><p>许多嵌入式设备不会加载操作系统，而是已经将操作系统存储在非易失性存储器（如Flash或ROM）中。例如，那些加载操作系统（例如基于ARM的Android手机）的设备将在设备开机时执行只读存储器（通常在NOR闪存中）中的代码。此引导代码嵌入在某些设备的CPU ASIC中，因此不需要板上单独的闪存芯片。当系统复位（包括上电）时，处理器处于监控(SVC)模式并且中断被禁用。在基于ARM的系统上，处理器从地址0x00000000开始执行。包含启动代码的闪存在复位时映射到地址0x00000000。此代码执行各种初始化，包括在DRAM中设置异常向量表以及将应用程序代码从ROM复制到DRAM（代码在DRAM中运行速度更快）。代码将DRAM重新映射到地址0，从而隐藏了闪存（处理器有一个REMAP位来改变闪存的映射）。然后初始化存储系统。这涉及设置内存保护和设置系统堆栈。然后初始化I&#x2F;O设备并将处理器更改为用户模式。引导固件检测可引导媒体并加载和运行第二阶段引导加载程序（如有必要）。第二阶段引导加载程序通常是用于大型系统的GRUB或用于嵌入式系统的uBoot。第二阶段加载器加载操作系统并将控制权转移给它。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习嘛，当然要有浓厚的兴趣先，所以需要百度学习了一下，按下电源键之后的故事。操作系统这玩意虽说玄乎，但是参考资料还是很多的&lt;/p&gt;
&lt;p&gt;参考书籍是《30天自制操作系统》和《一个64位操作系统的设计与实现》，以30天为主，但是这玩意用的是Windows环境，这显然是不友好的，最终选择环境位Ubuntu18，能换的都换换呗&lt;/p&gt;
&lt;p&gt;Intel手册：&lt;a href=&quot;https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html&quot;&gt;Intel® 64 and IA-32 Architectures Software Developer Manuals&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vol1：用来介绍Intel x86平台的基本架构和执行环境。&lt;/p&gt;
&lt;p&gt;Vol2：介绍x86指令，学汇编的时候可以参考啊&lt;/p&gt;
&lt;p&gt;Vol3：介绍x86系统编程的基础，包括内存管理、保护、任务管理、中断和异常处理、多处理器支持、散热和电源管理功能、调试、性能监控、系统管理模式、虚拟机扩展(VMX)指令、英特尔虚拟化技术(Intel VT)和英特尔软件防护扩展(Intel SGX)。&lt;/p&gt;
&lt;p&gt;Vol4：介绍x86 CPU上的MSR，是CPU内部的一组特殊的寄存器（这个是从原来的Vol3中独立出来的）。&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Make OS" scheme="https://sidneyding.cn/categories/OS/Make-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>Compile Android 11 with WSL2</title>
    <link href="https://sidneyding.cn/posts/c64b5633/"/>
    <id>https://sidneyding.cn/posts/c64b5633/</id>
    <published>2021-06-13T01:15:43.000Z</published>
    <updated>2023-08-13T01:51:38.855Z</updated>
    
    <content type="html"><![CDATA[<p>手里就一台笔记本，可不想把系统换成Linux的，毕竟有很多操作还是很不方便，但是又想学习学习Android源码，所以，总得找点什么凑活着用的办法，于是我把目光放到了Win10上的Linux子系统上了，也就是WSL，毕竟虚拟机太废内存划不来，亲测</p><p>CPU：AMD Ryzen 7 4800H with Radeon Graphics 2.90 GHz</p><p>RAM：16G</p><p>ROM：512G SSD + 2T HDD</p><p>GPU：GTX 1650</p><p>跑起来不说多么流畅，反正不卡，可能编译慢点，咱也不差那点时间，硬盘预留个256G的空间就够了。话不多说，记录一下这次操作的经历..</p><span id="more"></span><h1 id="1-安装WSL2"><a href="#1-安装WSL2" class="headerlink" title="1 安装WSL2"></a>1 安装WSL2</h1><p>网上教程比较多，直接看微软官方教程即可：[在 Windows 10 上安装 WSL | Microsoft Docs](<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10#manual-installation-steps">在 Windows 10 上安装 WSL | Microsoft Docs</a>)</p><p>我这里按照教程装了Ubuntu-18.04，推荐也安装个Windows Terminal，还是挺好用的，可以看看这个：<a href="https://zhuanlan.zhihu.com/p/137595941">Windows Terminal 完美配置 PowerShell 7.1</a></p><p>按照这个方法安装完了呢，WSL2所有东西都是默认放在C盘的，咱可是要做大事的人，C盘怕是放不太下，啥？你就一个盘，好的，当我没说。</p><h2 id="1-1-WSL2挪位"><a href="#1-1-WSL2挪位" class="headerlink" title="1.1 WSL2挪位"></a>1.1 WSL2挪位</h2><p>我C盘就200G显然不能够干大事，所以就转移到E盘了，于是，咱们打开powershell或者Windows Terminal：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出导入Ubuntu18</span></span><br><span class="line"><span class="comment">## 路径太长 看着不舒服 换一下</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState&gt; <span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; wsl <span class="literal">--shutdown</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br><span class="line">  NAME            STATE           VERSION</span><br><span class="line">* Ubuntu<span class="literal">-18</span>.<span class="number">04</span>    Stopped         <span class="number">2</span></span><br><span class="line"><span class="comment">## 导出</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; wsl <span class="literal">--export</span> Ubuntu<span class="literal">-18</span>.<span class="number">04</span>  E:\wsl2\ubuntu18\ubuntu18.tar</span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; wsl <span class="literal">--unregister</span> Ubuntu<span class="literal">-18</span>.<span class="number">04</span></span><br><span class="line"><span class="comment">## 导入</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; wsl <span class="literal">--import</span> Ubuntu<span class="literal">-18</span>.<span class="number">04</span> E:\wsl2\ubuntu18 E:\wsl2\ubuntu18\ubuntu18.tar</span><br><span class="line"><span class="comment">## 设置默认用户 就是之前安装wsl时创建的用户。此时会在 E:\wsl2\ubuntu18 下多一个ext4.vhdx 的文件</span></span><br><span class="line"><span class="comment">## 最好给一个完全控制权限 不然必须要管理员模式才能用</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; ubuntu1804.exe config <span class="literal">--default-user</span> sidney</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的可以不用执行，主要的是创建要给link</span></span><br><span class="line"><span class="comment">## 设置WSL要移动的位置</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; <span class="variable">$newLocation</span> = <span class="string">&quot;E:\wsl2\ubuntu18&quot;</span></span><br><span class="line"><span class="comment">## 这里具体位置可能不同 找到CanonicalGroupLimited.Ubuntu18.04onWindows开头就不会错了</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; <span class="built_in">cd</span> ~\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState</span><br><span class="line"><span class="comment">## 彻底关闭wsl</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState&gt; wsl <span class="literal">--shutdown</span></span><br><span class="line"><span class="comment">## 下面这些命令 需要启用hype-v相关服务 不然会报没这个命令啥的 如果不需要 移动完了再关掉就行了</span></span><br><span class="line"><span class="comment">## 主要是两个地方 一个是 启用或关闭Windows功能 另一个是 服务 后面放张图</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState&gt; <span class="built_in">Optimize-VHD</span> .\ext4.vhdx <span class="literal">-Mode</span> Full</span><br><span class="line"><span class="comment">## 创建目标位置</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState&gt; mkdir <span class="variable">$newLocation</span> <span class="literal">-Force</span></span><br><span class="line"><span class="comment">## 这就挪过去了</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState&gt; <span class="built_in">mv</span> ext4.vhdx <span class="variable">$newLocation</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState&gt; <span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState&gt; <span class="built_in">rm</span> LocalState</span><br><span class="line"><span class="comment">## 这实际上就类似于Linux上的link</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.<span class="number">04</span>onWindows_79rhkp1fndgsc\LocalState&gt; <span class="built_in">New-Item</span> <span class="literal">-ItemType</span> SymbolicLink <span class="literal">-Path</span> <span class="string">&quot;LocalState&quot;</span> <span class="literal">-Target</span> <span class="variable">$newLocation</span></span><br></pre></td></tr></table></figure><p>至此已经完成了wsl的迁移，已经可以用了</p><p>贴两张图</p><p>一个是 启用或关闭Windows功能，<code>Win + R</code> – 输入”control”，回车 – 程序</p><p><img data-src="/assets/Compile-Android-11-with-WSL2/20210613100715.png"></p><p>另一个是 服务，<code>Win + R</code> – 输入”services.msc”，回车</p><p><img data-src="/assets/Compile-Android-11-with-WSL2/20210613100834.png"></p><p>接下来需要考虑一件事，把Android源码放在哪？如果放在宿主机，Win10上，最好开启大小写敏感，以及得考虑后面权限的事情，我怕麻烦，最后决定就放wsl里面好了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启大小写敏感</span></span><br><span class="line">fsutil file SetCaseSensitiveInfo E:\workspace\AOSP enable</span><br><span class="line">fsutil file SetCaseSensitiveInfo E:\workspace\CCACHE enable</span><br><span class="line"><span class="comment"># 关闭大小写敏感</span></span><br><span class="line">fsutil file SetCaseSensitiveInfo E:\workspace\AOSP disable</span><br><span class="line">fsutil file SetCaseSensitiveInfo E:\workspace\CCACHE disable</span><br></pre></td></tr></table></figure><p>如果想要看代码，可以在wsl里面再弄个opengrok：<a href="https://sidneygod.github.io/posts/ad7ab3b5/">Build OpenGrok To Read the Fuck Source Code | Sidney God</a></p><h2 id="1-2-WSL2配置"><a href="#1-2-WSL2配置" class="headerlink" title="1.2 WSL2配置"></a>1.2 WSL2配置</h2><p>我也是后来才想起来的，这儿么点配置，编译Android有点费事不说，还有可能编不了，我们需要对wsl做点什么：<a href="https://docs.microsoft.com/en-us/windows/wsl/wsl-config">Manage Linux Distributions | Microsoft Docs</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Windows的user根目录创建.wslconfig文件 啥？你问我为啥有vim cat..命令？我装了git啊</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; vim ~\.wslconfig</span><br><span class="line">[<span class="type">wsl2</span>]</span><br><span class="line"><span class="comment">#memory=8GB # Limits VM memory in WSL 2 to 4 GB</span></span><br><span class="line">processors=<span class="number">4</span> <span class="comment"># Makes the WSL 2 VM use two virtual processors</span></span><br><span class="line">swap=<span class="number">16</span>GB  <span class="comment"># 你不设置 貌似没有swap</span></span><br><span class="line">swapFile=%USERPROFILE%\AppData\Local\Temp\swap.vhdx</span><br><span class="line">localhostForwarding=true</span><br><span class="line"></span><br><span class="line">[<span class="built_in">int</span><span class="type">erop</span>]</span><br><span class="line">enabled=false</span><br><span class="line">appendWindowsPath=false</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后需要重启才能生效</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; wsl <span class="literal">--shutdown</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最好再用管理员模式打开powershell输入以下命令</span></span><br><span class="line">net stop LxssManager</span><br><span class="line">net <span class="built_in">start</span> LxssManager</span><br></pre></td></tr></table></figure><h2 id="1-3-WSL2扩容"><a href="#1-3-WSL2扩容" class="headerlink" title="1.3 WSL2扩容"></a>1.3 WSL2扩容</h2><p>WSL2使用虚拟硬件磁盘(VHD)来存储Linux文件。如果达到其最大大小，则可能需要对其进行扩展。WSL2 VHD使用ext4文件系统,此VHD会自动调整大小以满足你的存储需求，并且其最大大小为256GB。如果你的分发版大小增长到大于256GB，则会显示错误，指出磁盘空间不足。 可以通过扩展 VHD 大小来纠正此错误。若要将最大 VHD 大小扩展到超过 256GB，请执行以下操作：</p><p>参考：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/disk-space?source=recommendations#how-to-expand-the-size-of-your-wsl-2-virtual-hard-disk">如何管理 WSL 磁盘空间 | Microsoft Learn</a></p><p>以管理员模式打开powershell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\WINDOWS\system32&gt; diskpart</span><br><span class="line"></span><br><span class="line">Microsoft DiskPart 版本 <span class="number">10.0</span>.<span class="number">19041.964</span></span><br><span class="line"></span><br><span class="line">Copyright (C) Microsoft Corporation.</span><br><span class="line">在计算机上: SIDNEYGOD</span><br><span class="line"><span class="comment"># 找不到咱的虚拟磁盘</span></span><br><span class="line">DISKPART&gt; list vol</span><br><span class="line"></span><br><span class="line">  卷 <span class="comment">###      LTR  标签         FS     类型        大小     状态       信息</span></span><br><span class="line">  <span class="literal">----------</span>  <span class="literal">---</span>  <span class="literal">-----------</span>  <span class="literal">-----</span>  <span class="literal">----------</span>  <span class="literal">-------</span>  <span class="literal">---------</span>  <span class="literal">--------</span></span><br><span class="line">  卷     <span class="number">0</span>     E   <span class="keyword">Data</span>         NTFS   磁盘分区        <span class="number">1863</span> GB  正常</span><br><span class="line">  卷     <span class="number">1</span>     C   System       NTFS   磁盘分区         <span class="number">200</span> GB  正常         启动</span><br><span class="line">  卷     <span class="number">2</span>     D   Software     NTFS   磁盘分区         <span class="number">275</span> GB  正常</span><br><span class="line">  卷     <span class="number">3</span>         SYSTEM_DRV   FAT32  磁盘分区         <span class="number">260</span> MB  正常         系统</span><br><span class="line">  卷     <span class="number">4</span>         WINRE_DRV    NTFS   磁盘分区        <span class="number">1000</span> MB  正常         已隐藏</span><br><span class="line">DISKPART&gt; list vdisk</span><br><span class="line"></span><br><span class="line">没有要显示的虚拟磁盘。</span><br><span class="line"><span class="comment"># 但是咱知道在哪啊 选中</span></span><br><span class="line">DISKPART&gt; <span class="built_in">Select</span> vdisk file=<span class="string">&quot;E:\wsl2\ubuntu18\ext4.vhdx&quot;</span></span><br><span class="line"><span class="comment"># 扩展</span></span><br><span class="line">DISKPART&gt; expand vdisk maximum=<span class="string">&quot;358400&quot;</span></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">DISKPART&gt; <span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要在wsl里面执行个命令 sudo apt install resize2fs</span></span><br><span class="line">sudo resize2fs /dev/sdb &lt;sizeInMegabytes&gt;M</span><br></pre></td></tr></table></figure><h2 id="1-4-WSL2压缩"><a href="#1-4-WSL2压缩" class="headerlink" title="1.4 WSL2压缩"></a>1.4 WSL2压缩</h2><p>上面扩容完了有时候又会觉得分的太大，浪费，又想收回来，所以又得要个压缩空间的法子，同样是管理员模式打开powershell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭wsl</span></span><br><span class="line">wsl.exe --shutdown</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前子系统是不是在stopped状态</span></span><br><span class="line">wsl.exe --list --verbose</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入磁盘管理</span></span><br><span class="line">diskpart</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选中要操作的虚拟磁盘</span></span><br><span class="line">select vdisk file=&quot;E:\wsl2\ubuntu18\ext4.vhdx&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩</span></span><br><span class="line">compact vdisk</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等一会</span></span><br><span class="line">100 百分比已完成</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>到这里算是把wsl折腾完了</p><h1 id="2-编译Android"><a href="#2-编译Android" class="headerlink" title="2 编译Android"></a>2 编译Android</h1><p>我这里为啥没选Android S呢，完全是因为编不动，编system的时候总是segment fault，并且当时也忘了设置swap试试，所以就试试Android R了，结果还是比较满意的</p><h2 id="2-1-prepare"><a href="#2-1-prepare" class="headerlink" title="2.1 prepare"></a>2.1 prepare</h2><p>Ubuntu换源，基础的东西装一下。首先，Java得要安装吧，百度一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换源</span></span><br><span class="line">sudo <span class="built_in">mv</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># 主要是libesd0-dev</span></span><br><span class="line">deb http://us.archive.ubuntu.com/ubuntu/ xenial main universe</span><br><span class="line">deb-src http://us.archive.ubuntu.com/ubuntu/ xenial main universe</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装Java，不要装11..</span></span><br><span class="line">sudo add-apt-repository ppa:linuxuprising/java</span><br><span class="line">sudo apt update</span><br><span class="line">apt list | grep oracle-java</span><br><span class="line">sudo apt install oracle-java17-installer</span><br><span class="line">sudo apt install oracle-java17-set-default</span><br></pre></td></tr></table></figure><p>然后git配置一下，我发现这个git是有缺陷的，有需要最好重新安装一下</p><p>然后把Android编译需要的东西安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc python bc git-core gnupg flex bison gperf libsdl1.2-dev \</span><br><span class="line">libesd0-dev squashfs-tools build-essential zip curl \</span><br><span class="line">libncurses5-dev zlib1g-dev pngcrush schedtool libxml2 libxml2-utils \</span><br><span class="line">xsltproc lzop libc6-dev schedtool g++-multilib lib32z1-dev lib32ncurses5-dev \</span><br><span class="line">lib32readline6-dev gcc-multilib libswitch-perl libssl1.0.0 libssl-dev</span><br></pre></td></tr></table></figure><p>查询想要下载的分支：<a href="https://android.googlesource.com/platform/manifest/+refs%EF%BC%8C%E9%9C%80%E8%A6%81%E7%BF%BB%E5%A2%99%E8%83%BD%E5%8A%9B%EF%BC%8C%E6%88%96%E8%80%85%E7%94%A8github%E4%B9%9F%E8%A1%8C%EF%BC%9Ahttps://github.com/aosp-mirror/platform_manifest">https://android.googlesource.com/platform/manifest/+refs，需要翻墙能力，或者用github也行：https://github.com/aosp-mirror/platform_manifest</a></p><p>我最终选的是android11-release</p><h2 id="2-2-Compile-AOSP"><a href="#2-2-Compile-AOSP" class="headerlink" title="2.2 Compile AOSP"></a>2.2 Compile AOSP</h2><p>这里主要参考了：<a href="https://gitee.com/SidneyGod/ImagePlace/blob/master/attachments/exercises-210203.pdf">https://gitee.com/SidneyGod/ImagePlace/blob/master/attachments/exercises-210203.pdf</a></p><p>关于Android源码的下载，由于墙的原因，必然只能找镜像的，清华源，北外源，中科大源都是ok的</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">AOSP | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p><a href="https://mirrors.bfsu.edu.cn/help/AOSP/">AOSP | 镜像站使用帮助 | 北京外国语大学开源软件镜像站 | BFSU Open Source Mirror</a></p><p><a href="http://mirrors.ustc.edu.cn/help/aosp.html">AOSP 镜像使用帮助 — USTC Mirror Help 文档</a></p><p>建议repo啥的，直接都用这些源提供的就好</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这就不解释了 直接加到PATH里面就好了</span></span><br><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo</span><br><span class="line"><span class="built_in">chmod</span> +x repo</span><br><span class="line"><span class="comment"># 创建aosp目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/FuckSourceCode/1-android11-release</span><br><span class="line"><span class="built_in">cd</span> ~/FuckSourceCode/1-android11-release</span><br><span class="line"><span class="comment">## 这里一定要加--depth=1，省点空间，还快一点</span></span><br><span class="line">repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android11-release --depth=1 --no-tags</span><br><span class="line"><span class="comment">## -j4就可以了 太多会被服务器拉黑的</span></span><br><span class="line">repo <span class="built_in">sync</span> -j4 --fail-fast --force-sync</span><br><span class="line"><span class="comment">## 然后就是常规的编译</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch aosp_x86_64-eng</span><br><span class="line">make -j4</span><br><span class="line"><span class="comment"># 经过漫长的几把王者荣耀 编译完成 展示一下主要的东西</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android11-release$ <span class="built_in">ls</span> out/target/product/generic_x86_64/ -la</span><br><span class="line">total 6757124</span><br><span class="line">drwxr-xr-x 20 sidney sidney       4096 Jun 12 22:07 .</span><br><span class="line">drwxr-xr-x  3 sidney sidney       4096 Jun  6 17:00 ..</span><br><span class="line">-rw-r--r--  1 sidney sidney        356 Jun 12 22:07 VerifiedBootParams.textproto</span><br><span class="line">-rw-r--r--  1 sidney sidney        383 Jun  6 17:06 advancedFeatures.ini</span><br><span class="line">-rw-r--r--  1 sidney sidney   18874368 Jun  6 17:06 encryptionkey.img</span><br><span class="line">-rw-r--r--  1 sidney sidney   14157728 Jun 12 22:03 kernel-ranchu</span><br><span class="line">-rw-r--r--  1 sidney sidney    2927776 Jun 12 22:03 ramdisk-qemu.img</span><br><span class="line">drwxr-xr-x 15 sidney sidney       4096 Jun 12 22:05 system</span><br><span class="line">-rw-r--r--  1 sidney sidney 3232759808 Jun 12 22:08 system-qemu.img</span><br><span class="line">-rw-r--r--  1 sidney sidney  576716800 Jun 12 22:03 userdata.img</span><br><span class="line">-rw-r--r--  1 sidney sidney   68157440 Jun 12 22:05 vendor-qemu.img</span><br></pre></td></tr></table></figure><p>编译完了当然要看看咱们的成果了，由于咱是在WSL里面弄的，肯定不能敲一个emulator命令了事</p><p>首先，它需要一个模拟器，去下载Android Studio并且创建一个模拟器，这一部不详细说了</p><p>比如我这里创建的模拟器和下载的image是</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; emulator <span class="literal">-list-avds</span></span><br><span class="line">Pixel_3_Edited_API_30</span><br><span class="line"><span class="comment"># 不带playstore的</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\Sidney&gt; <span class="built_in">ls</span> D:\Develop\Environments\sdk\system<span class="literal">-images</span>\android<span class="literal">-30</span>\google_apis\x86_64\</span><br><span class="line"></span><br><span class="line">    目录: D:\Develop\Environments\sdk\system<span class="literal">-images</span>\android<span class="literal">-30</span>\google_apis\x86_64</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                 <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line">d<span class="literal">-----</span>          <span class="number">2021</span>/<span class="number">6</span>/<span class="number">7</span>     <span class="number">22</span>:<span class="number">09</span>                <span class="keyword">data</span></span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>            <span class="number">383</span> advancedFeatures.ini</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>           <span class="number">2271</span> build.prop</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>       <span class="number">18874368</span> encryptionkey.img</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>       <span class="number">14157728</span> kernel<span class="literal">-ranchu</span></span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2021</span>/<span class="number">6</span>/<span class="number">7</span>     <span class="number">22</span>:<span class="number">09</span>        <span class="number">2984443</span> NOTICE.txt</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2021</span>/<span class="number">6</span>/<span class="number">7</span>     <span class="number">22</span>:<span class="number">09</span>          <span class="number">18153</span> package.xml</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>        <span class="number">2927776</span> ramdisk.img</span><br><span class="line"><span class="literal">-a----</span>          <span class="number">2021</span>/<span class="number">6</span>/<span class="number">7</span>     <span class="number">22</span>:<span class="number">09</span>            <span class="number">294</span> source.properties</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>     <span class="number">3232759808</span> system.img</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>      <span class="number">576716800</span> userdata.img</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>       <span class="number">68157440</span> vendor.img</span><br><span class="line"><span class="literal">-a----</span>         <span class="number">2021</span>/<span class="number">6</span>/<span class="number">12</span>     <span class="number">22</span>:<span class="number">08</span>            <span class="number">356</span> VerifiedBootParams.textproto</span><br></pre></td></tr></table></figure><p>可以看到核心也就这么几个文件，把这些文件备份一下，拷入我们编译出来的image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忘了说，其实对于宿主机win10的磁盘都是以挂载的形式存在于wsl中的 所以直接cp过去就完了</span></span><br><span class="line"><span class="comment"># 这里要注意 有qemu的image就用qemu的，bootimage是kernel-ranchu</span></span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/VerifiedBootParams.textproto /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/advancedFeatures.ini /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/encryptionkey.img /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/kernel-ranchu /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/ramdisk-qemu.img /mnt/d/Develop/Android/MySystemImg/ramdisk.img</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/system-qemu.img /mnt/d/Develop/Android/MySystemImg/system.img</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/userdata.img /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/vendor-qemu.img /mnt/d/Develop/Android/MySystemImg/vendor.img</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/system/build.prop /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝完了 理论上咱编的system就能起来了</span></span><br><span class="line">emulator -avd Pixel_3_Edited_API_30 -writable-system -wipe-data -show-kernel -skip-adb-auth -no-cache</span><br></pre></td></tr></table></figure><p>看一下，效果还是可以的</p><p><img data-src="/assets/Compile-Android-11-with-WSL2/20210613231943.png"></p><p>只不过这里的kernel其实是源码里自带的，没有源码，所以略显僵硬，注意这里的内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Sidney&gt;adb shell</span><br><span class="line">generic_x86_64:/ # cat /proc/version</span><br><span class="line">Linux version 5.4.47-01061-g22e35a1de440 (android-build@abfarm-east4-070) (Android (6443078 based on r383902) clang version 11.0.1 (https://android.googlesource.com/toolchain/llvm-project b397f81060ce6d701042b782172ed13bee898b79), LLD 11.0.1 (/buildbot/tmp/tmp6_m7QH b397f81060ce6d701042b782172ed13bee898b79)) #1 SMP PREEMPT Fri Jun 19 01:58:49 UTC 2020</span><br></pre></td></tr></table></figure><p>下面继续整个内核源码</p><h2 id="2-3-Compile-Kernel"><a href="#2-3-Compile-Kernel" class="headerlink" title="2.3 Compile Kernel"></a>2.3 Compile Kernel</h2><p>貌似从Android11开始，内核整了个gki，<a href="https://source.android.google.cn/devices/architecture/kernel/android-common?hl=zh-cn">Android 通用内核</a></p><p>关于内核的版本我选择了与参考文档不一样的版本，不是common-android11-5.4，而是common-android-mainline，毕竟根据Android官方文档介绍，common-android-mainline看起来才是祖宗，于是乎</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sidney@SidneyGod:~/FuckSourceCode$ <span class="built_in">mkdir</span> 2-common-android-mainline</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode$ <span class="built_in">cd</span> 2-common-android-mainline</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ repo init -u http://mirrors.tuna.tsinghua.edu.cn/git/AOSP/kernel/manifest -b common-android11-5.4 --depth=1</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ repo <span class="built_in">sync</span> -j4</span><br></pre></td></tr></table></figure><p>代码下载完成后，并不能直接进行编译，而是需要改一个地方</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ cd common</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline/common$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/arch/x86/configs/gki_defconfig b/arch/x86/configs/gki_defconfig</span></span><br><span class="line"><span class="comment">index d120cc284..9147503b3 100644</span></span><br><span class="line"><span class="comment">--- a/arch/x86/configs/gki_defconfig</span></span><br><span class="line"><span class="comment">+++ b/arch/x86/configs/gki_defconfig</span></span><br><span class="line"><span class="meta">@@ -1,5 +1,5 @@</span></span><br><span class="line"> CONFIG_LOCALVERSION=&quot;-mainline&quot;</span><br><span class="line"><span class="deletion">-CONFIG_KERNEL_LZ4=y</span></span><br><span class="line"><span class="addition">+CONFIG_KERNEL_BZIP2=y</span></span><br><span class="line"># CONFIG_USELIB is not set</span><br><span class="line"> CONFIG_AUDIT=y</span><br><span class="line"> CONFIG_NO_HZ=y</span><br></pre></td></tr></table></figure><p>貌似是因为Ubuntu18不支持LZ4打包，改成BZIP2就可以了，于是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这两句其实编译得还算挺快的了</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ SKIP_MRPROPER=1 BUILD_CONFIG=common/build.config.gki.x86_64 build/build.sh</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ SKIP_MRPROPER=1 BUILD_CONFIG=common-modules/virtual-device/build.config.virtual_device.x86_64 build/build.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完了之后呢 回到刚才的android11-release目录 把源码自带的kernel备份一下</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ <span class="built_in">cd</span> ../1-android11-release</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode//1-android11-release$ <span class="built_in">cp</span> prebuilts/qemu-kernel/x86_64/5.4 prebuilts/qemu-kernel/x86_64/5.4.bak</span><br><span class="line"><span class="comment"># 再回到kernel目录</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android11-release$ <span class="built_in">cd</span> ../2-common-android-mainline</span><br><span class="line"><span class="comment"># 把android11-release中kernel的东西删掉</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ <span class="built_in">rm</span> -rf ../1-android11-release/prebuilts/qemu-kernel/x86_64/5.4/kernel-qemu2</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ <span class="built_in">rm</span> -rf ../1-android11-release/prebuilts/qemu-kernel/x86_64/5.4/ko/*</span><br><span class="line"><span class="comment"># 将刚刚编译好的kernel拷贝到android11-release中</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ <span class="built_in">cp</span> out/android-mainline/dist/bzImage /home/sidney/FuckSourceCode/1-android11-release/prebuilts/qemu-kernel/x86_64/5.4/kernel-qemu2</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ out/android-mainline/dist/*.ko /home/sidney/FuckSourceCode/1-android11-release/prebuilts/qemu-kernel/x86_64/5.4/ko/</span><br><span class="line"><span class="comment"># 再回到android11-release目录 整编一下aosp</span></span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/2-common-android-mainline$ <span class="built_in">cd</span> ../1-android11-release</span><br><span class="line">sidney@SidneyGod:~/FuckSourceCode/1-android11-release$ make -j4</span><br></pre></td></tr></table></figure><p>最后的步骤当然和前面的一摸一样了，把编译出来的image拷贝到宿主机中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里要注意 不要漏任何一个image 否则总会有一些奇奇怪怪的错误出现</span></span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/VerifiedBootParams.textproto /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/advancedFeatures.ini /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/encryptionkey.img /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/kernel-ranchu /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/ramdisk-qemu.img /mnt/d/Develop/Android/MySystemImg/ramdisk.img</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/system-qemu.img /mnt/d/Develop/Android/MySystemImg/system.img</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/userdata.img /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/vendor-qemu.img /mnt/d/Develop/Android/MySystemImg/vendor.img</span><br><span class="line"><span class="built_in">cp</span> out/target/product/generic_x86_64/system/build.prop /mnt/d/Develop/Android/MySystemImg/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝完了 理论上咱编的system就能起来了</span></span><br><span class="line">emulator -avd Pixel_3_Edited_API_30 -writable-system -wipe-data -show-kernel -skip-adb-auth -no-cache</span><br></pre></td></tr></table></figure><p>再上效果图</p><p><img data-src="/assets/Compile-Android-11-with-WSL2/20210614010437.png" alt="20210614010437"></p><p>再看看这里的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Sidney&gt;adb shell</span><br><span class="line">generic_x86_64:/ <span class="comment"># cat /proc/version</span></span><br><span class="line">Linux version 5.13.0-rc5-mainline-g9c2efcb127bb-dirty (build-user@build-host) (Android (7284624, based on r416183b) clang version 12.0.5 (https://android.googlesource.com/toolchain/llvm-project c935d99d7cf2016289302412d708641d52d2f7ee), LLD 12.0.5 (/buildbot/src/android/llvm-toolchain/out/llvm-project/lld c935d99d7cf2016289302412d708641d52d2f7ee)) <span class="comment">#1 SMP PREEMPT Wed Jun 9 12:52:23 UTC 2021</span></span><br></pre></td></tr></table></figure><p>到这里就说明成功了，至此，kernel和system都可以顺利编译了</p><p>另外，如果拷贝完image到宿主机后，发现无法开机，并报下面的错，那可能是image没编好，kernel不适配，重新整编一下就好了</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[    <span class="number">1.785501</span>] init: Failed to insmod &#x27;/lib/modules/dummy-cpufreq.ko&#x27; with args &#x27;&#x27;</span><br><span class="line">[    <span class="number">1.789747</span>] init: LoadWithAliases was unable to <span class="keyword">load</span> dummy_cpufreq</span><br><span class="line">[    <span class="number">1.793175</span>] init: [libfs_mgr]ReadFstabFromDt(): failed to <span class="keyword">read</span> fstab from dt</span><br><span class="line">[    <span class="number">1.797138</span>] init: Using Android DT directory /<span class="keyword">proc</span>/device-tree/firmware/android/</span><br><span class="line">[    1.824079]<span class="title"> init:</span> bool<span class="title"> android::init::BlockDevInitializer::InitDevices(std::set&lt;std::string&gt;):</span> partition(s)<span class="title"> not</span> found<span class="title"> in</span> /sys,<span class="title"> waiting</span> for<span class="title"> their</span> uevent(s):<span class="title"> metadata,</span> super,<span class="title"> vbmeta</span></span><br><span class="line">[   11.844727]<span class="title"> init:</span> Wait<span class="title"> for</span> partitions<span class="title"> returned</span> after 10011ms</span><br><span class="line">[   11.848915]<span class="title"> init:</span> bool<span class="title"> android::init::BlockDevInitializer::InitDevices(std::set&lt;std::string&gt;):</span> partition(s)<span class="title"> not</span> found<span class="title"> after</span> polling<span class="title"> timeout:</span> metadata,<span class="title"> super,</span> vbmeta</span><br><span class="line">[   11.855918]<span class="title"> init:</span> Failed<span class="title"> to</span> mount<span class="title"> required</span> partitions<span class="title"> early</span> ...</span><br><span class="line">[   11.859722]<span class="title"> init:</span> InitFatalReboot:<span class="title"> signal</span> 6</span><br></pre></td></tr></table></figure><h1 id="Android12编译后起不来"><a href="#Android12编译后起不来" class="headerlink" title="Android12编译后起不来"></a>Android12编译后起不来</h1><p>首先AndroidS和AndroidR的操作基本没啥区别，只不过lunch时候的选项可能需要改一下，因为用<code>aosp_x86_64-eng</code>编译完成后没有qemu的image和<code>userdata.img</code>，就像stack overflow上这样<a href="https://stackoverflow.com/questions/69553871/android-12-latest-release-emulator-build-not-running-for-android-12-0-0-r2-aosp/69780243#69780243">android 12 latest release: Emulator build not running for android-12.0.0_r2 aosp release - Stack Overflow</a></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>out/target/product/generic_arm64/userdata-qemu.img&#x27;: No such file or directory</span><br></pre></td></tr></table></figure><p>解决方案我也贴上去了，就是需要在<code>build/make/target/product/AndroidProducts.mk</code>下面加一句</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/target/product/AndroidProducts.mk b/target/product/AndroidProducts.mk</span></span><br><span class="line"><span class="comment">index 7d9d90e..419cccb 100644</span></span><br><span class="line"><span class="comment">--- a/target/product/AndroidProducts.mk</span></span><br><span class="line"><span class="comment">+++ b/target/product/AndroidProducts.mk</span></span><br><span class="line"><span class="meta">@@ -84,3 +84,4 @@</span> COMMON_LUNCH_CHOICES := \</span><br><span class="line">     aosp_arm-eng \</span><br><span class="line">     aosp_x86_64-eng \</span><br><span class="line">     aosp_x86-eng \</span><br><span class="line"><span class="addition">+    sdk_phone_x86_64-eng \</span></span><br></pre></td></tr></table></figure><p>然后lunch的时候选择<code>sdk_phone_x86_64-eng</code>就好了..</p><h1 id="Android12-kernel无效"><a href="#Android12-kernel无效" class="headerlink" title="Android12 kernel无效"></a>Android12 kernel无效</h1><p>Android12的kernel不在<code>prebuilts/qemu-kernel/x86_64/</code>，这里面也没有5.10，而是在</p><p><code>kernel/prebuilts/5.10/x86_64/kernel-5.10</code>和<code>kernel/prebuilts/common-modules/virtual-device/5.10/x86-64/*.ko</code>，对应的bzImage和ko文件挪到这里就好了，注意不要把bp文件给删了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;手里就一台笔记本，可不想把系统换成Linux的，毕竟有很多操作还是很不方便，但是又想学习学习Android源码，所以，总得找点什么凑活着用的办法，于是我把目光放到了Win10上的Linux子系统上了，也就是WSL，毕竟虚拟机太废内存划不来，亲测&lt;/p&gt;
&lt;p&gt;CPU：AMD Ryzen 7 4800H with Radeon Graphics 2.90 GHz&lt;/p&gt;
&lt;p&gt;RAM：16G&lt;/p&gt;
&lt;p&gt;ROM：512G SSD + 2T HDD&lt;/p&gt;
&lt;p&gt;GPU：GTX 1650&lt;/p&gt;
&lt;p&gt;跑起来不说多么流畅，反正不卡，可能编译慢点，咱也不差那点时间，硬盘预留个256G的空间就够了。话不多说，记录一下这次操作的经历..&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://sidneyding.cn/categories/OS/"/>
    
    <category term="Android" scheme="https://sidneyding.cn/categories/OS/Android/"/>
    
    
    <category term="WSL" scheme="https://sidneyding.cn/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>[Relearning C/Cpp] Supplement</title>
    <link href="https://sidneyding.cn/posts/c8ed763e/"/>
    <id>https://sidneyding.cn/posts/c8ed763e/</id>
    <published>2021-05-05T09:40:29.000Z</published>
    <updated>2021-12-26T15:07:58.246Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记主要是对C&#x2F;Cpp一些知识的补充，这篇笔记过后就是抽象机制以及一些库函数的学习了</p><h1 id="1-源文件与程序"><a href="#1-源文件与程序" class="headerlink" title="1 源文件与程序"></a>1 源文件与程序</h1><p>一个C语言文件到可执行文件，中间经历了什么？预处理(Preprocessing)、编译(Compilation)、汇编(Assemble)、链接(Linking)。这是耳熟能详的几个过程，甚至还能敲出对应的gcc命令，那么实际上到底是啥情况呢？比如现在有个C程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>敲出gcc的命令：<code>gcc main.c -o main.o -v</code></p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@SidneyDing hello]<span class="comment"># gcc main.c -o main.o -v</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper</span><br><span class="line">Target: x86_64-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC)</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;main.o&#x27;</span> <span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -quiet -v main.c -quiet -dumpbase main.c -mtune=generic -march=x86-64 -auxbase main -version -o /tmp/cc8LaNsi.s</span><br><span class="line">GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-36) (x86_64-redhat-linux)</span><br><span class="line">        compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-36), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1</span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">ignoring nonexistent directory <span class="string">&quot;/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include-fixed&quot;</span></span><br><span class="line">ignoring nonexistent directory <span class="string">&quot;/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/include&quot;</span></span><br><span class="line"><span class="comment">#include &quot;...&quot; search starts here:</span></span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br><span class="line">GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-36) (x86_64-redhat-linux)</span><br><span class="line">        compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-36), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1</span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">Compiler executable checksum: c0b461ba69dba093bfc939a7fa8b7724</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;main.o&#x27;</span> <span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> as -v --64 -o /tmp/ccqhVoX2.o /tmp/cc8LaNsi.s</span><br><span class="line">GNU assembler version 2.27 (x86_64-redhat-linux) using BFD version version 2.27-34.base.el7</span><br><span class="line">COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-o&#x27;</span> <span class="string">&#x27;main.o&#x27;</span> <span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../.. /tmp/ccqhVoX2.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crtn.o</span><br><span class="line">[root@SidneyDing hello]<span class="comment"># ls</span></span><br><span class="line">main.c  main.o</span><br></pre></td></tr></table></figure><p>看起来好像挺乱的，我们拆分一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 main.c -o /tmp/cc8LaNsi.s  <span class="comment"># 第10行，预处理 + 编译</span></span><br><span class="line">as -o /tmp/ccqhVoX2.o /tmp/cc8LaNsi.s  <span class="comment"># 第27行，汇编</span></span><br><span class="line">/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 \</span><br><span class="line">  -dynamic-linker /lib64/ld-linux-x86-64.so.2 \</span><br><span class="line">  -o main.out \</span><br><span class="line">     /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crt1.o \</span><br><span class="line">     /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crti.o \</span><br><span class="line">     /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o \</span><br><span class="line">     /tmp/ccqhVoX2.o \</span><br><span class="line">  -lc /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o \</span><br><span class="line">     /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crtn.o  <span class="comment"># 第32行，链接</span></span><br></pre></td></tr></table></figure><p>其中呢，cc1可以再拆分为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpp -o main.i main.c  <span class="comment"># 预编译 一般语法检查阶段</span></span><br><span class="line">/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 main.i -o /tmp/ccMDBkDo.s  <span class="comment"># 编译</span></span><br></pre></td></tr></table></figure><p>这时候，你可能在怀疑，这些命令真的有用？我们来一个伪<code>makefile.sh</code>试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.i</span></span><br><span class="line">cpp -o main.i main.c; <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># main.s</span></span><br><span class="line">/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -o main.s main.i; <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># main.o</span></span><br><span class="line">as -o main.o main.s; <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># main.out</span></span><br><span class="line">/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 \</span><br><span class="line">   -dynamic-linker /lib64/ld-linux-x86-64.so.2 \</span><br><span class="line">   -o main.out \</span><br><span class="line">      /usr/lib64/crt1.o \</span><br><span class="line">      /usr/lib64/crti.o \</span><br><span class="line">      /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o \</span><br><span class="line">      main.o \</span><br><span class="line">   -lc /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o \</span><br><span class="line">      /usr/lib64/crtn.o; <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># .clean</span></span><br><span class="line"><span class="comment"># rm -rf main.i main.s main.o main.out</span></span><br></pre></td></tr></table></figure><p>这么一运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@SidneyDing hello]<span class="comment"># bash makefile.sh</span></span><br><span class="line">main.c  main.i  makefile.sh</span><br><span class="line"> main</span><br><span class="line">Analyzing compilation unit</span><br><span class="line">Performing interprocedural optimizations</span><br><span class="line"> &lt;*free_lang_data&gt; &lt;visibility&gt; &lt;early_local_cleanups&gt; &lt;*free_inline_summary&gt; &lt;whole-program&gt;Assembling <span class="built_in">functions</span>:</span><br><span class="line"> main</span><br><span class="line">Execution <span class="built_in">times</span> (seconds)</span><br><span class="line"> phase setup             :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (50%) wall    1094 kB (74%) ggc</span><br><span class="line"> phase parsing           :   0.00 ( 0%) usr   0.01 (100%) sys   0.01 (50%) wall     329 kB (22%) ggc</span><br><span class="line"> parser (global)         :   0.00 ( 0%) usr   0.01 (100%) sys   0.01 (50%) wall     287 kB (20%) ggc</span><br><span class="line"> TOTAL                 :   0.00             0.01             0.02               1472 kB</span><br><span class="line">main.c  main.i  main.s  makefile.sh</span><br><span class="line">main.c  main.i  main.o  main.s  makefile.sh</span><br><span class="line">main.c  main.i  main.o  main.out  main.s  makefile.sh</span><br><span class="line">[root@SidneyDing hello]<span class="comment"># ./main.out</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>瞅瞅，是不是就是那么回事~</p><p>从这件事中，我们学到了，从源文件到可执行程序需要经历：<strong>C源程序 &gt; 预编译处理 &gt; 编译 &gt; 优化程序 &gt; 汇编程序 &gt; 链接程序 &gt; 可执行文件</strong></p><p><code>main.i</code>是预处理后的文件，把所有要包含的(include)文件的内容递归式加到原始C文件中，再输出到<code>main.i</code>中，除此之外，还展开了所有的宏定义，所以在<code>main.i</code>中看不到任何的宏</p><p><code>main.s</code>是编译后的文件，就是将C转换为汇编代码</p><p><code>main.o</code>是汇编后的文件，就是将上面的汇编代码翻译成符合一定格式的机器代码，在Linux上一般表现为ELF目标文件(通过<code>file main.o</code>查看得知)</p><p><code>main.out</code>是链接后的文件，将上步的目标文件与系统的目标文件，库文件链接起来，最后生成在特定平台运行的可执行文件。</p><p>为什么要链接库文件(<code>crt1.o crti.o</code>)？这些目标文件都是用来初始化或者回收C运行时环境的，比如说堆内存分配，上下文环境的初始化等，实际上crt就是C Runtime的所写。这也暗示了另一点，程序并不是从main开始执行的，而是从crt中某个入口开始的，在Linux上此入口是<code>_start</code>。</p><p>探究程序的入口可能对于进程怎么诞生有点好处，参考：<a href="https://mp.weixin.qq.com/s/YsqoIfFZkHw1pEzsdkfo9Q">从创建进程到进入main函数，发生了什么？ (qq.com)</a></p><p>我的目的只是<strong>简单</strong>熟悉一下Makefile，不说会写吧，至少能看懂写的啥..</p><h1 id="2-GNU-Makefile"><a href="#2-GNU-Makefile" class="headerlink" title="2 GNU Makefile"></a>2 GNU Makefile</h1><p>参考：</p><p><a href="https://www.gnu.org/software/make/manual/make.html">GNU make</a> – 官方文档</p><p><a href="https://seisman.github.io/how-to-write-makefile/Makefile.pdf">Makefile.pdf (seisman.github.io)</a> – 感觉是官方文档的翻译..</p><p>比如将上面的伪makefile改成真正的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">all: main.out</span></span><br><span class="line"><span class="section">main.out: main.o</span></span><br><span class="line">ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 \</span><br><span class="line">-o main.out \</span><br><span class="line">/usr/lib64/crt1.o \</span><br><span class="line">/usr/lib64/crti.o \</span><br><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o \</span><br><span class="line">main.o \</span><br><span class="line">-lc /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o \</span><br><span class="line">/usr/lib64/crtn.o</span><br><span class="line"><span class="section">main.o: main.s</span></span><br><span class="line">as -o main.o main.s</span><br><span class="line"><span class="section">main.s: main.i</span></span><br><span class="line">/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -o main.s main.i</span><br><span class="line"><span class="section">main.i: main.c</span></span><br><span class="line">cpp -o main.i main.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf main.i main.s main.o main.out</span><br></pre></td></tr></table></figure><p>然后执行make相关命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@SidneyDing hello]<span class="comment"># make</span></span><br><span class="line">cpp -o main.i main.c</span><br><span class="line">/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -o main.s main.i</span><br><span class="line"> main</span><br><span class="line">Analyzing compilation unit</span><br><span class="line">Performing interprocedural optimizations</span><br><span class="line"> &lt;*free_lang_data&gt; &lt;visibility&gt; &lt;early_local_cleanups&gt; &lt;*free_inline_summary&gt; &lt;whole-program&gt;Assembling <span class="built_in">functions</span>:</span><br><span class="line"> main</span><br><span class="line">Execution <span class="built_in">times</span> (seconds)</span><br><span class="line"> phase setup             :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (50%) wall    1094 kB (74%) ggc</span><br><span class="line"> phase parsing           :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (50%) wall     329 kB (22%) ggc</span><br><span class="line"> phase opt and generate  :   0.00 ( 0%) usr   0.01 (100%) sys   0.00 ( 0%) wall      32 kB ( 2%) ggc</span><br><span class="line"> parser (global)         :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (50%) wall     287 kB (20%) ggc</span><br><span class="line"> <span class="built_in">expand</span>                  :   0.00 ( 0%) usr   0.01 (100%) sys   0.00 ( 0%) wall       2 kB ( 0%) ggc</span><br><span class="line"> TOTAL                 :   0.00             0.01             0.02               1472 kB</span><br><span class="line">as -o main.o main.s</span><br><span class="line">ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 \</span><br><span class="line">-o main.out \</span><br><span class="line">        /usr/lib64/crt1.o \</span><br><span class="line">        /usr/lib64/crti.o \</span><br><span class="line">        /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o \</span><br><span class="line">        main.o \</span><br><span class="line">-lc /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o \</span><br><span class="line">        /usr/lib64/crtn.o</span><br><span class="line">[root@SidneyDing hello]<span class="comment"># ls</span></span><br><span class="line">main.c  main.i  main.o  main.out  main.s  Makefile  makefile.sh</span><br><span class="line">[root@SidneyDing hello]<span class="comment"># ./main.out</span></span><br><span class="line">Hello World!</span><br><span class="line">[root@SidneyDing hello]<span class="comment"># make clean</span></span><br><span class="line"><span class="built_in">rm</span> -rf main.i main.s main.o main.out</span><br><span class="line">[root@SidneyDing hello]<span class="comment"># ls</span></span><br><span class="line">main.c  Makefile  makefile.sh</span><br><span class="line">[root@SidneyDing hello]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>make怎么工作的？</strong></p><p>一般情况下，当输入make命令时，</p><blockquote><p>1 make 会在当前目录下找名字叫“Makefile”或“makefile”的文件</p><p>2 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“all”这个文<br>件，并把这个文件作为最终的目标文件。</p><p>3 如果 all 文件不存在，或是 all 所依赖的后面的 .o 文件的文件修改时间要比 all 这个文件新， 那么，他就会执行后面所定义的命令来生成 all 这个文件。</p><p>4 如果 all 所依赖的 .o 文件也不存在，那么 make 会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件。（这有点像一个堆栈的过程）</p><p>5 当然，你的 C 文件和 H 文件是存在的啦，于是 make 会生成 .o 文件，然后再用 .o 文件生成 make 的终极任务，也就是执行文件 all 了。</p></blockquote><p><strong>Makefile 里有什么？</strong></p><blockquote><p>1 显式规则。显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要 生成的文件、文件的依赖文件和生成的命令。</p><p>2 隐晦规则。由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由 make 所支持的。</p><p>3 变量的定义。在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 C 语 言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。</p><p>4 文件指示。其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像 C 语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译 #if 一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p><p>5 注释。Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用 # 字符，这个就像 C&#x2F;C++ 中的 &#x2F;&#x2F; 一样。如果你要在你的 Makefile 中使用 # 字符，可以用反斜杠进行转义，如：# 。</p><p>最后，还值得一提的是，在 Makefile 中的命令，必须要以 Tab 键开始。</p></blockquote><p>pdf太详细了..不抄了。多说一句可以<code>make [target]</code>，比如<code>make main.i</code></p><h1 id="3-动态分配内存"><a href="#3-动态分配内存" class="headerlink" title="3 动态分配内存"></a>3 动态分配内存</h1><p>这个和前面两个内容没有太大关系，但却是比较重要的一点。命名对象的生命周期一般由作用域决定，但是很多时候，我们希望生命周期和作用域分开，比如子函数中创建一个变量，希望在子函数执行完了，主函数中还能用。这个时候就需要将该变量放在堆(heap)上。先看C语言的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  <span class="comment">// 头文件</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">( <span class="type">size_t</span> size )</span>;  <span class="comment">// Allocates size bytes of uninitialized storage.</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">( <span class="type">size_t</span> num, <span class="type">size_t</span> size )</span>;  <span class="comment">// Allocates memory for an array of num objects of size and initializes all bytes in the allocated storage to zero.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">( <span class="type">void</span> *ptr, <span class="type">size_t</span> new_size )</span>;  <span class="comment">// Reallocates the given area of memory. It must be previously allocated by malloc(), calloc() or realloc() and not yet freed with a call to free or realloc. Otherwise, the results are undefined.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">( <span class="type">void</span>* ptr )</span>;  <span class="comment">// Deallocates the space previously allocated by malloc(), calloc(), aligned_alloc(), (since C11) or realloc().</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">aligned_alloc</span><span class="params">( <span class="type">size_t</span> alignment, <span class="type">size_t</span> size )</span>;  <span class="comment">// Allocate size bytes of uninitialized storage whose alignment is specified by alignment. The size parameter must be an integral multiple of alignment.</span></span><br></pre></td></tr></table></figure><p>偷个懒：</p><p><a href="https://en.cppreference.com/w/c/memory/malloc">malloc - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/c/memory/calloc">calloc - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/c/memory/realloc">realloc - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/c/memory/free">free - cppreference.com</a></p><p>用好malloc和free也就差不多了，这俩都是线程安全的。malloc的size是可以为0的，返回空指针。free可以传个空指针</p><p>再看Cpp，在Cpp的世界比较单纯，只有new和delete，如果是数组的话，那就new[]和delete[]，有意思的是这俩是个运算符，并且这个运算符是可以重载的..</p><p>对象泄漏：使用了new，但忘了使用delete释放对象</p><p>提前释放：</p><p>重复释放：</p><blockquote><p>Cpp的标准是有版权的，150刀左右&#x2F;每版。但是标准的草案是免费的，并且和最终版大体一样，所以找最新的草案版本也可以</p><p>Cpp11草案：<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a></p><p>Cpp14草案：<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf</a></p><p>Cpp17草案：<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf</a></p><p>Cpp20草案：<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4878.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4878.pdf</a></p><p>主要就是在<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/">C++ Standards Committee Papers (open-std.org)</a>下的年份里搜”Standard for Programming Language”，当然也有C的</p><p>这些都不重要，这辈子也精通不了Cpp，别说标准了，教材都不一定看完一本..</p></blockquote><h1 id="4-lambda表达式"><a href="#4-lambda表达式" class="headerlink" title="4 lambda表达式"></a>4 lambda表达式</h1><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> name = [capture](parameters)-&gt;return_type&#123;body&#125;;</span><br></pre></td></tr></table></figure><p>一个可能为空的捕获列表capture，指明定义环境中的哪些名字能被用在lambda表达式内，以及这些名字的访问方式是拷贝还是引用，捕获列表位于[]内；</p><p>一个可选的参数列表parameters，指明lambda表达式所需要的参数，参数列表位于()内；</p><p>一个可选的mutable修饰符，指明该lambda表达式可能会修改它自身状态，修改按值捕获的外部变量；</p><p>一个可选的noexception修饰符；</p><p>一个可选的 -&gt; 形式的返回类型声明；</p><p>一个表达式体body，指明要执行的代码，表达式体位于{}内</p><p><strong>捕获</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// auto f1 = []&#123; return a; &#125;;  // error，没有捕获外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]&#123; <span class="keyword">return</span> a++; &#125;;  <span class="comment">// OK，捕获所有外部变量，并对a执行自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]&#123; <span class="keyword">return</span> a; &#125;;  <span class="comment">// OK，捕获所有外部变量，并返回a</span></span><br><span class="line"><span class="comment">// auto f4 = [=]&#123; return a++; &#125;;  // error，a是以复制方式捕获的，无法修改</span></span><br><span class="line"><span class="comment">// auto f5 = [a]&#123; return a + b; &#125;;  // error，没有捕获变量b</span></span><br><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获a和b的引用，并对b做自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f7 = [&amp;, a]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，你懂的..</span></span><br><span class="line"><span class="keyword">auto</span> f8 = [=, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获所有外部变量和b的引用，并对b做自加运算</span></span><br></pre></td></tr></table></figure><p>一个容易出错的细节是关于 lambda 表达式的延迟调用的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]&#123; <span class="keyword">return</span> a; &#125;;      <span class="comment">// 按值捕获外部变量</span></span><br><span class="line">a += <span class="number">1</span>;                         <span class="comment">// a被修改了</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;  <span class="comment">// 输出？</span></span><br></pre></td></tr></table></figure><p>在捕获的一瞬间，a 的值就已经被复制到f中了。之后 a 被修改，但此时 f 中存储的 a 仍然还是捕获时的值，因此，最终输出结果是 0。</p><p><strong>mutable</strong></p><p>如果希望去修改按值捕获的外部变量应当怎么办呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// auto f1 = [=]&#123; return a++; &#125;;          // error，修改按值捕获的外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;  <span class="comment">// OK，mutable</span></span><br></pre></td></tr></table></figure><p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。啥叫闭包？脚本语言里面听到的贼多..就是能够访问另一个函数作用域的变量的函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记主要是对C&amp;#x2F;Cpp一些知识的补充，这篇笔记过后就是抽象机制以及一些库函数的学习了&lt;/p&gt;
&lt;h1 id=&quot;1-源文件与程序&quot;&gt;&lt;a href=&quot;#1-源文件与程序&quot; class=&quot;headerlink&quot; title=&quot;1 源文件与程序&quot;&gt;&lt;/a&gt;1 源文件与程序&lt;/h1&gt;&lt;p&gt;一个C语言文件到可执行文件，中间经历了什么？预处理(Preprocessing)、编译(Compilation)、汇编(Assemble)、链接(Linking)。这是耳熟能详的几个过程，甚至还能敲出对应的gcc命令，那么实际上到底是啥情况呢？比如现在有个C程序&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello World!\n&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;敲出gcc的命令：&lt;code&gt;gcc main.c -o main.o -v&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="https://sidneyding.cn/categories/Language/"/>
    
    <category term="C/Cpp" scheme="https://sidneyding.cn/categories/Language/C-Cpp/"/>
    
    
    <category term="Relearning C/Cpp" scheme="https://sidneyding.cn/tags/Relearning-C-Cpp/"/>
    
  </entry>
  
  <entry>
    <title>[Relearning C/Cpp] Initialization and Functions</title>
    <link href="https://sidneyding.cn/posts/e4de57a8/"/>
    <id>https://sidneyding.cn/posts/e4de57a8/</id>
    <published>2021-04-17T08:53:30.000Z</published>
    <updated>2022-05-24T14:58:49.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h1><p>对象的声明可以通过初始化的过程获得初始值。主要就是见识一下C&#x2F;Cpp里面几种初始化的形式，免得大惊小怪</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言的初始化还好，怎么着都得有个 =</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> c = &#123;<span class="number">1</span>&#125;;  <span class="comment">// scalar initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="type">int</span> a[<span class="number">3</span>], b;&#125; MyType;</span><br><span class="line">MyType mm = &#123;&#123;<span class="number">1</span>&#125;, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* ptr = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cpp多了一个花样</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="type">int</span> a[<span class="number">3</span>], b;&#125; MyType;</span><br><span class="line">MyType mm &#123;&#123;<span class="number">1</span>&#125;, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> *m = <span class="keyword">new</span> MyType;</span><br><span class="line"><span class="keyword">auto</span> *m1 &#123;<span class="keyword">new</span> <span class="built_in">MyType</span>()&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>对于C来说，有显示初始化(Explicit initialization)，隐式初始化(Implicit initialization)，零初始化(Zero initialization)</p><p>显示的比较好理解，<a href="https://en.cppreference.com/w/c/language/scalar_initialization">scalar initialization</a>，<a href="https://en.cppreference.com/w/c/language/array_initialization">array initialization</a>，<a href="https://en.cppreference.com/w/c/language/struct_initialization">struct initialization</a>，基本都没啥好说的，经常用</p><p>隐式初始化就是你没给它显示初始化，这个时候有两种现象，一种是静态的和thread local <a href="https://en.cppreference.com/w/c/language/storage_duration">storage duration</a>(这四个单词我的理解是整个线程生命周期都存在的对象，全局变量？)一般会置为零初始化；还有一种automatic <a href="https://en.cppreference.com/w/c/language/storage_duration">storage duration</a>(auto和register修饰的，局部变量？)一般是个不确定值(野指针)</p><p>零初始化(在内存的表现形式是0？)</p><ul><li>pointers are initialized to null pointer values of their types</li><li>objects of integral types are initialized to unsigned zero</li><li>objects of floating types are initialized to positive zero</li><li>all elements of arrays, all members of structs, and the first members of unions are zero-initialized, recursively, plus all padding bits are initialized to zero</li></ul><p>对于Cpp来说呢，有静态初始化和动态初始化一说</p><p>Depending on context, the initializer may invoke:</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/value_initialization">Value initialization</a>, e.g. <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s{};</li><li><a href="https://en.cppreference.com/w/cpp/language/direct_initialization">Direct initialization</a>, e.g. <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s(“hello”);</li><li><a href="https://en.cppreference.com/w/cpp/language/copy_initialization">Copy initialization</a>, e.g. <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s &#x3D; “hello”;</li><li><a href="https://en.cppreference.com/w/cpp/language/list_initialization">List initialization</a>, e.g. <a href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s{‘a’, ‘b’, ‘c’};</li><li><a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate initialization</a>, e.g. char a[3] &#x3D; {‘a’, ‘b’};</li><li><a href="https://en.cppreference.com/w/cpp/language/reference_initialization">Reference initialization</a>, e.g. char&amp; c &#x3D; a[0];</li></ul><p>If no initializer is provided, the rules of <a href="https://en.cppreference.com/w/cpp/language/default_initialization">default initialization</a> apply.</p><p>这里有个<a href="https://en.cppreference.com/w/cpp/language/default_initialization">default initialization</a>，还有个<a href="https://en.cppreference.com/w/cpp/language/zero_initialization">zero-initialized</a>和<a href="https://en.cppreference.com/w/cpp/language/constant_initialization">constant initialization</a></p><p>默认初始化呢，就当时默认构造函数好了。常量初始化呢，编译时期的。</p><h1 id="2-函数"><a href="#2-函数" class="headerlink" title="2 函数"></a>2 函数</h1><p>了解函数之前，得先了解语句，毕竟函数不就是把语句打包一下吗？这也是所有编程语言核心之处啊，这里不说编程语言，就说计算机语言，还是蛮简单的。赋值，选择，循环，跳转。</p><p>简单不代表容易呀</p><p>C&#x2F;Cpp中选择if和switch，循环for，while和do-while，跳转goto，还有continue，break，空语句，几乎每种编程语言都有，感觉也没啥要注意的，main函数不就是个函数，和<code>y=f(x)</code>很像啊</p><p>函数定义形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名() &#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言比较奔放 下面那就叫一个函数 CPP需要返回值类型</span></span><br><span class="line">tmp()&#123;&#125;  <span class="comment">// 适合C89，不适合C99</span></span><br></pre></td></tr></table></figure><p>Cpp的函数比较复杂一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    [[noreturn]] <span class="function"><span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> * <span class="type">const</span>)</span> -&gt; <span class="type">void</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了，一个破函数能有这么多修饰..</p><p><strong>返回值</strong></p><p>返回值这东西我们知道，一般写在函数名前面，然而Cpp总能给你来点不一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">int</span> a)</span></span>;   <span class="comment">// 前置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">to_string</span><span class="params">(<span class="type">int</span> a)</span> -&gt; string</span>;  <span class="comment">// 后置返回类型</span></span><br></pre></td></tr></table></figure><p>其中auto关键字就表示后置返回类型，后置返回类型的必要性来自于模板函数，因为返回类型依赖于参数</p><p><strong>inline和constexpr</strong></p><p>在函数声明或定义中函数返回类型前加上关键字inline即把函数指定为内联，函数固定为一个地址</p><p>关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用</p><p>定义在类声明之中的成员函数将自动地成为内联函数</p><p>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高</p><p>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大</p><p>面对constexpr，胆子大一点，直接当成常量就ok了</p><p><strong>[[noreturn]]</strong></p><p>形如<code>[[...]]</code>被称为属性，属性可以置于Cpp语法的任何位置。<code>[[noreturn]]</code>放在函数声明语句开始位置，表示我们不希望函数返回任何结果</p><h2 id="2-1-参数传递"><a href="#2-1-参数传递" class="headerlink" title="2.1 参数传递"></a>2.1 参数传递</h2><p>当程序调用一个函数时，我们为该函数的形参申请内存空间，并用实参初始化形参。参数传递的语义与初始化的语义一致(严格来说是拷贝初始化)。**C中，所有函数参数都是”值传递”；Cpp中，除非形参是引用，其他情况函数参数也都是”值传递”**。所谓值传递，就是传入函数的是实参的副本，传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中，被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本值。</p><p><strong>引用参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span>&amp; ref)</span> </span>&#123;</span><br><span class="line">    ++val;</span><br><span class="line">    ++ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用函数f时，<code>++val</code>递增的是实参的副本，<code>++ref</code>递增的是实参本身</p><p>单从拷贝的角度来考虑，如果遇到大对象时，引用传递比值传递更有效。但是此时最好将引用类型的参数声明成const的，表明只是为了效率，而非想修改对象的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Large&amp; arg)</span></span>;</span><br></pre></td></tr></table></figure><p>对于小对象使用值传递方式；</p><p>对于无需修改的大对象使用const引用传递；</p><p>如需要返回计算结果，最好使用return而非通过参数修改对象；</p><p>使用右值实现移动和转发；</p><p>如果找不到合适的对象则传递指针(用nullptr表示没有对象)；</p><p>除非万不得已，否则不要使用引用传递，传递指针它不香吗？</p><p><strong>数组参数</strong></p><p>当数组作为参数时，实际传入的是指向该数组首元素的指针。也就是说，当数组作为参数传入函数时，<code>T[]</code>会转换成<code>T*</code>，所以也就没有长度一说，如果此时对数组元素赋值，则会改变该数组元素实际值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这叫复合字面量</span></span><br><span class="line">fun((<span class="type">int</span>[]) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">fun(arr);</span><br></pre></td></tr></table></figure><p><strong>列表参数</strong></p><p>一个由{}限定的列表可以作为下述形参的实参</p><p>1 类型<code>std::initializer_list&lt;T&gt;</code>，其中列表的值能隐式地转换成T</p><p>2 能用列表中的值初始化的类型</p><p>3 T类型数组的引用，其中列表值能隐式地转换成T</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(std::initializer_list&lt;T&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    std::string str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T (&amp;&amp;r)[N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f1</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);  <span class="comment">// T是int，initializer_list大小是4</span></span><br><span class="line">    <span class="built_in">f2</span>(&#123;<span class="number">1</span>, <span class="string">&quot;cpp&quot;</span>&#125;);</span><br><span class="line">    <span class="built_in">f3</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);  <span class="comment">// T是int，N是4</span></span><br><span class="line">    <span class="built_in">f4</span>(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在二义性，则initializer_list参数的函数被优先考虑</p><p><strong>数量未定参数</strong></p><p>对于某些函数，很难明确指出调用时期望的参数数量和类型，要实现这样的接口：</p><p>1 使用可变模板，安全</p><p>2 使用initializer_list作为参数类型，安全</p><p>3 使用省略号(…)结束参数列表，不安全</p><p><strong>默认参数</strong></p><p>只能给参数列表中位置靠后的参数提供默认值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tp1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// int tp2(int a = 1, int b);  // Missing default argument on parameter &#x27;b&#x27;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tp3</span><span class="params">(<span class="type">char</span>* = <span class="literal">nullptr</span>)</span></span>;  <span class="comment">// * 和 = 之间必须有空格，否则就是 *= 了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tp4</span><span class="params">(<span class="type">int</span> = <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="comment">// int tp4(int x = 8);  // Redefinition of default argument</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tp4</span><span class="params">(<span class="type">long</span> x = <span class="number">8</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-2-函数重载"><a href="#2-2-函数重载" class="headerlink" title="2.2 函数重载"></a>2.2 函数重载</h2><p>为不同数据类型的同一种操作起同一种名字称为重载。这个概念是Cpp的，C没有。重载发生在一组重载函数集的成员内部，也就是说重载函数应该位于同一个作用域。</p><p><strong>自动重载</strong></p><p>由编译器决定使用一组函数中的某一个，主要依据实参和哪个函数形参类型最匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">long</span> l)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1L</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// print(1);  // Call to &#x27;print&#x27; is ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 精确匹配，无须类型转换或者仅需简单类型转换即可实现匹配</p><p>2 执行提升后匹配，执行了整数提升(bool转int，char转int..)</p><p>3 执行标准类型转换后实现匹配，比如int转double，double转int，<code>T*</code>转<code>void*</code></p><p>4 执行用户自定义类型的转换后实现匹配</p><p>5 使用函数声明中的省略号进行匹配</p><p><strong>手动重载</strong></p><p>为了解决自动重载的二义性，方案一，增加一个函数版本；方案二，static_cast</p><p><strong>C的重载</strong></p><p>C语言真的没法重载了？不过是不能声明同样名字的函数罢了。参考：<a href="http://locklessinc.com/articles/overloading/">http://locklessinc.com/articles/overloading/</a></p><blockquote><p>为什么Cpp可以重载而C不可以，从汇编的角度来看，Cpp汇编完了，总会在函数名字上加点什么，而C就不会</p></blockquote><p>省略号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, ...)</span>;  <span class="comment">// 着实有点僵硬，但也重载了一点，个数</span></span><br></pre></td></tr></table></figure><p>你说要重载参数类型，我觉得划不来，多写太多代码了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> param1;</span><br><span class="line">    <span class="type">int</span> param2;</span><br><span class="line">&#125; INT_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> param1;</span><br><span class="line">    <span class="type">double</span> param2;</span><br><span class="line">&#125; DOUBLE_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(ADDFUNC)</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int_add_func</span><span class="params">(<span class="type">void</span> *wParam)</span> &#123;</span><br><span class="line">    INT_PARAM *lParam = (INT_PARAM *) wParam;</span><br><span class="line">    <span class="type">int</span> res = lParam-&gt;param1 + lParam-&gt;param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">double_add_func</span><span class="params">(<span class="type">void</span> *wParam)</span> &#123;</span><br><span class="line">    DOUBLE_PARAM *lParam = (DOUBLE_PARAM *) wParam;</span><br><span class="line">    <span class="type">double</span> res = lParam-&gt;param1 + lParam-&gt;param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %f\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_func</span><span class="params">(ADDFUNC f, <span class="type">void</span> *wParam)</span> &#123;</span><br><span class="line">    f(wParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    INT_PARAM val1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    DOUBLE_PARAM val2 = &#123;<span class="number">30.5</span>, <span class="number">40.5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    add_func(int_add_func, &amp;val1);</span><br><span class="line">    add_func(double_add_func, &amp;val2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">overload_float</span><span class="params">(<span class="type">float</span> f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Use f */</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">overload_double</span><span class="params">(<span class="type">double</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Use d */</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> overload(A)\</span></span><br><span class="line"><span class="meta">    ((sizeof(A) == sizeof(float))?overload_float(A):\</span></span><br><span class="line"><span class="meta">    (sizeof(A) == sizeof(double))?overload_double(A):(void)0)</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="type">void</span> <span class="title function_">cpp_overload1</span><span class="params">(<span class="type">int</span> p1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPP One param: %d\n&quot;</span>, p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpp_overload2</span><span class="params">(<span class="type">double</span> *p1, <span class="type">const</span> <span class="type">char</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPP Two params: %p (%f) %s\n&quot;</span>, p1, *p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpp_overload3</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2, <span class="type">int</span> p3)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPP Three params: %c %d %d\n&quot;</span>, p1, p2, p3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAT(A, B) CAT2(A, B)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAT2(A, B) A ## B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpp_overload(...)\</span></span><br><span class="line"><span class="meta">    CAT(cpp_overload, COUNT_PARMS(__VA_ARGS__))(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h2 id="2-3-指针函数"><a href="#2-3-指针函数" class="headerlink" title="2.3 指针函数"></a>2.3 指针函数</h2><p>看完参数，就该瞅瞅返回值了。基础类型的返回值没啥好看的，如果函数返回值是指针，数组，结构体..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int[] getArr();  // Function cannot return array type &#x27;int []&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; MY_POINT;</span><br><span class="line"></span><br><span class="line">MY_POINT <span class="title function_">pointFun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="comment">//return (MY_POINT) &#123;x, y&#125;;  // 直接返回的话 就不会为这个函数分配栈空间了</span></span><br><span class="line">    MY_POINT mp = &#123;x + <span class="number">1</span>, y + <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pointFun: %p, %p\n&quot;</span>, &amp;(mp.x), &amp;(mp.y));</span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">getIntP</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// return (int[]) &#123;1, 2, 3&#125;;  // 可不能返回一个局部数组 会出大事的</span></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">3</span>);</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    *(p + <span class="number">1</span>) = <span class="number">11</span>;</span><br><span class="line">    *(p + <span class="number">2</span>) = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getIntP: %p, %p, %p, %p\n&quot;</span>, &amp;p, p, p + <span class="number">1</span>, p + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MY_POINT point = pointFun(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="type">int</span> *p = getIntP();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;point: %d, %d\n&quot;</span>, point.x, point.y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;intP: %d, %d, %d\n&quot;</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p, %p\n&quot;</span>, &amp;p, p, p + <span class="number">1</span>, p + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %d\n&quot;</span>, (&amp;p + <span class="number">1</span>), (<span class="type">int</span>) *(&amp;p + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %d\n&quot;</span>, &amp;(point.x), point.x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pointFun: 000000000062FDC8, 000000000062FDCC</span></span><br><span class="line"><span class="comment">getIntP: 000000000062FDC8, 0000000000E72CA0, 0000000000E72CA4, 0000000000E72CA8</span></span><br><span class="line"><span class="comment">point: 6, 8</span></span><br><span class="line"><span class="comment">intP: 10, 11, 12</span></span><br><span class="line"><span class="comment">000000000062FE10, 0000000000E72CA0, 0000000000E72CA4, 0000000000E72CA8</span></span><br><span class="line"><span class="comment">000000000062FE18, 6</span></span><br><span class="line"><span class="comment">000000000062FE18, 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>首先，C&#x2F;Cpp函数不能直接返回一个<code>int[]</code>，或许是因为不知道大小吧。返回一个结构体似乎是没有问题的，而且貌似还能返回个局部变量。返回指针自然不必说，先不说有个指针函数的概念，我返回个地址咋不行了？</p><p>汇编瞅瞅，这次为了搞得更清楚一点呢，换一个新指令<code>gcc -S -fverbose-asm -O0 -m64 RetTest.c</code>，以”.”开头指令基本是伪指令，可以删了，不用看</p><p>汇编的函数跳转过程，参考：<a href="https://blog.csdn.net/ww188/article/details/82841617">linux进程运行空间分析_ww188的专栏-CSDN博客</a></p><p>内存布局参考：<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">    .ascii &quot;pointFun: %p, %p\12\0&quot;</span><br><span class="line">pointFun:</span><br><span class="line">    # 函数建立栈空间 start</span><br><span class="line">    pushq    %rbp     #</span><br><span class="line">    movq    %rsp, %rbp     #,</span><br><span class="line">    subq    $48, %rsp     #,</span><br><span class="line">    # 函数建立栈空间 end</span><br><span class="line">    movl    %ecx, 16(%rbp)     # 把参数拿出来 x</span><br><span class="line">    movl    %edx, 24(%rbp)     # y</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = &#123;x + 1, y + 2&#125;;</span><br><span class="line">    movl    16(%rbp), %eax     # x, tmp91</span><br><span class="line">    addl    $1, %eax     #, _1</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = &#123;x + 1, y + 2&#125;;</span><br><span class="line">    movl    %eax, -8(%rbp)     # _1, mp.x</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = &#123;x + 1, y + 2&#125;;</span><br><span class="line">    movl    24(%rbp), %eax     # y, tmp92</span><br><span class="line">    addl    $2, %eax     #, _2</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = &#123;x + 1, y + 2&#125;;</span><br><span class="line">    movl    %eax, -4(%rbp)     # _2, mp.y</span><br><span class="line"> # RetTest.c:17:     printf(&quot;pointFun: %p, %p\n&quot;, &amp;(mp.x), &amp;(mp.y));</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp93</span><br><span class="line">    leaq    4(%rax), %rdx     #, tmp94</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp95</span><br><span class="line">    movq    %rdx, %r8     # tmp94,</span><br><span class="line">    movq    %rax, %rdx     # tmp95,</span><br><span class="line">    leaq    .LC0(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:18:     return mp;</span><br><span class="line">    movq    -8(%rbp), %rax     # 把返回值放到rax中</span><br><span class="line"> # RetTest.c:19: &#125;</span><br><span class="line">    addq    $48, %rsp     # 上面为这个函数开辟了48字节 现在收回去</span><br><span class="line">    popq    %rbp     # 把当前rsp的值给rbp，此时rbp就是main的了，rsp再回去一个单位，还不是main的样子</span><br><span class="line">    ret     # 先把rsp的值给rip，rip就指向了main调用函数的那块了，rsp再回去一个单位，是main的样子了</span><br><span class="line">.LC1:</span><br><span class="line">    .ascii &quot;getIntP: %p, %p, %p, %p\12\0&quot;</span><br><span class="line">getIntP:</span><br><span class="line">    pushq    %rbp     #</span><br><span class="line">    movq    %rsp, %rbp     #,</span><br><span class="line">    subq    $64, %rsp     #,</span><br><span class="line"> # RetTest.c:23:     int *p = (int *) malloc(sizeof(int) * 3);</span><br><span class="line">    movl    $12, %ecx     #,</span><br><span class="line">    call    malloc     #</span><br><span class="line"> # RetTest.c:23:     int *p = (int *) malloc(sizeof(int) * 3);</span><br><span class="line">    movq    %rax, -8(%rbp)     # _1, p</span><br><span class="line"> # RetTest.c:24:     *p = 10;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.0_2</span><br><span class="line"> # RetTest.c:24:     *p = 10;</span><br><span class="line">    movl    $10, (%rax)     #, *p.0_2</span><br><span class="line"> # RetTest.c:25:     *(p + 1) = 11;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.1_3</span><br><span class="line">    addq    $4, %rax     #, _4</span><br><span class="line"> # RetTest.c:25:     *(p + 1) = 11;</span><br><span class="line">    movl    $11, (%rax)     #, *_4</span><br><span class="line"> # RetTest.c:26:     *(p + 2) = 12;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.2_5</span><br><span class="line">    addq    $8, %rax     #, _6</span><br><span class="line"> # RetTest.c:26:     *(p + 2) = 12;</span><br><span class="line">    movl    $12, (%rax)     #, *_6</span><br><span class="line"> # RetTest.c:27:     printf(&quot;getIntP: %p, %p, %p, %p\n&quot;, &amp;p, p, p + 1, p + 2);</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.3_7</span><br><span class="line">    leaq    8(%rax), %rdx     #, _8</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.4_9</span><br><span class="line">    leaq    4(%rax), %r8     #, _10</span><br><span class="line">    movq    -8(%rbp), %rcx     # p, p.5_11</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp101</span><br><span class="line">    movq    %rdx, 32(%rsp)     # _8,</span><br><span class="line">    movq    %r8, %r9     # _10,</span><br><span class="line">    movq    %rcx, %r8     # p.5_11,</span><br><span class="line">    movq    %rax, %rdx     # tmp101,</span><br><span class="line">    leaq    .LC1(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:28:     return p;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, _19</span><br><span class="line"> # RetTest.c:29: &#125;</span><br><span class="line">    addq    $64, %rsp     #,</span><br><span class="line">    popq    %rbp     #</span><br><span class="line">    ret    </span><br><span class="line">.LC2:</span><br><span class="line">    .ascii &quot;point: %d, %d\12\0&quot;</span><br><span class="line">.LC3:</span><br><span class="line">    .ascii &quot;intP: %d, %d, %d\12\0&quot;</span><br><span class="line">.LC4:</span><br><span class="line">    .ascii &quot;%p, %p, %p, %p\12\0&quot;</span><br><span class="line">.LC5:</span><br><span class="line">    .ascii &quot;%p, %d\12\0&quot;</span><br><span class="line">main:</span><br><span class="line">    # 给函数建立栈空间 start</span><br><span class="line">    pushq    %rbp     # 先将rsp向下增长一个单位(8bit)，把rbp压到栈中</span><br><span class="line">    movq    %rsp, %rbp     # 让rbp指向当前的rsp</span><br><span class="line">    subq    $64, %rsp     # rsp开辟64bit空间</span><br><span class="line">    # 给函数建立栈空间</span><br><span class="line"> # RetTest.c:31: int main() &#123;</span><br><span class="line">    call    __main     # 这个有时间再搞明白</span><br><span class="line"> # RetTest.c:32:     MY_POINT point = pointFun(5, 6);</span><br><span class="line">    movl    $6, %edx     # 参数2</span><br><span class="line">    movl    $5, %ecx     # 参数1</span><br><span class="line">    call    pointFun     # 先把rsp再增长一个单位，把rip的值压进栈，然后把pointFun值给rip 那么下一条指令就是pointFun的了</span><br><span class="line">    movq    %rax, -8(%rbp)     # rax是pointFun的返回值</span><br><span class="line"> # RetTest.c:33:     int *p = getIntP();</span><br><span class="line">    call    getIntP     #</span><br><span class="line"> # RetTest.c:33:     int *p = getIntP();</span><br><span class="line">    movq    %rax, -16(%rbp)     # _1, p</span><br><span class="line"> # RetTest.c:35:     printf(&quot;point: %d, %d\n&quot;, point.x, point.y);</span><br><span class="line">    movl    -4(%rbp), %edx     # point.y, _2</span><br><span class="line">    movl    -8(%rbp), %eax     # point.x, _3</span><br><span class="line">    movl    %edx, %r8d     # _2,</span><br><span class="line">    movl    %eax, %edx     # _3,</span><br><span class="line">    leaq    .LC2(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:36:     printf(&quot;intP: %d, %d, %d\n&quot;, *p, *(p + 1), *(p + 2));</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.6_4</span><br><span class="line">    addq    $8, %rax     #, _5</span><br><span class="line"> # RetTest.c:36:     printf(&quot;intP: %d, %d, %d\n&quot;, *p, *(p + 1), *(p + 2));</span><br><span class="line">    movl    (%rax), %ecx     # *_5, _6</span><br><span class="line"> # RetTest.c:36:     printf(&quot;intP: %d, %d, %d\n&quot;, *p, *(p + 1), *(p + 2));</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.7_7</span><br><span class="line">    addq    $4, %rax     #, _8</span><br><span class="line"> # RetTest.c:36:     printf(&quot;intP: %d, %d, %d\n&quot;, *p, *(p + 1), *(p + 2));</span><br><span class="line">    movl    (%rax), %edx     # *_8, _9</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.8_10</span><br><span class="line">    movl    (%rax), %eax     # *p.8_10, _11</span><br><span class="line">    movl    %ecx, %r9d     # _6,</span><br><span class="line">    movl    %edx, %r8d     # _9,</span><br><span class="line">    movl    %eax, %edx     # _11,</span><br><span class="line">    leaq    .LC3(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:37:     printf(&quot;%p, %p, %p, %p\n&quot;, &amp;p, p, p + 1, p + 2);</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.9_12</span><br><span class="line">    leaq    8(%rax), %rdx     #, _13</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.10_14</span><br><span class="line">    leaq    4(%rax), %r8     #, _15</span><br><span class="line">    movq    -16(%rbp), %rcx     # p, p.11_16</span><br><span class="line">    leaq    -16(%rbp), %rax     #, tmp113</span><br><span class="line">    movq    %rdx, 32(%rsp)     # _13,</span><br><span class="line">    movq    %r8, %r9     # _15,</span><br><span class="line">    movq    %rcx, %r8     # p.11_16,</span><br><span class="line">    movq    %rax, %rdx     # tmp113,</span><br><span class="line">    leaq    .LC4(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:38:     printf(&quot;%p, %d\n&quot;, (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    leaq    -16(%rbp), %rax     #, _17</span><br><span class="line">    addq    $8, %rax     #, _17</span><br><span class="line"> # RetTest.c:38:     printf(&quot;%p, %d\n&quot;, (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    movq    (%rax), %rax     # *_17, _18</span><br><span class="line"> # RetTest.c:38:     printf(&quot;%p, %d\n&quot;, (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    movl    %eax, %edx     # _19, _20</span><br><span class="line">    leaq    -16(%rbp), %rax     #, _21</span><br><span class="line">    addq    $8, %rax     #, _21</span><br><span class="line">    movl    %edx, %r8d     # _20,</span><br><span class="line">    movq    %rax, %rdx     # _21,</span><br><span class="line">    leaq    .LC5(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:39:     printf(&quot;%p, %d\n&quot;, &amp;(point.x), point.x);</span><br><span class="line">    movl    -8(%rbp), %edx     # point.x, _22</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp114</span><br><span class="line">    movl    %edx, %r8d     # _22,</span><br><span class="line">    movq    %rax, %rdx     # tmp114,</span><br><span class="line">    leaq    .LC5(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:41:     return 0;</span><br><span class="line">    movl    $0, %eax     #, _32</span><br><span class="line"> # RetTest.c:42: &#125;</span><br><span class="line">    addq    $64, %rsp     #,</span><br><span class="line">    popq    %rbp     #</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这个鬼程序还是蛮长的，用张图翻译一下</p><p><img data-src="/assets/04_Relearning-C-Cpp-Initialization-and-Functions/20210425212120_ret_value.svg" alt="20210425212120_ret_value"></p><p>基本上每个颜色就是一个步骤，还是比较容易理解的，所以说，指针函数就这样，没啥难度</p><p>再看看，为啥不能返回局部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">getArr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// int arr[] = &#123;1, 2, 3&#125;;</span></span><br><span class="line">    <span class="comment">// printf(&quot;getArr: %p, %p, %p\n&quot;, arr, arr + 1, arr + 2);</span></span><br><span class="line">    <span class="comment">// return arr;  // Address of stack memory associated with local variable &#x27;arr&#x27; returned</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>[]) &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;  <span class="comment">// 这仍然是个局部变量哦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nothing</span><span class="params">()</span> &#123;  <span class="comment">// 真的就是nothing</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nothing: %p, %p, %p\n&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = getArr();</span><br><span class="line">    nothing();</span><br><span class="line">    <span class="comment">// 猜猜值是多少</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d, %d, %d\n&quot;</span>, *arr, *(arr + <span class="number">1</span>), *(arr + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %p, %p, %p, %p\n&quot;</span>, &amp;arr, arr, arr + <span class="number">1</span>, arr + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">nothing: 000000000062FDCC, 000000000062FDC8, 000000000062FDC4</span></span><br><span class="line"><span class="comment">main: 10, 9, 8</span></span><br><span class="line"><span class="comment">main: 000000000062FE18, 000000000062FDC4, 000000000062FDC8, 000000000062FDCC</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个程序就不反汇编了，这种情况还是好的，能打印出来数据，更有甚者，程序可能会崩溃。所以<strong>永远不要返回局部变量的地址</strong></p><blockquote><p>指针和地址是一回事吗？通常是，但不完全是。我们这里都是用字节去划分内存，但是，如果是用字呢？</p></blockquote><h2 id="2-4-函数指针"><a href="#2-4-函数指针" class="headerlink" title="2.4 函数指针"></a>2.4 函数指针</h2><p>之前指针的应用都是指向数据，而函数指针不过就是把指针指向代码。这种指针可以被赋值，存放在数组中，传递给函数以及作为函数的返回值等等。简单的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> (*pFun)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p\n&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %p\n&quot;</span>, add(a, b), &amp;add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %p, %p\n&quot;</span>, pFun(a, b), pFun, &amp;pFun);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %p, %p\n&quot;</span>, (*pFun)(a, b), pFun, &amp;pFun);  <span class="comment">// *pFun的 () 不能少！！！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">000000000062FE0C, 000000000062FE08</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0, 000000000062FE00</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0, 000000000062FE00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个程序也没必要汇编了..函数add实际上存在text段的，指针pFun和a, b一样，都在栈中，只是存的值是add的地址，机制就是这么个机制。</p><p>还有就是有人喜欢把函数指针和typedef放一块看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="keyword">typedef</span> (*FUN_POINT)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FUN_POINT point;</span></span><br><span class="line"><span class="comment">// point = add;  // 为什么不能这么玩？</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FUN_POINT funPoint;</span><br><span class="line">    funPoint = add;</span><br><span class="line"></span><br><span class="line">    funPoint(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    (*funPoint)(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typedef就是重命名呀。好了，知道这么个机制，我们能做些什么？</p><p><strong>函数指针数组</strong></p><p>来看一个程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_cmd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">retrieve_cmd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update_cmd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">delete_cmd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是函数指针数组</span></span><br><span class="line"><span class="type">int</span> (*crud_cmd[])(<span class="type">int</span>, <span class="type">int</span>) = &#123;</span><br><span class="line">        create_cmd,</span><br><span class="line">        retrieve_cmd,</span><br><span class="line">        update_cmd,</span><br><span class="line">        delete_cmd</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = crud_cmd[<span class="number">1</span>](<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> b = (*crud_cmd + <span class="number">1</span>)(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把函数，指针，数组，三个词放一块还是很有意思的，比如实现一个状态机？</p><p><strong>多态</strong></p><p>多态是面向对象的概念，C语言是面向过程的语言(我觉得这句话不正确)。C语言就不能实现多态了？且看下面一个没有实质作用的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类 HUMANITY，基本特性 name，基本方法 intro</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HUMANITY</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> (*intro)(<span class="keyword">struct</span> HUMANITY *);</span><br><span class="line">&#125; HUMANITY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HUMANITY的子类 TEACHER，多了一个属性 teachNo</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HUMANITY humanity;</span><br><span class="line">    <span class="type">int</span> teachNo;</span><br><span class="line">&#125; TEACHER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TEACHER特有的 intro</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">teachIntro</span><span class="params">(HUMANITY *humanity)</span> &#123;</span><br><span class="line">    TEACHER *t = (TEACHER *) humanity;  <span class="comment">// 向下转型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a teacher. My name is %s and teachNo is %d\n&quot;</span>, t-&gt;humanity.name, t-&gt;teachNo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HUMANITY的子类 STUDENT，多了一个属性 stuNo</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HUMANITY humanity;</span><br><span class="line">    <span class="type">long</span> stuNo;</span><br><span class="line">&#125; STUDENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STUDENT特有的 intro</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stuIntro</span><span class="params">(HUMANITY *humanity)</span> &#123;</span><br><span class="line">    STUDENT *s = (STUDENT *) humanity;  <span class="comment">// 向下转型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a student. My name is %s and stuNo is %ld\n&quot;</span>, s-&gt;humanity.name, s-&gt;stuNo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    TEACHER *t = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TEACHER));  <span class="comment">// 创建一个TEACHER对象</span></span><br><span class="line">    t-&gt;humanity.name = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t-&gt;humanity.name, <span class="string">&quot;Wang&quot;</span>);</span><br><span class="line">    t-&gt;humanity.intro = teachIntro;</span><br><span class="line">    t-&gt;teachNo = <span class="number">12</span>;</span><br><span class="line">    HUMANITY *teacher = (HUMANITY *) t;  <span class="comment">// 向上转型</span></span><br><span class="line">    (teacher-&gt;intro)(teacher);  <span class="comment">// 实际上是 TEACHER 特有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(teacher-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line"></span><br><span class="line">    STUDENT *s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT));</span><br><span class="line">    s-&gt;humanity.name = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;humanity.name, <span class="string">&quot;Sidney Ding&quot;</span>);</span><br><span class="line">    s-&gt;humanity.intro = stuIntro;</span><br><span class="line">    s-&gt;stuNo = <span class="number">9999L</span>;</span><br><span class="line">    HUMANITY *student = (HUMANITY *) s;</span><br><span class="line">    (student-&gt;intro)(student);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(s-&gt;humanity.name);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">I am a teacher. My name is Wang and teachNo is 12</span></span><br><span class="line"><span class="comment">I am a student. My name is Sidney Ding and stuNo is 9999</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此时是不是发现C语言变得有趣多了？面向对象而已，C语言这么强大的语言必拿下。在这个例子中，不免要思考一件事，向上转型和向下转型？因为子类多余的属性是放在父类后面的，所谓的转型，我们就当是内存截断好了，父类前面的内容必然是符合的，至于后面内容，也不会丢，毕竟还是占内存的。此时再将这个父类向下转型，不过就是扩张而已，恰巧后面的就是子类多出的属性占的内存。</p><h2 id="2-5-宏函数"><a href="#2-5-宏函数" class="headerlink" title="2.5 宏函数"></a>2.5 宏函数</h2><p>这个没啥好说，<code>#define</code>这玩意本省就是编译时替换，所以注意多加括号就好了，至于宏的一些技巧，例如拼接，之前也说过了</p><p>所以，就到这里了，以后想到啥好玩的，再加进来吧！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-初始化&quot;&gt;&lt;a href=&quot;#1-初始化&quot; class=&quot;headerlink&quot; title=&quot;1 初始化&quot;&gt;&lt;/a&gt;1 初始化&lt;/h1&gt;&lt;p&gt;对象的声明可以通过初始化的过程获得初始值。主要就是见识一下C&amp;#x2F;Cpp里面几种初始化的形式，免得大惊小怪&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// C语言的初始化还好，怎么着都得有个 =&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; c = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;  &lt;span class=&quot;comment&quot;&gt;// scalar initialization&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], b;&amp;#125; MyType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyType mm = &amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;* ptr = &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Cpp多了一个花样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; b &amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], b;&amp;#125; MyType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyType mm &amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; *m = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;auto&lt;/span&gt; *m1 &amp;#123;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;MyType&lt;/span&gt;()&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Language" scheme="https://sidneyding.cn/categories/Language/"/>
    
    <category term="C/Cpp" scheme="https://sidneyding.cn/categories/Language/C-Cpp/"/>
    
    
    <category term="Relearning C/Cpp" scheme="https://sidneyding.cn/tags/Relearning-C-Cpp/"/>
    
  </entry>
  
  <entry>
    <title>[Relearning C/Cpp] Array and Pointer</title>
    <link href="https://sidneyding.cn/posts/61dcf29f/"/>
    <id>https://sidneyding.cn/posts/61dcf29f/</id>
    <published>2021-04-17T07:47:30.000Z</published>
    <updated>2022-06-05T09:19:40.518Z</updated>
    
    <content type="html"><![CDATA[<p>数组和指针一般不能分开，尤其是C语言里面，让人又爱又恨的东西..而一谈到这俩玩意就得画图..</p><h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h1><p>对数组下定义，抱歉，我不会。但是我有词典，a way of organizing and storing related data in a computer memory。这么一看就清晰多了</p><p>元素类型为char的数组可以如下声明</p><p><code>int c[6];  // 可以存6个整数的数组</code></p><p>在声明中<code>[]</code>表示xxx的数组，所有数组下标都是从0开始，计算机中很多东西都是从0开始，为什么？搜索一下吧。数组的大小，就是那个6，必须得是个常量表达式，这么看，数组一旦定义好了大小就定下来了呀</p><p>数组名也是标识符，也要符合规则，不能和其他变量重名</p><p>数组初始化的时候可以部分初始化，也可以整体初始化；赋值的时候不能整体赋值，只能单个元素得赋值(数组拷贝，那个不算)</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 这样就是整体初始化，可以不用写数组大小</span></span><br><span class="line"><span class="comment">// arr = &#123;5, 4, 3, 2, 1&#125;;  // 不带这样的赋值</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">4</span>;  <span class="comment">// 只能单个赋值</span></span><br></pre></td></tr></table></figure><p>另外有一点就是大家常说的，数组是在内存里面开辟一块连续的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d]&#x27;s addr is %p\n&quot;</span>, i, &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">a[0]&#x27;s addr is 000000000062FE00</span></span><br><span class="line"><span class="comment">a[1]&#x27;s addr is 000000000062FE04</span></span><br><span class="line"><span class="comment">a[2]&#x27;s addr is 000000000062FE08</span></span><br><span class="line"><span class="comment">a[3]&#x27;s addr is 000000000062FE0C</span></span><br><span class="line"><span class="comment">a[4]&#x27;s addr is 000000000062FE10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到都是4个4个往上加的连续地址</p><p>再说多维数组，多维数组给我们的直观感受是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如这是个二维的，那就应该是个平面</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是显然内存不是个平面，还是个线性的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d]&#x27;s addr is %p\n&quot;</span>, i, j, &amp;arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">a[0][0]&#x27;s addr is 000000000062FE00</span></span><br><span class="line"><span class="comment">a[0][1]&#x27;s addr is 000000000062FE04</span></span><br><span class="line"><span class="comment">a[0][2]&#x27;s addr is 000000000062FE08</span></span><br><span class="line"><span class="comment">a[1][0]&#x27;s addr is 000000000062FE0C</span></span><br><span class="line"><span class="comment">a[1][1]&#x27;s addr is 000000000062FE10</span></span><br><span class="line"><span class="comment">a[1][2]&#x27;s addr is 000000000062FE14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>汇编出来看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -32(%rbp)</span><br><span class="line">    movl    $2, -28(%rbp)</span><br><span class="line">    movl    $3, -24(%rbp)</span><br><span class="line">    movl    $4, -20(%rbp)</span><br><span class="line">    movl    $5, -16(%rbp)</span><br><span class="line">    movl    $6, -12(%rbp)</span><br><span class="line">    movl    $0, -4(%rbp)</span><br><span class="line">    jmp    .L2</span><br><span class="line">...</span><br><span class="line">.L2:</span><br><span class="line">    cmpl    $1, -4(%rbp)</span><br><span class="line">    jle    .L5</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $64, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>现在对(%rbp)前面的数字就有那么点感觉了哈，<code>-8(%rbp)</code>去哪了？是j呀</p><p>数组里面还有一个特殊的，就是字符数组，在C语言里面就指望这个当字符串了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> arr[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> tmp[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(<span class="type">char</span>); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%c)&quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">char</span>); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%c)&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n&quot;</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">(h)(e)(l)(l)(o)( )(w)(o)(r)(l)(d)(!)( )</span></span><br><span class="line"><span class="comment">hello world!</span></span><br><span class="line"><span class="comment">(h)(e)(l)(l)(o)( )(w)(o)(r)(l)(d)(!)</span></span><br><span class="line"><span class="comment">hello world!hello world!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>汇编出来瞅瞅</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    call    __main</span><br><span class="line">    movabsq    $8031924123371070824, %rax  # 8个字节</span><br><span class="line">    movq    %rax, -21(%rbp)</span><br><span class="line">    movl    $560229490, -13(%rbp)  # 4个字节 和前面8个加起来就是 hello world!</span><br><span class="line">    movb    $0, -9(%rbp)     # 最后面的\0 到这里为止应该是str的定义及声明</span><br><span class="line">    movb    $104, -33(%rbp)  # h</span><br><span class="line">    movb    $101, -32(%rbp)</span><br><span class="line">    movb    $108, -31(%rbp)</span><br><span class="line">    movb    $108, -30(%rbp)</span><br><span class="line">    movb    $111, -29(%rbp)</span><br><span class="line">    movb    $32, -28(%rbp)</span><br><span class="line">    movb    $119, -27(%rbp)</span><br><span class="line">    movb    $111, -26(%rbp)</span><br><span class="line">    movb    $114, -25(%rbp)</span><br><span class="line">    movb    $108, -24(%rbp)</span><br><span class="line">    movb    $100, -23(%rbp)</span><br><span class="line">    movb    $33, -22(%rbp)   # ! 到这里位置应该是arr的</span><br><span class="line">    movb    $104, -35(%rbp) # h</span><br><span class="line">    movb    $0, -34(%rbp)   # 这里就是tmp的了</span><br><span class="line">    movl    $0, -4(%rbp)</span><br><span class="line">    jmp    .L2</span><br><span class="line">.L3:</span><br></pre></td></tr></table></figure><p>从这段程序至少可以看出，字符数组要想编程字符串后面必须有<code>&#39;\0&#39;</code>，字符串不论何种形式，内存占的大小是一样的，但是用字符数组去初始化字符串通常会比较慢(好像每种指令执行速度不一样，这句话不一定对哦)</p><p>还有一个C和C++的字符串是不一样的，它们之间的转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string cppString = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="comment">//char* cString = &quot;cstr&quot;;  // ISO C++ 11不允许这么干</span></span><br><span class="line">    <span class="type">char</span> cArr[] = <span class="string">&quot;cArr&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *cString = cArr;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *tmpStr = cppString.<span class="built_in">c_str</span>();</span><br><span class="line">    string aStr = cString;</span><br><span class="line">    string bStr = cArr;</span><br><span class="line">    string cStr = tmpStr;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *tmpCStr = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="built_in">malloc</span>(<span class="number">10</span>));</span><br><span class="line">    cppString.<span class="built_in">copy</span>(tmpCStr, cppString.<span class="built_in">length</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> tmpCArr[<span class="number">10</span>];</span><br><span class="line">    cppString.<span class="built_in">copy</span>(tmpCArr, cppString.<span class="built_in">length</span>(), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *cDataStr = cppString.<span class="built_in">data</span>();  <span class="comment">// C++11报错 要const，C++17没事</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组单个玩没意思，还是需要结合指针玩</p><h1 id="2-指针"><a href="#2-指针" class="headerlink" title="2 指针"></a>2 指针</h1><p>先不要把这玩意想象成指针</p><img data-src="/assets/03_Relearning-C-Cpp-Array-and-Pointer/watch.webp" alt="watch" style="zoom: 25%;" /><p>就当成一个数据类型，这个数据类型是存地址的，地址是啥，就一串数字，说白了就是存了一串数字。从这里我们就知道了指针的大小了，地址是无符号数，那么32位的程序就是4个字节，64位的程序就是8个字节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三个输出都是8 我是64位的</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">long</span>*));</span><br></pre></td></tr></table></figure><p>再看指针的声明定义啥的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* iP = &amp;a;  <span class="comment">// 我们称iP为 &quot;指向&quot;a的指针；&amp;取地址符号只能应用于内存中的对象，不能用作表达式，常量，register的变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *iP);  <span class="comment">// 这里的*表示间接寻址或间接引用，访问指针所指向的对象</span></span><br></pre></td></tr></table></figure><p>指针只能指向某个特定数据类型的对象，但是void型指针比较特殊，可以指向任意数据类型的对象，但它不能间接引用自身。注意读法<font color='red'><strong>“aa指向bb的指针”</strong></font>(读法来自K&amp;R的《C程序设计语言》)，读不好，后面就得绕进去</p><h2 id="2-1-指针和数组"><a href="#2-1-指针和数组" class="headerlink" title="2.1 指针和数组"></a>2.1 指针和数组</h2><p>通过数组下标所能完成的任何任务都能通过指针来实现。一般来说，用指针实现的程序比用数组下标实现的程序执行速度更快(现在优化得两者差不多了)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* pInt = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>* pArr = arr;</span><br><span class="line"></span><br><span class="line">    pInt = pInt + <span class="number">1</span>;</span><br><span class="line">    pArr = pArr + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -64(%rbp)  # arr[0]</span><br><span class="line">    movl    $2, -60(%rbp)</span><br><span class="line">    movl    $3, -56(%rbp)</span><br><span class="line">    movl    $4, -52(%rbp)</span><br><span class="line">    movl    $5, -48(%rbp)</span><br><span class="line">    movl    $6, -44(%rbp)</span><br><span class="line">    movl    $7, -40(%rbp)</span><br><span class="line">    movl    $8, -36(%rbp)</span><br><span class="line">    movl    $9, -32(%rbp)</span><br><span class="line">    leaq    -64(%rbp), %rax  # load effective address</span><br><span class="line">    movq    %rax, -8(%rbp)   # pInt</span><br><span class="line">    leaq    -64(%rbp), %rax</span><br><span class="line">    movq    %rax, -16(%rbp)  # pArr</span><br><span class="line">    addq    $4, -8(%rbp)     # 地址加立即数4，因为int是4字节的</span><br><span class="line">    addq    $8, -16(%rbp)    # 地址加立即数8，两个4呀</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $96, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>所以从汇编的角度来看arr就是指向arr[0]的地址，指针加n，实际上就是<code>指针的值(地址) + n * sizeof(数据类型)</code>，那么减法应当也是一样咯，地址往前往后的区别。</p><p>知道这层关系之后，再来讨论一下指针和多维数组之间的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pArr是指向int的指针的数组 指针数组 pArr是个存放int型指针的一维数组</span></span><br><span class="line">    <span class="type">int</span> *pArr[<span class="number">3</span>] = &#123;arr[<span class="number">0</span>], arr[<span class="number">1</span>] + <span class="number">1</span>, arr[<span class="number">2</span>] + <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// int *(pArr[3]) = &#123;arr[0], arr[1] + 1, arr[2] + 2&#125;;</span></span><br><span class="line">    <span class="comment">// p1是指向4 int数组的指针 数组指针 p1是个指针，指向的是一个数组，这样说，可能有点不明白，换个方式。</span></span><br><span class="line">    <span class="comment">// 把arr当作一维数组，存的就是4个数组的首地址，现在再看p1是个指针，指向存有4个数组首地址的数组的首地址</span></span><br><span class="line">    <span class="type">int</span> (*p1)[<span class="number">4</span>] = arr;</span><br><span class="line">    <span class="comment">// int (*p1)[] = arr;  // 4是可以去掉的，因为arr很明确</span></span><br><span class="line">    <span class="comment">// p2是指向指向3 int的指针的数组的指针 指向指针数组的指针</span></span><br><span class="line">    <span class="type">int</span> *(*p2)[<span class="number">3</span>] = &amp;pArr;</span><br><span class="line">    <span class="comment">// int* (*p2)[] = &amp;pArr;</span></span><br><span class="line">    <span class="comment">// p3是指向 指向4 int数组的指针 的指针，指向数组指针的指针，二级指针</span></span><br><span class="line">    <span class="type">int</span> (**p3)[<span class="number">4</span>] = &amp;p1;</span><br><span class="line">    <span class="comment">// int (**p3)[] = &amp;p1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p4是指向int的指针 arr == &amp;arr[0][0]</span></span><br><span class="line">    <span class="type">int</span> *p4 = *arr;</span><br><span class="line">    <span class="comment">// int* p2 = arr;  这会有warning initialization of &#x27;int *&#x27; from incompatible pointer type &#x27;int (*)[4]&#x27;</span></span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, *(pArr[<span class="number">1</span>] + <span class="number">0</span>));       <span class="comment">// 6</span></span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, *(*(p1 + <span class="number">1</span>) + <span class="number">1</span>));     <span class="comment">// 6</span></span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, *(*(*(p2) + <span class="number">1</span>) + <span class="number">0</span>));  <span class="comment">// 6</span></span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, *(*(*p3 + <span class="number">1</span>) + <span class="number">1</span>));    <span class="comment">// 6</span></span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, *(p4 + <span class="number">5</span>));            <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp              # push当然是入栈的意思</span><br><span class="line">    .seh_pushreg    %rbp</span><br><span class="line">    movq    %rsp, %rbp        # rbp是堆栈基指针 rsp是栈顶指针 现在它俩对齐了</span><br><span class="line">    .seh_setframe    %rbp, 0</span><br><span class="line">    subq    $160, %rsp        # 给变量开辟空间 160个字节</span><br><span class="line">    .seh_stackalloc    160</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -80(%rbp)     # arr[0][0]</span><br><span class="line">    movl    $2, -76(%rbp)</span><br><span class="line">    movl    $3, -72(%rbp)</span><br><span class="line">    movl    $4, -68(%rbp)</span><br><span class="line">    movl    $5, -64(%rbp)</span><br><span class="line">    movl    $6, -60(%rbp)</span><br><span class="line">    movl    $7, -56(%rbp)</span><br><span class="line">    movl    $8, -52(%rbp)</span><br><span class="line">    movl    $9, -48(%rbp)</span><br><span class="line">    movl    $10, -44(%rbp)</span><br><span class="line">    movl    $11, -40(%rbp)</span><br><span class="line">    movl    $12, -36(%rbp)    # arr[2][3]</span><br><span class="line">    leaq    -80(%rbp), %rax   # 将-80(%rbp)的地址存到%rax</span><br><span class="line">    movq    %rax, -112(%rbp)  # pArr[0] = -112(%rbp) = -80(%rbp)的地址</span><br><span class="line">    leaq    -80(%rbp), %rax</span><br><span class="line">    addq    $16, %rax</span><br><span class="line">    addq    $4, %rax</span><br><span class="line">    movq    %rax, -104(%rbp)  # pArr[1] = -104(%rbp) = (-80 + 16 + 4)(%rbp)的地址</span><br><span class="line">    leaq    -80(%rbp), %rax</span><br><span class="line">    addq    $32, %rax</span><br><span class="line">    addq    $8, %rax</span><br><span class="line">    movq    %rax, -96(%rbp)   # pArr[2] = -96(%rbp) = (-80 + 32 + 8)(%rbp)的地址</span><br><span class="line">    leaq    -80(%rbp), %rax</span><br><span class="line">    movq    %rax, -120(%rbp)  # p1 = -120(%rbp) = -80(%rbp)的地址</span><br><span class="line">    leaq    -112(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)    # p2 = -8(%rbp) =  -112(%rbp)的地址</span><br><span class="line">    leaq    -120(%rbp), %rax</span><br><span class="line">    movq    %rax, -16(%rbp)   # p3 = -16(%rbp) = -120(%rbp)的地址</span><br><span class="line">    leaq    -80(%rbp), %rax</span><br><span class="line">    movq    %rax, -24(%rbp)   # p4 = -24(%rbp) = -80(%rbp)的地址</span><br><span class="line">    movq    -104(%rbp), %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movq    -120(%rbp), %rax</span><br><span class="line">    addq    $16, %rax</span><br><span class="line">    addq    $4, %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    addq    $8, %rax</span><br><span class="line">    movq    (%rax), %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movq    -16(%rbp), %rax</span><br><span class="line">    addq    $8, %rax</span><br><span class="line">    movq    (%rax), %rax</span><br><span class="line">    addq    $16, %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $160, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>再来一张图</p><p><img data-src="/assets/03_Relearning-C-Cpp-Array-and-Pointer/pointer.svg" alt="pointer"></p><p>这整个搞完，发现一个很重要的点，就是当前指针的步长是多少，当前指针存储地址是多少，这样就可以无限递归推算下去。</p><p>PS：没系统学过汇编，可能表述的有点问题..</p><h2 id="2-2-指针运算"><a href="#2-2-指针运算" class="headerlink" title="2.2 指针运算"></a>2.2 指针运算</h2><p>再探讨一下比较好玩的事，常量指针和指针常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有const的话，我们读作 变量a；加了const，我们读作 常量a</span></span><br><span class="line">const <span class="type">char</span> a;</span><br><span class="line"><span class="type">char</span> const b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量p1是指向 常量char 的指针，变量p1，那么p1的值可以变，但是p1指向的值不能变</span></span><br><span class="line">const <span class="type">char</span> *p1;</span><br><span class="line"><span class="comment">// 变量p1是指向 char常量 的指针</span></span><br><span class="line"><span class="type">char</span> const *p1;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 常量p2是指向 char变量 的指针，常量p2，那么p2的值不能变，但是p2指向的值可以变</span></span><br><span class="line"><span class="type">char</span>* const p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量p3是指向 常量char 的指针，都是常量，那就是都不能变</span></span><br><span class="line">const <span class="type">char</span>* const p3;</span><br><span class="line"><span class="type">char</span> const * const p3;  <span class="comment">// 看起来很奇怪对不对 但是能够读得通 那就没毛病</span></span><br><span class="line"></span><br><span class="line">p1 = &amp;a;  <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// *p1 = &#x27;a&#x27;;   Read-only variable is not assignable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p2 = &amp;a;  Cannot assign to variable &#x27;p3&#x27; with const-qualified type &#x27;char *const&#x27;</span></span><br><span class="line">*p2 = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>啥常量指针，指针常量，那第三个咋读？常量指针常量？精简就容易带来误解</p><p>好了，那只是个题外话，接下来说说，指针相关的计算，就是加减乘除啥的</p><p><strong>指针和基本数据类型</strong></p><p>从上面我们了解到，指针和int可以做加减，实际就是指针存储的值做偏移，比如下面的程序，一点毛病没有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *pArr = arr;</span><br><span class="line">    pArr++;</span><br><span class="line">    pArr--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题1：那有个好玩的数据类型，void，这个呢？可以与int做加减吗？根据搜索得知</p><blockquote><p>void* pvoid;</p><p>pvoid++; &#x2F;&#x2F; ANSI：错误</p><p>pvoid +&#x3D; 1; &#x2F;&#x2F; ANSI：错误</p><p>pvoid++; &#x2F;&#x2F;GNU：正确</p><p>pvoid +&#x3D; 1; &#x2F;&#x2F;GNU：正确</p><p>(char *) pvoid++; &#x2F;&#x2F; ANSI：正确；GNU：正确</p><p>(char *) pvoid +&#x3D; 1; &#x2F;&#x2F; ANSI：错误；GNU：正确</p></blockquote><p>这么说，ANSI限制贼严格..切换成ANSI全报红了..还是GNU比较奔放。通过实验也可以发现，在GNU下，<code>sizeof(void)</code>的值是1</p><p>问题2：能和浮点数相加吗？能和char相加吗？能和long相加吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>* pInt = arr;</span><br><span class="line"><span class="comment">// pInt += 2.1;  // Invalid operands to binary expression (&#x27;int *&#x27; and &#x27;double&#x27;)</span></span><br><span class="line">pInt += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">pInt += <span class="number">1L</span>;</span><br><span class="line"><span class="type">short</span> s = <span class="number">1</span>;</span><br><span class="line">pInt += s;</span><br></pre></td></tr></table></figure><p>答案还是比较容易想到的</p><p>问题3：指针可以乘除吗？</p><p>Invalid operands to binary expression (‘int *’ and ‘int’)。我只能说隐式转换不成功</p><p><strong>指针和指针</strong></p><p>问题1：指针和指针相加会有什么特效？</p><p>Invalid operands to binary expression (‘int *’ and ‘int *’)</p><p>当然也不要想着乘除了，存在必合理，不存在那肯定就是不合理了</p><p>问题2：指针和指针相减会有什么特效？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>* pInt1 = arr;</span><br><span class="line"><span class="type">int</span>* pInt2 = arr + <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> diff = pInt2 - pInt1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>, diff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, pInt1 - pInt2);  <span class="comment">// 很容易想到吧</span></span><br></pre></td></tr></table></figure><p>这是同类型的，那不同类型的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> u;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">long</span> c;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pa = &amp;a;</span><br><span class="line"><span class="type">unsigned</span> *pu = &amp;u;</span><br><span class="line"><span class="type">char</span>* pb = &amp;b;</span><br><span class="line"><span class="type">long</span>* pc = &amp;c;</span><br><span class="line"><span class="type">double</span>* pd = &amp;d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pa - pb;  &#x27;int *&#x27; and &#x27;char *&#x27; are not pointers to compatible types</span></span><br><span class="line"><span class="comment">// pa - pu;</span></span><br><span class="line"><span class="comment">// pa - pc;</span></span><br><span class="line"><span class="comment">// pa - pd;</span></span><br></pre></td></tr></table></figure><p>这报的错叫aa和bb不是指向兼容的指针，难道还有类型不一样，但是类型兼容的指针？指针减一下就知道是不是同类型的了，不是编译都过不了</p><p><strong>指针逻辑运算</strong></p><p>不打算研究那么多了，指针能够比较大小吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *pInt1 = arr;</span><br><span class="line"><span class="type">int</span> *pInt2 = arr + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pInt1 &lt; pInt2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pInt1 &lt; <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pInt1 &lt; <span class="number">0xFFFFFFFFFF</span>);  <span class="comment">// Ordered comparison between pointer and integer (&#x27;int *&#x27; and &#x27;long long&#x27;)</span></span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    .seh_pushreg    %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .seh_setframe    %rbp, 0</span><br><span class="line">    subq    $64, %rsp</span><br><span class="line">    .seh_stackalloc    64</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $10, -28(%rbp)    # arr[0]</span><br><span class="line">    movl    $2, -24(%rbp)     # arr[1]</span><br><span class="line">    movl    $3, -20(%rbp)     # arr[2]</span><br><span class="line">    leaq    -28(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)   # pInt1</span><br><span class="line">    leaq    -28(%rbp), %rax</span><br><span class="line">    addq    $4, %rax</span><br><span class="line">    movq    %rax, -16(%rbp)  # pInt2</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    cmpq    -16(%rbp), %rax  # 直接拿存储的地址进行比较</span><br><span class="line">    setb    %al</span><br><span class="line">    movzbl    %al, %eax</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %edx              # 这应该是被优化了 都不比较了</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movabsq    $1099511627774, %rax</span><br><span class="line">    cmpq    %rax, -16(%rbp)       # 拿地址和数字进行比较</span><br><span class="line">    setbe    %al</span><br><span class="line">    movzbl    %al, %eax</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $64, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>总结一下</p><blockquote><p>有效的指针运算包括相同类型指针之间的赋值运算；指针同整数之间的加法或减法运算；指向相同数组中元素的两个指针间的减法或比较运算；将指针赋值为0或指针与0之间的比较运算。其他所有形式的指针运算都是非法的，指针之间加减乘除，移位或屏蔽运算；指针同float或double类型之间的加法；不经强制类型转换而直接将指向一种类型对象的指针赋值给指向另一种类型对象的指针运算(两个指针之一是void*类型的情况除外)</p></blockquote><p>至于函数指针，指针函数这俩玩意放到函数那块再讨论</p><h1 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a>3 引用</h1><p>引用这个概念是Cpp的，C没有，在Cpp的世界里，指针与引用是分不开的</p><p>和指针类似，引用作为对象的别名存放的也是对象的机器地址，与指针相比，引用不会带来额外的开销，引用与指针的却别主要包括：</p><ul><li><p>访问引用与访问对象本身从语法形式上是一样的</p></li><li><p>引用所引的永远是一开始初始化的那个对象</p></li><li><p>不存在“空引用”，我们可以认为引用一定对应着某个对象</p></li></ul><p>引用实际上是对象的别名。引用最重要的用途是作为函数的实参或返回值，此外它也被用于重载运算符</p><p>左值引用：引用那些我们希望改变的对象</p><p>const引用：引用那些我们不希望改变值的对象(比如常量)</p><p>右值引用：所引对象的值在我们使用之后就无需保留了(比如临时变量)</p><p>前两种都叫做左值引用</p><h2 id="3-1-左值引用"><a href="#3-1-左值引用" class="headerlink" title="3.1 左值引用"></a>3.1 左值引用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>&amp; r = i;</span><br><span class="line">    <span class="type">int</span> ii = r;</span><br><span class="line">    r = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d, %p\n&quot;</span>, i, r, ii, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">4, 4, 1, 000000000064fe10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明引用是有地址的，引用和(*p)是很像的，但是引用这玩意比较智能一点，汇编一波</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -16(%rbp)     # int i = 1;</span><br><span class="line">    leaq    -16(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)    # int&amp; r = i;</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, -12(%rbp)   # int ii = r;</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    $4, (%rax)        # r = 4;</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    (%rax), %ecx      # i</span><br><span class="line">    movl    -16(%rbp), %eax   # r</span><br><span class="line">    movl    -12(%rbp), %r8d   # ii</span><br><span class="line">    movq    -8(%rbp), %rdx</span><br><span class="line">    movq    %rdx, 32(%rsp)    # &amp;r</span><br><span class="line">    movl    %r8d, %r9d</span><br><span class="line">    movl    %ecx, %r8d</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    _ZL6printfPKcz</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $64, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>再把引用换成指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* r = &amp;i;</span><br><span class="line">    <span class="type">int</span> ii = *r;</span><br><span class="line">    *r = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d, %p\n&quot;</span>, i, *r, ii, &amp;(*r));  <span class="comment">// 这才是引用的本质</span></span><br><span class="line">    <span class="comment">// printf(&quot;%d, %d, %d, %p\n&quot;, i, *r, ii, &amp;r);  // 这样汇编会少一句 movl    %eax, %edx</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">4, 4, 1, 000000000064fe10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -16(%rbp)</span><br><span class="line">    leaq    -16(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    (%rax), %eax</span><br><span class="line">    movl    %eax, -12(%rbp)</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    $4, (%rax)</span><br><span class="line">    movq    -8(%rbp), %rax</span><br><span class="line">    movl    (%rax), %ecx</span><br><span class="line">    movl    -16(%rbp), %eax</span><br><span class="line">    movl    -12(%rbp), %r8d</span><br><span class="line">    movq    -8(%rbp), %rdx</span><br><span class="line">    movq    %rdx, 32(%rsp)</span><br><span class="line">    movl    %r8d, %r9d</span><br><span class="line">    movl    %ecx, %r8d</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    _ZL6printfPKcz</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $64, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>汇编出来的代码都一毛一样，所以，你懂我意思吧。</p><p><strong>为了确保引用对应某个对象，必须初始化引用</strong></p><p>再来看一个牛逼一点的常量引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 常量引用的本质 汇编代码是一样的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; r = i;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p = &amp;i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// r = &amp;i;  Cannot assign to variable &#x27;r&#x27; with const-qualified type &#x27;const int &amp;&#x27;</span></span><br><span class="line">    <span class="comment">// p = &amp;t;  Cannot assign to variable &#x27;p&#x27; with const-qualified type &#x27;int *const&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; r1 = <span class="number">1</span>;  <span class="comment">// 这个稍微强一点 只不过是少写点代码而已</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-右值引用"><a href="#3-2-右值引用" class="headerlink" title="3.2 右值引用"></a>3.2 右值引用</h2><p>右值引用对应一个临时对象，用户可以修改这个对象，并且认定这个对象以后不会用到了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int a = 10;</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; rr = a;  // Rvalue reference to type &#x27;int&#x27; cannot bind to lvalue of type &#x27;int&#x27;</span></span><br><span class="line">    <span class="type">int</span> &amp;&amp; rr = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp;&amp; rr1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rr是个临时变量，不允许绑定左值，只允许绑定右值。虽然可以声明定义const右值引用，但是一般不用，因为右值引用就是用来修改的，加了const就不能改了</p><p>右值引用和const左值引用都能绑定右值，但是它们的目标完全不同</p><ul><li><p>右值引用实现了一种破坏性读取，某些数据本来需要拷贝，使用右值引用可以优化其性能</p></li><li><p>const左值引用的目的是保护参数内容不被修改</p></li></ul><p>为什么说提高性能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T tmp = <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(a);</span><br><span class="line">    a = <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(b);</span><br><span class="line">    b = <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T tmp = std::<span class="built_in">move</span>(a);</span><br><span class="line">    a = std::<span class="built_in">move</span>(b);</span><br><span class="line">    b = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>move函数并没有移动，而是将左值强转为右值。这里需要插播一下，何为左值，何为右值</p><blockquote><p>右值是”不能作为左值的值”，比如像函数返回值一样的临时值。右值的定义多么清晰，只要知道什么是左值就行了。当考虑对象的寻址，拷贝，移动等操作时，有两种属性特别关键</p><ul><li>有身份，在程序中有对象的名字，或者指向该对象的指针，或该对象的引用，这样我们就能判断两个对象是否相等或对象值是否发生改变</li><li>可移动，能把对象的内容移出来(比如，能把它的值移动到其他某处，剩下的对象处于合法但未指定状态，与拷贝是有差别的)</li></ul><p>根据排列组合可知，有身份和可移动可以组合成四种形式，但是既没有身份又不可移动的对象不重要。</p><p>左值：有身份 &amp;&amp; !可移动</p><p>特别值：有身份 &amp;&amp; 可移动</p><p>纯右值：!有身份 &amp;&amp; 可移动<br>其中左值和特别值又称泛左值(有身份)，纯右值和特别值又称右值(可移动)。在实际编程中考虑左值和右值就够了，一条表达式要么是左值，要么是右值，不可能两者都是</p></blockquote><p>程序一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(a);</span><br><span class="line">    a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(b);</span><br><span class="line">    b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, a, b, tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">2, 1, 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $48, %rsp</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -4(%rbp)       # int a = 1;</span><br><span class="line">    movl    $2, -8(%rbp)       # int b = 2;</span><br><span class="line">    movl    -4(%rbp), %eax     # %eax临时变量的角色 1</span><br><span class="line">    movl    %eax, -12(%rbp)    # int tmp = 1;</span><br><span class="line">    movl    -8(%rbp), %eax     # %eax的值换成了2</span><br><span class="line">    movl    %eax, -4(%rbp)     # a = 2;</span><br><span class="line">    movl    -12(%rbp), %eax    # 临时变量又换成了 1</span><br><span class="line">    movl    %eax, -8(%rbp)     # b = 1;</span><br><span class="line">    movl    -12(%rbp), %ecx</span><br><span class="line">    movl    -8(%rbp), %edx</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    %ecx, %r9d</span><br><span class="line">    movl    %edx, %r8d</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    _ZL6printfPKcz</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $48, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>程序二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, a, b, tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $48, %rsp</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -4(%rbp)</span><br><span class="line">    movl    $2, -8(%rbp)</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    %eax, -12(%rbp)</span><br><span class="line">    movl    -8(%rbp), %eax</span><br><span class="line">    movl    %eax, -4(%rbp)</span><br><span class="line">    movl    -12(%rbp), %eax</span><br><span class="line">    movl    %eax, -8(%rbp)</span><br><span class="line">    movl    -12(%rbp), %ecx</span><br><span class="line">    movl    -8(%rbp), %edx</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    %ecx, %r9d</span><br><span class="line">    movl    %edx, %r8d</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    _ZL6printfPKcz</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $48, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>和程序1的汇编代码是一毛一样的..难道右值引用只是个噱头？</p><p>程序三：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    string tmp = s1;</span><br><span class="line">    s1 = s2;</span><br><span class="line">    s2 = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1: %s\n&quot;</span>, s1.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2: %s\n&quot;</span>, s2.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tmp: %s\n&quot;</span>, tmp.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">s1: b</span></span><br><span class="line"><span class="comment">s2: a</span></span><br><span class="line"><span class="comment">tmp: a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>程序四：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    string s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    string tmp = <span class="built_in">static_cast</span>&lt;string&amp;&amp;&gt;(s1);</span><br><span class="line">    s1 = <span class="built_in">static_cast</span>&lt;string&amp;&amp;&gt;(s2);</span><br><span class="line">    s2 = <span class="built_in">static_cast</span>&lt;string&amp;&amp;&gt;(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1: %s\n&quot;</span>, s1.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2: %s\n&quot;</span>, s2.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tmp: %s\n&quot;</span>, tmp.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">s1: b</span></span><br><span class="line"><span class="comment">s2: a</span></span><br><span class="line"><span class="comment">tmp:</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从结果来看，tmp里面的东西真的移走了，程序三个程序四的汇编代码很类似，只是程序四较程序三少一点东西</p><p>再来个程序看左引用和右引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; rr = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; r = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $11, %eax</span><br><span class="line">    movl    %eax, -20(%rbp)  # 11也是有地址的</span><br><span class="line">    leaq    -20(%rbp), %rax</span><br><span class="line">    movq    %rax, -8(%rbp)   # int&amp;&amp; rr = 10;</span><br><span class="line">    movl    $10, -24(%rbp)   # int i = 10</span><br><span class="line">    leaq    -24(%rbp), %rax</span><br><span class="line">    movq    %rax, -16(%rbp)  # r = &amp;i;</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $64, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>事实上右值(临时变量)是有地址的，只是我们不知道存在哪罢了，并且这个右值与它的引用具有相同的生命周期。<strong>临时变量根本上来说就是一个没有名字的变量而已</strong>，有名字的10(i)和没名字的11的处理方式基本一致</p><h2 id="3-3-引用的引用"><a href="#3-3-引用的引用" class="headerlink" title="3.3 引用的引用"></a>3.3 引用的引用</h2><p>如果用引用指向某类型的引用，那么得到还是该类型的引用，而非特殊的引用的引用类型。就是传说中的引用折叠(reference collapse)问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> rr_i = <span class="type">int</span>&amp;&amp;;</span><br><span class="line"><span class="keyword">using</span> lr_i = <span class="type">int</span>&amp;;</span><br><span class="line"><span class="keyword">using</span> rr_rr_i = rr_i&amp;&amp;;  <span class="comment">// int&amp;&amp; &amp;&amp; 的类型是 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">using</span> lr_rr_i = rr_i&amp;;   <span class="comment">// int&amp;&amp; &amp;  的类型是 int&amp;</span></span><br><span class="line"><span class="keyword">using</span> rr_lr_i = lr_i&amp;&amp;;  <span class="comment">// int&amp; &amp;&amp;  的类型是 int&amp;</span></span><br><span class="line"><span class="keyword">using</span> lr_lr_i = lr_i&amp;;   <span class="comment">// int&amp; &amp;   的类型是 int&amp;</span></span><br></pre></td></tr></table></figure><p>永远是左值引用优先，不管怎么做都无法改变左值引用绑定左值的事实。</p><p>C++不允许<code>int&amp;&amp; &amp;r = i;</code>的语法</p><h1 id="4-结构"><a href="#4-结构" class="headerlink" title="4 结构"></a>4 结构</h1><p>这个应该叫做自定义数据类型的，struct，enum，union，class等，这绝对是个大章节，想想就有很多知识点..</p><p>可别把结构体搞成这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declaration does not declare anything</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;  <span class="comment">// 声明成这样 让人咋用？</span></span><br></pre></td></tr></table></figure><p>好歹给名字让人能叫出来名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POINT</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">POINT</span> <span class="title">p</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; P;</span><br><span class="line">P p1 = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P2</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; P1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P2</span> <span class="title">p2</span>;</span></span><br><span class="line">P1 p3;</span><br></pre></td></tr></table></figure><p>我们来汇编一个结构，来看看在内存里面长啥样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">POINT</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">char</span> y;</span><br><span class="line">        <span class="type">char</span> z;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">POINT</span> <span class="title">p</span> =</span> &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;p.x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;p.y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;p.z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -8(%rbp)       # p.x</span><br><span class="line">    movb    $97, -4(%rbp)      # p.y</span><br><span class="line">    movb    $98, -3(%rbp)      # p.z</span><br><span class="line">    leaq    -8(%rbp), %rax     # 结构提名就是第一个元素的地址</span><br><span class="line">    movq    %rax, %rdx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    leaq    -8(%rbp), %rax     # 第一个元素的地址</span><br><span class="line">    movq    %rax, %rdx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    leaq    -8(%rbp), %rax</span><br><span class="line">    addq    $4, %rax           # 第二个元素地址</span><br><span class="line">    movq    %rax, %rdx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    leaq    -8(%rbp), %rax</span><br><span class="line">    addq    $5, %rax           # 第三个元素地址</span><br><span class="line">    movq    %rax, %rdx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $48, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>貌似和数组一样，结构体名字不占空间，顺着基地址往上顶就完了，那么这里就来了第一个问题，结构体在内存大小的问题，</p><h2 id="3-1-内存对齐"><a href="#3-1-内存对齐" class="headerlink" title="3.1 内存对齐"></a>3.1 内存对齐</h2><p>来看一个程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P1</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">    &#125; P1;</span><br><span class="line">    P1 p1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P2</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">    &#125; P2;</span><br><span class="line">    P2 p2 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(P1): %lld\n&quot;</span>, <span class="keyword">sizeof</span>(P1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(P2): %lld\n&quot;</span>, <span class="keyword">sizeof</span>(P2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">sizeof(P1): 8</span></span><br><span class="line"><span class="comment">sizeof(P2): 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -8(%rbp)    # p1.x</span><br><span class="line">    movb    $2, -4(%rbp)    # p1.c</span><br><span class="line">    movw    $3, -2(%rbp)    # p1.s</span><br><span class="line">    movb    $2, -20(%rbp)   # p2.c</span><br><span class="line">    movl    $1, -16(%rbp)   # p2.x</span><br><span class="line">    movw    $3, -12(%rbp)   # p2.s</span><br><span class="line">    movl    $8, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $12, %edx</span><br><span class="line">    leaq    .LC1(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $64, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>多么有意思，调个位置，占得内存大小就不一样了，画个图，很容易就能搞明白</p><p><img data-src="/assets/03_Relearning-C-Cpp-Array-and-Pointer/struct_mem_20210418183714.svg" alt="struct_mem_20210418183714"></p><p>灰色的就是被浪费了，为啥呢，因为要内存对齐，很多语言都有的特性。尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的。它一般会以2字节，4字节，8字节，16字节甚至32字节为单位来存取内存。每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认<code>#pragma pack(4)</code>，可以通过预编译命令<code>#pragma pack(n), n = 1,2,4,8,16</code>来改变这一系数。</p><p>1 对齐值</p><p>数据类型自身对齐值：基本数据类型的自身所占空间大小</p><p>指定对齐值：使用<code>#pragam pack(value)</code>时，指定的对齐值value</p><p>结构体或类的自身对齐值：其中成员对齐值最大的那个值</p><p>结构体和类的<strong>有效对齐值</strong>：自身对其值和指定对其值中较小的那个值，有效对齐值也叫<strong>对齐单位</strong>。</p><p>2 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的offset都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>3 <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p>分别解释一下P1和P2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P1，最长的数据类型是 int x; 是4，我电脑默认指定对齐值是8，那么有效对齐值就是4</span></span><br><span class="line"><span class="comment">// 第一个数据类型是 int x; offset是0，直接放进去内存</span></span><br><span class="line"><span class="comment">// 第二个数据类型是 char c; offset是成员大小(1)与有效对齐值(4)较小的那个整数倍，5比8小，紧挨着放</span></span><br><span class="line"><span class="comment">// 第三个数据类型是 short s; offset是成员大小(2)与有效对齐值(4)较小的那个整数倍，6比8小，放在6的位置，中间补个空，浪费掉</span></span><br><span class="line"><span class="comment">// 结构体总大小是有效对齐值的整数倍，此时P1的大小已经是4(x) + 1(c) + 1(补充) + 2(s) = 8 = 4 * 2，所以不用补充</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P2，最长的数据类型是 int x; 是4，我电脑默认指定对齐值是8，那么有效对齐值就是4</span></span><br><span class="line"><span class="comment">// 第一个数据是 short s; offset是0，直接放进去</span></span><br><span class="line"><span class="comment">// 第二个数据是 int x; offset是成员大小(4)与有效对齐值(4)较小的那个整数倍，那就是4，中间补2</span></span><br><span class="line"><span class="comment">// 第三个数据是 char c; offset是成员大小(1)与有效对齐值(4)较小的那个整数倍，5比8小，紧挨着放</span></span><br><span class="line"><span class="comment">// 结构体总大小是有效对齐值的整数倍，此时P2的大小是 2(s) + 2(补) + 4(x) + 1(c) = 9，对齐最小整数倍是 12 = 4 * 3，所以后面再补3</span></span><br></pre></td></tr></table></figure><p>在程序中加了那个宏就不一样了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P1</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">    &#125; P1;</span><br><span class="line">    P1 p1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)  <span class="comment">// 按2字节对齐</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P2</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">    &#125; P2;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()  <span class="comment">// 取消指定对齐，恢复默认对齐</span></span></span><br><span class="line">    P2 p2 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(P1): %lld\n&quot;</span>, <span class="keyword">sizeof</span>(P1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(P2): %lld\n&quot;</span>, <span class="keyword">sizeof</span>(P2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">sizeof(P1): 8</span></span><br><span class="line"><span class="comment">sizeof(P2): 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>那么为啥要内存对齐？经过搜索我们知道了，和CPU读取数据的效率有关，假设CPU一次能读取4个字节的数据，这时候没有内存对齐，都揉在一起了，比如P2那种情况，想要获取中间的x值，先要读取前4个字节数据，并且还要把第一个字节数据剔除掉，因为那是char的，然后再读取后面的4个字节，完了还得把后面3个去掉，最后把前面3个和后面一个拼起来才是我们想要的x的值，这工作量太大了</p><p><strong>正确处理内存对齐</strong></p><p>数组：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。<br>联合：按其包含的长度最大的数据类型对齐。<br>结构体：结构体中每个数据类型都要对齐。</p><p>建议非必要不修改默认对齐值</p><p><strong>什么时候需要设置对齐</strong></p><p>在设计不同CPU下的通信协议时，或者编写硬件驱动程序时寄存器的结构这两个地方都需要按一字节对齐。即使看起来本来就自然对齐的也要使其对齐，以免不同的编译器生成的代码不一样。</p><p><strong>针对字节对齐，我们在编程中如何考虑</strong></p><p>1 如果在编程的时候要考虑节约空间的话，那么基本的原则就是把结构中的变量按照类型大小从小到大声明，尽量减少中间的填补空间</p><p>2 以空间换取时间的效率，我们显示的进行填补空间进行对齐，比如：有一种使用空间换时间做法是显式的插入reserved成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> reserved[<span class="number">3</span>];  <span class="comment">// 使用空间换时间</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reserved成员对我们的程序没有什么意义，它只是起到填补空间以达到字节对齐的目的，当然即使不加这个成员通常编译器也会给我们自动填补对齐，我们自己加上它只是起到显式的提醒作用</p><p><strong>如何修改编译器的默认对齐值</strong></p><p>除了上面用的<code>#pragma pack(n)</code>，还有另外一种方式，<code>__attribute((aligned (n)))</code>，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。<code>__attribute__ ((packed))</code>，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">P1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">&#125; __attribute__ ((packed)) P1;</span><br></pre></td></tr></table></figure><p><strong>字节对齐可能带来的隐患</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *p1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = &amp;i;</span><br><span class="line">*p = <span class="number">0x00</span>;</span><br><span class="line">p1 = (<span class="type">unsigned</span> <span class="type">short</span> *) (p + <span class="number">1</span>);</span><br><span class="line">*p1 = <span class="number">0x0000</span>;</span><br></pre></td></tr></table></figure><p>最后两句代码，从奇数边界去访问unsignedshort型变量，显然不符合对齐的规定</p><p>在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error，因为它们要求必须字节对齐</p><h2 id="3-2-位字段"><a href="#3-2-位字段" class="headerlink" title="3.2 位字段"></a>3.2 位字段</h2><p>位字段（bit-field）是一个由具有特定数量的位组成的整数变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> x:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> y:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> z:<span class="number">1</span>;</span><br><span class="line">&#125; flag;</span><br><span class="line"></span><br><span class="line">flag f = &#123;<span class="number">0b1</span>, <span class="number">0b1</span>, <span class="number">0b1</span>&#125;;</span><br><span class="line"><span class="comment">// printf(&quot;%p&quot;, &amp;(f.x));  error: Address of bit-field requested</span></span><br></pre></td></tr></table></figure><p>这里就限制了x,y,z只有两种取值方式，0 or 1</p><p>位字段的声明格式为：<code>类型[成员名称]：宽度;</code><br>各部分的详细描述如下：</p><p>(1) 类型<br>指定一个整数类型，用来决定该位字段值被解释的方式。类型可以是 _Bool、int、signed int、unsigned int，或者为所选实现版本所提供的类型。这里的类型也可以包含类型限定符。</p><p>具有 signed int 类型的位字段会被解释成有符号数；具有 unsigned int 类型的位字段会被解释成无符号数。具有 int 类型的位字段可以是有符号或无符号的类型，由编译器决定。</p><p>(2) 成员名称<br>成员名称是可选的（可以不写）。但是，如果声明了一个无名称的位字段，就没有办法获取它。没有名称的位字段只能用于填充（padding），以帮助后续的位字段在机器字中对齐到特定的地址边界。</p><p>(3) 宽度<br>位字段中位的数量。宽度必须是一个常量整数表达式，其值是非负的，并且必须小于或等于指定类型的位宽。无名称位字段的宽度可以是 0。在这种情况下，下一个声明的位字段就会从新的可寻址内存单元开始。</p><p>呃，感觉没啥好介绍的..</p><p><strong>字段不是数组，并且没有地址，因此不能对它们使用 &amp; 运算符</strong></p><h2 id="3-3-零长数组"><a href="#3-3-零长数组" class="headerlink" title="3.3 零长数组"></a>3.3 零长数组</h2><p>看一个程序吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">char</span>* data;</span><br><span class="line">    &#125; STR1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">    &#125; STR2;</span><br><span class="line"></span><br><span class="line">    STR1 str1 = &#123;&#125;;</span><br><span class="line">    STR2 str2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STR1: %llu\n&quot;</span>, <span class="keyword">sizeof</span>(STR1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STR2: %llu\n&quot;</span>, <span class="keyword">sizeof</span>(STR2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">STR1: 16</span></span><br><span class="line"><span class="comment">STR2: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这么一看，差距还挺大的，对不对，汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movq    $0, -16(%rbp)  # STR1.len</span><br><span class="line">    movq    $0, -8(%rbp)   # STR1.data</span><br><span class="line">    movl    $0, -20(%rbp)  # STR2.len</span><br><span class="line">    movl    $16, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $4, %edx</span><br><span class="line">    leaq    .LC1(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $64, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>为什么是16，能想得明白哈，中间补了4个。零长数组优点</p><p>第一，节省内存。从上面的例子中可以看出，零长度数组不占用内存空间，而指针却占用内存空间。</p><p>第二，方便内存释放。如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。</p><p>第三，这样有利于访问速度。连续的内存有益于提高访问速度，也有益于减少内存碎片。</p><p>但是有个缺点，在结构体中，数组为0的数组必须在最后声明，使用上有一定限制。</p><p>我发现一个有意思的事情，下面这程序..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span>* data;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">    &#125; STR1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">    &#125; STR2;</span><br><span class="line"></span><br><span class="line">    STR1 str1 = &#123;&#125;;</span><br><span class="line">    STR2 str2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str1.data) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--before STR1--\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--%s\n&quot;</span>, str1.data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--before STR1--\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!str2.data) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--before STR2--\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--%s\n&quot;</span>, str2.data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--before STR2--\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">--before STR1--</span></span><br><span class="line"><span class="comment">--(null)</span></span><br><span class="line"><span class="comment">--before STR1--</span></span><br><span class="line"><span class="comment">--before STR2--</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--before STR2--</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="3-4-结构体指针"><a href="#3-4-结构体指针" class="headerlink" title="3.4 结构体指针"></a>3.4 结构体指针</h2><p>这个其实没啥好说的，主要就是认识一下两个运算符”.”和”-&gt;”，正好使用一下0长数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">0</span>];</span><br><span class="line">    &#125; STR;</span><br><span class="line"></span><br><span class="line">    STR *str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 一次开辟</span></span><br><span class="line">    <span class="keyword">if</span> ((str = (STR *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STR) + <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        str-&gt;len = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(str-&gt;data, <span class="string">&quot;hello!&quot;</span>, str-&gt;len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是结构体对象就用 . 如果是指针就用 -&gt;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len: %d, data: %s\n&quot;</span>, (*str).len, str-&gt;data);</span><br><span class="line">    <span class="comment">// 一次销毁</span></span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的，好像也没啥了</p><h1 id="5-联合与枚举"><a href="#5-联合与枚举" class="headerlink" title="5 联合与枚举"></a>5 联合与枚举</h1><p>union和enum，这俩</p><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">short</span> b;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125; U;</span><br><span class="line"></span><br><span class="line">    U u = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, u.a, u.b, u.c);</span><br><span class="line">    u.b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, u.a, u.b, u.c);</span><br><span class="line">    u.c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, u.a, u.b, u.c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n%p\n%p\n%p\n&quot;</span>, &amp;u, &amp;u.a, &amp;u.b, &amp;u.c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">1, 1, 1</span></span><br><span class="line"><span class="comment">2, 2, 2</span></span><br><span class="line"><span class="comment">3, 3, 3</span></span><br><span class="line"><span class="comment">000000000063FE1C</span></span><br><span class="line"><span class="comment">000000000063FE1C</span></span><br><span class="line"><span class="comment">000000000063FE1C</span></span><br><span class="line"><span class="comment">000000000063FE1C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">    ...</span><br><span class="line">    .seh_endprologue</span><br><span class="line">    call    __main</span><br><span class="line">    movl    $1, -4(%rbp)    # u.a = 1</span><br><span class="line">    movzbl    -4(%rbp), %eax</span><br><span class="line">    movsbl    %al, %ecx</span><br><span class="line">    movzwl    -4(%rbp), %eax</span><br><span class="line">    movswl    %ax, %edx</span><br><span class="line">    movl    -4(%rbp), %eax</span><br><span class="line">    movl    %ecx, %r9d</span><br><span class="line">    movl    %edx, %r8d</span><br><span class="line">    movl    %eax, %edx</span><br><span class="line">    leaq    .LC0(%rip), %rcx</span><br><span class="line">    call    printf</span><br><span class="line">    movw    $2, -4(%rbp)     # u.b = 2</span><br><span class="line">    ...</span><br><span class="line">    movb    $3, -4(%rbp)      # u.c = 3</span><br><span class="line">    ...</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    addq    $48, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>实际上union就是struct，只不过union所有的成员相对于基地址的偏移量都是0</p><p>再看enum</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure><p>仅仅给出了名字，却没有给出名字对应的值，这是因为枚举值默认从0开始，往后逐个加（递增）；也就是说，week中的Mon、Tues … Sun 对应的值分别为 0、1 … 6。</p><p>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏</p><p>枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量</p><p>Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量</p><p>Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用<code>&amp;</code>取得它们的地址。这就是枚举的本质</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组和指针一般不能分开，尤其是C语言里面，让人又爱又恨的东西..而一谈到这俩玩意就得画图..&lt;/p&gt;
&lt;h1 id=&quot;1-数组&quot;&gt;&lt;a href=&quot;#1-数组&quot; class=&quot;headerlink&quot; title=&quot;1 数组&quot;&gt;&lt;/a&gt;1 数组&lt;/h1&gt;&lt;p&gt;对数组下定义，抱歉，我不会。但是我有词典，a way of organizing and storing related data in a computer memory。这么一看就清晰多了&lt;/p&gt;
&lt;p&gt;元素类型为char的数组可以如下声明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int c[6];  // 可以存6个整数的数组&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在声明中&lt;code&gt;[]&lt;/code&gt;表示xxx的数组，所有数组下标都是从0开始，计算机中很多东西都是从0开始，为什么？搜索一下吧。数组的大小，就是那个6，必须得是个常量表达式，这么看，数组一旦定义好了大小就定下来了呀&lt;/p&gt;
&lt;p&gt;数组名也是标识符，也要符合规则，不能和其他变量重名&lt;/p&gt;
&lt;p&gt;数组初始化的时候可以部分初始化，也可以整体初始化；赋值的时候不能整体赋值，只能单个元素得赋值(数组拷贝，那个不算)&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="https://sidneyding.cn/categories/Language/"/>
    
    <category term="C/Cpp" scheme="https://sidneyding.cn/categories/Language/C-Cpp/"/>
    
    
    <category term="Relearning C/Cpp" scheme="https://sidneyding.cn/tags/Relearning-C-Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Build a leanote server</title>
    <link href="https://sidneyding.cn/posts/5d13faf3/"/>
    <id>https://sidneyding.cn/posts/5d13faf3/</id>
    <published>2020-08-23T10:05:55.000Z</published>
    <updated>2022-06-05T09:34:21.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Prepare"><a href="#1-Prepare" class="headerlink" title="1 Prepare"></a>1 Prepare</h1><p>You need a server. My server OS is CentOS 7.2. You can also use other versions of Linux. Ok, let’s get started.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">yum install git  # config your git</span><br><span class="line">git config --global user.name=UserName</span><br><span class="line">git config --global user.email=xx@yy.zz</span><br><span class="line">mkdir /usr/local/apps</span><br><span class="line">mkdir ~/tmp</span><br><span class="line">cd ~/tmp</span><br></pre></td></tr></table></figure><h1 id="2-Install-Golang"><a href="#2-Install-Golang" class="headerlink" title="2 Install Golang"></a>2 Install Golang</h1><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">download golang</span></span><br><span class="line">wget https://golang.google.cn/dl/go1.15.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unzip</span></span><br><span class="line">tar -zxvf go1.15.linux-amd64.tar.gz -C /usr/local/apps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configure the golang environment variable</span></span><br><span class="line">vim /etc/profile</span><br><span class="line">    # golang</span><br><span class="line">    export GOROOT=/usr/local/apps/go</span><br><span class="line">    export GOPATH=/usr/local/apps/gopackage</span><br><span class="line">    export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">refresh profile</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">check golang</span></span><br><span class="line">go version</span><br></pre></td></tr></table></figure><h1 id="3-Install-Mongodb"><a href="#3-Install-Mongodb" class="headerlink" title="3 Install Mongodb"></a>3 Install Mongodb</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">download mongodb</span></span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.20.tgz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unzip</span> </span><br><span class="line">tar -zxvf mongodb-linux-x86_64-4.0.20.tgz -C /usr/local/apps</span><br><span class="line">cd /usr/local/apps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rename</span></span><br><span class="line">mv mongodb-linux-x86_64-4.0.20 mongodb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Configure Mongodb</span></span><br><span class="line">cd mongodb</span><br><span class="line">mkdir -p data/db</span><br><span class="line">mkdir -p data/log</span><br><span class="line">mkdir conf</span><br><span class="line">vim conf/mongodb.conf</span><br><span class="line">    # port</span><br><span class="line">    port=27017</span><br><span class="line">    # database path</span><br><span class="line">    dbpath=/usr/local/apps/mongodb/data/db</span><br><span class="line">    # log path</span><br><span class="line">    logpath=/usr/local/apps/mongodb/data/log/mongodb.log</span><br><span class="line">    pidfilepath=/usr/local/apps/mongodb/data/mongo.pid </span><br><span class="line">    # run in background</span><br><span class="line">    fork=true</span><br><span class="line">    # log output mode</span><br><span class="line">    logappend=true</span><br><span class="line">    # your server private IP</span><br><span class="line">    bind_ip=127.0.0.1[,private IP]</span><br><span class="line">    # max connection count</span><br><span class="line">    maxConns=200</span><br><span class="line">vim /etc/profile</span><br><span class="line">    # mongo</span><br><span class="line">    export PATH=$PATH:/usr/local/apps/mongodb/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start mongodb service</span></span><br><span class="line">mongod --config /usr/local/apps/mongodb/conf/mongodb.conf</span><br><span class="line">mongo</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h1 id="4-Install-Leanote"><a href="#4-Install-Leanote" class="headerlink" title="4 Install Leanote"></a>4 Install Leanote</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">cd ~/tmp</span><br><span class="line">git clone https://github.com/leanote/leanote-all.git --depth=1</span><br><span class="line">mkdir /usr/local/apps/gopackage</span><br><span class="line">cp -r leanote-all/src/ gopackage/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install revel</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">go get github.com/revel/cmd/revel  <span class="comment"># timeout!</span></span></span><br><span class="line">mkdir -p /usr/local/apps/go/src/golang.org/x/</span><br><span class="line">cd /usr/local/apps/go/src/golang.org/x/</span><br><span class="line">git clone https://github.com/golang/net.git --depth=1</span><br><span class="line">git clone https://github.com/golang/crypto.git --depth=1</span><br><span class="line">git clone https://github.com/golang/sys.git --depth=1</span><br><span class="line">git clone https://github.com/golang/tools.git --depth=1</span><br><span class="line">git clone https://github.com/golang/mod.git --depth=1</span><br><span class="line">git clone https://github.com/golang/xerrors.git --depth=1</span><br><span class="line">cd /usr/local/apps/go/bin</span><br><span class="line">go build github.com/revel/cmd/revel</span><br><span class="line">revel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">init data</span></span><br><span class="line">mongorestore -h 127.0.0.1(your server private IP) -d leanote --dir /usr/local/apps/gopackage/src/github.com/leanote/leanote/mongodb_backup/leanote_install_data</span><br><span class="line">mongo</span><br><span class="line">show dbs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> there is a leanote database, it means that the initialization data is successful.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create a super administrator</span></span><br><span class="line">use admin</span><br><span class="line">db.createUser(&#123;user: &#x27;root&#x27;, pwd: &#x27;root&#x27;, roles: [&#x27;clusterAdmin&#x27;, &#x27;dbAdminAnyDatabase&#x27;, &#x27;userAdminAnyDatabase&#x27;, &#x27;readWriteAnyDatabase&#x27;]&#125;)</span><br><span class="line">db.auth(&#x27;root&#x27;, &#x27;root&#x27;)</span><br><span class="line"></span><br><span class="line">use leanote</span><br><span class="line">db.createUser(&#123;user: &#x27;leanote&#x27;, pwd: &#x27;leanotepwd&#x27;, roles: [&#x27;readWrite&#x27;]&#125;)</span><br><span class="line">db.auth(&#x27;leanote&#x27;, &#x27;leanotepwd&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">stop mongodb service and quit</span></span><br><span class="line">use admin</span><br><span class="line">db.shutdownServer()</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h1 id="5-Configure-Leanote"><a href="#5-Configure-Leanote" class="headerlink" title="5 Configure Leanote"></a>5 Configure Leanote</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/apps/gopackage</span><br><span class="line">vim src/github.com/leanote/leanote/conf/app.conf</span><br><span class="line">    # you website public ip or url</span><br><span class="line">    site.url=http://www.example.com:9000</span><br><span class="line">    # mongodb</span><br><span class="line">    db.username=leanote</span><br><span class="line">    db.password=leanotepwd</span><br><span class="line">    # You Must Change It !!!</span><br><span class="line">    app.secret=[you can modify it at will]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start mongodb service</span></span><br><span class="line">mongod --auth --config /usr/local/apps/mongodb/conf/mongodb.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start leanote</span></span><br><span class="line">nohup revel run src/github.com/leanote/leanote &gt;leanote.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>Now, you can try to open <a href="http://www.example.com:9000/">www.example.com:9000</a> !<br><strong>The default account is admin and password is abc123.</strong></p><h1 id="6-Other"><a href="#6-Other" class="headerlink" title="6 Other"></a>6 Other</h1><h2 id="6-1-MongoDB-Error"><a href="#6-1-MongoDB-Error" class="headerlink" title="6.1 MongoDB Error"></a>6.1 MongoDB Error</h2><p><strong>ERROR: child process failed, exited with error number 48 To see additional information in this outpu</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start in repair mode again</span></span><br><span class="line">./mongod --dbpath=/usr/local/apps/mongodb/data/db --logpath=/usr/local/apps/mongodb/data/log/mongodb.log --repair</span><br><span class="line"><span class="comment"># According to the tips to fix! and kill mongod</span></span><br><span class="line">pkill mongod</span><br><span class="line"><span class="comment"># restart mongodb</span></span><br><span class="line">mongod --auth --config /usr/local/apps/mongodb/conf/mongodb.conf</span><br></pre></td></tr></table></figure><h2 id="6-2-Config-Nginx"><a href="#6-2-Config-Nginx" class="headerlink" title="6.2 Config Nginx"></a>6.2 Config Nginx</h2><p>reference: <a href="https://developer.aliyun.com/article/699966">https://developer.aliyun.com/article/699966</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install nginx</span></span><br><span class="line">yum install -y nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># after install successfully,</span></span><br><span class="line"><span class="comment"># the default web dir： /usr/share/nginx/html</span></span><br><span class="line"><span class="comment"># the default config file：/etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Open ports 80 and 443.</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># modify /etc/nginx/nginx.conf</span></span><br><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">-        server_name  _;</span><br><span class="line">+        server_name  101.132.124.174;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line">...</span><br><span class="line">        location / &#123;</span><br><span class="line">+            proxy_pass  http://127.0.0.1:9000;</span><br><span class="line">+            proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">+            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">+            proxy_set_header X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment"># start or restart nginx</span></span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>If nginx did not work, please run “systemctl status nginx” to check. If there is a log for:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to parse PID from file /run/nginx.pid: Invalid argument</span><br></pre></td></tr></table></figure><p>Please try the following:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /etc/systemd/system/nginx.service.d</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;[Service]\nExecStartPost=/bin/sleep 0.1\n&quot;</span> &gt; /etc/systemd/system/nginx.service.d/override.conf</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart nginx.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># check again</span></span><br><span class="line">service nginx status</span><br></pre></td></tr></table></figure><p>All is over, have fun!</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-Prepare&quot;&gt;&lt;a href=&quot;#1-Prepare&quot; class=&quot;headerlink&quot; title=&quot;1 Prepare&quot;&gt;&lt;/a&gt;1 Prepare&lt;/h1&gt;&lt;p&gt;You need a server. My server OS is CentOS 7.2. You can also use other versions of Linux. Ok, let’s get started.&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;su&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install git  # config your git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name=UserName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email=xx@yy.zz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir /usr/local/apps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir ~/tmp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd ~/tmp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&quot;2-Install-Golang&quot;&gt;&lt;a href=&quot;#2-Install-Golang&quot; class=&quot;headerlink&quot; title=&quot;2 Install Golang&quot;&gt;&lt;/a&gt;2 Install Golang&lt;/h1&gt;</summary>
    
    
    
    <category term="Other" scheme="https://sidneyding.cn/categories/Other/"/>
    
    
    <category term="leanote" scheme="https://sidneyding.cn/tags/leanote/"/>
    
    <category term="blog" scheme="https://sidneyding.cn/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Build FreeRADIUS server based on Ubuntu18</title>
    <link href="https://sidneyding.cn/posts/cb75f049/"/>
    <id>https://sidneyding.cn/posts/cb75f049/</id>
    <published>2020-08-22T14:46:36.000Z</published>
    <updated>2022-06-05T09:34:28.380Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><p><a href="https://www.cnblogs.com/opsprobe/p/9420502.html">https://www.cnblogs.com/opsprobe/p/9420502.html</a></p><p><a href="https://blog.csdn.net/lassewang/article/details/9159543">https://blog.csdn.net/lassewang/article/details/9159543</a></p><h1 id="0-RADIUS"><a href="#0-RADIUS" class="headerlink" title="0 RADIUS"></a>0 RADIUS</h1><p>RADIUS：（Remote Authentication Dial In User Service）中文名为远程用户拨号认证服务，简称RADIUS，是目前应用最广泛的AAA协议（认证、授权和计费）</p><p><img data-src="/assets/Build-FreeRADIUS-server-based-on-Ubuntu18/202205243456723.png" alt="202205243456723"></p><p>图中Device（例如交换机）向远程接入用户提供接入及与RADIUS服务器交互的服务。RADIUS服务器上则存储用户的身份信息、授权信息以及访问记录，对用户进行认证、授权和计费服务</p><p><strong>认证过程如下</strong></p><p>（1）客户端向接入设备发送一个EAPoL-Start报文，开始802.1x认证接入；</p><p>（2）接入设备向客户端发送EAP-Request&#x2F;Identity报文，要求客户端将用户名送上来；</p><span id="more"></span><p>（3）客户端回应一个EAP-Response&#x2F;Identity给接入设备的请求，其中包括用户名；</p><p>（4）接入设备将EAP-Response&#x2F;Identity报文封装到RADIUS Access-Request报文中，发送给认证服务器；</p><p>（5）认证服务器产生一个Challenge，通过接入设备将RADIUS Access-Challenge报文发送给客户端，其中包含有EAP-Request&#x2F;MD5-Challenge；</p><p>（6）接入设备通过EAP-Request&#x2F;MD5-Challenge发送给客户端，要求客户端进行认证；</p><p>（7）客户端收到EAP-Request&#x2F;MD5-Challenge报文后，将密码和Challenge做MD5算法后的Challenged-Pass-word，在EAP-Response&#x2F;MD5-Challenge回应给接入设备；</p><p>（8）接入设备将Challenge，Challenged Password和用户名一起送到RADIUS服务器，由RADIUS服务器进行认证；</p><p>（9）RADIUS服务器根据用户信息，做MD5算法，判断用户是否合法，然后回应认证成功&#x2F;失败报文到接入设备。如果成功，携带协商参数，以及用户的相关业务属性给用户授权。如果认证失败，则流程到此结束；</p><p>（10）如果认证通过，用户通过标准的DHCP协议 (可以是DHCP Relay) ，通过接入设备获取规划的IP地址；</p><p>（11）如果认证通过，接入设备发起计费开始请求给RADIUS用户认证服务器；</p><p>（12）RADIUS用户认证服务器回应计费开始请求报文，用户上线完毕。</p><p>freeradius是GNU&#x2F;GPL（通用公共许可证）的原则下，开发的高性能开源radius服务器。常见的radius服务器种类不多，比较强大的当属开源的freeradius，世界上大部分的radius服务器都是基于freeradius开发而来的。</p><p>freeradius可以对支持radius协议的网络设备进行账户认证、授权和记账管理，常见的开源路由器操作系统：如Openwrt，DD-wrt等，都支持radius协议，常见的电信运营商的宽带账户，上网账户管理，记账，也都是使用的radius服务器进行鉴权记账的。</p><p>RADIUS服务器和NAS服务器通过UDP协议进行通信，RADIUS服务器的1812端口负责认证，1813端口负责计费工作。采用UDP的基本考虑是因为NAS和RADIUS服务器大多在同一个局域网中，使用UDP更加快捷方便，而且UDP是无连接的，会减轻RADIUS的压力，也更安全。</p><p>以下均在Ubuntu18上操作的，Ubuntu16上坑太多..看网上教程，CentOS更多..</p><h1 id="1-安装Apache-Web-Server和PHP"><a href="#1-安装Apache-Web-Server和PHP" class="headerlink" title="1 安装Apache Web Server和PHP"></a>1 安装Apache Web Server和PHP</h1><p>在Ubuntu上安装Apache，运行以下命令安装Apache Web服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure><p>要在Ubuntu 18.04上安装PHP，请运行(<strong>直接运行可能会不成功，因为没这个源</strong>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php libapache2-mod-php php-gd php-common php-mail \</span><br><span class="line">    php-mail-mime php-mysql php-pear php-db php-mbstring php-xml php-curl</span><br></pre></td></tr></table></figure><p>PHP安装：</p><p>1 添加PHP PPA</p><p>添加ondrej&#x2F;php，它包含PHP包和其他必需的PHP扩展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>通过复制以下代码并将其添加到系统的软件源中，可以手动将此PPA添加到系统中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 18.04 拷贝</span></span><br><span class="line">deb http://ppa.launchpad.net/ondrej/php/ubuntu bionic main </span><br><span class="line">deb-src http://ppa.launchpad.net/ondrej/php/ubuntu bionic main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加源</span></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装PHP</span></span><br><span class="line">sudo apt-get install php libapache2-mod-php php-gd php-common php-mail \</span><br><span class="line">    php-mail-mime php-mysql php-pear php-db php-mbstring php-xml php-curl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">php -v</span><br></pre></td></tr></table></figure><h1 id="2-安装MariaDB并创建数据库"><a href="#2-安装MariaDB并创建数据库" class="headerlink" title="2 安装MariaDB并创建数据库"></a>2 安装MariaDB并创建数据库</h1><p>MariaDB是MySQL的一个分支，目前最新稳定版是10.5，以下是安装步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装software-properties-common</span></span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line"><span class="comment"># 导入MariaDB gpg密钥</span></span><br><span class="line">ssudo apt-key adv --fetch-keys <span class="string">&#x27;https://mariadb.org/mariadb_release_signing_key.asc&#x27;</span></span><br><span class="line"><span class="comment"># 添加apt存储库</span></span><br><span class="line">sudo add-apt-repository <span class="string">&#x27;deb [arch=amd64,arm64,ppc64el] https://mirrors.tuna.tsinghua.edu.cn/mariadb/repo/10.5/ubuntu bionic main&#x27;</span></span><br><span class="line"><span class="comment"># 安装MariaDB Server</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt -y install mariadb-server mariadb-client</span><br></pre></td></tr></table></figure><p>安装并运行后，为FreeRADIUS创建一个数据库，这将在稍后阶段使用：</p><p>数据库名称：radius</p><p>数据库用户：radius</p><p>数据库用户密码：radiuspassword</p><p>如果你有专用数据库服务器，请将localhost替换为源FreeRadius服务器的IP：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次使用，初始化MariaDB</span></span><br><span class="line">sudo mysql_secure_installation</span><br><span class="line"><span class="comment"># 大致会经历这几个阶段</span></span><br><span class="line">Switch to unix_socket authentication [Y/n] &gt;&gt; [直接Enter] 切换到unix_socket身份验证</span><br><span class="line">Change the root password? [Y/n] y</span><br><span class="line">New password: </span><br><span class="line">Re-enter new password:</span><br><span class="line">Remove anonymous <span class="built_in">users</span>? [Y/n] &gt;&gt; [直接Enter] 是否删除匿名用户</span><br><span class="line">Disallow root login remotely? [Y/n]  &gt;&gt; [直接Enter] 禁止远程root角色登录</span><br><span class="line">Remove <span class="built_in">test</span> database and access to it? [Y/n] &gt;&gt; [直接Enter] 是否删除<span class="built_in">test</span>数据库</span><br><span class="line">Reload privilege tables now? [Y/n] &gt;&gt; [直接Enter] 是否重新加载权限表</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># 输入密码 登录成功后在MariaDB中创建数据库</span></span><br><span class="line">CREATE DATABASE radius;</span><br><span class="line"><span class="comment"># 设置通过root:password可以在任何PC上访问数据库 方便其他电脑上用navicat或datagrip</span></span><br><span class="line">GRANT ALL ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&quot;password&quot;</span>;</span><br><span class="line"><span class="comment"># 设置通过 radius:radiuspassword 访问radius数据库</span></span><br><span class="line">GRANT ALL ON radius.* TO <span class="string">&#x27;radius&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&quot;radiuspassword&quot;</span>;</span><br><span class="line"><span class="comment"># 重新载入权限</span></span><br><span class="line">flush privileges;</span><br><span class="line"><span class="comment"># 退出MariaDB</span></span><br><span class="line">\q</span><br></pre></td></tr></table></figure><blockquote><p>完全卸载MySQL&#x2F;MariaDB</p><p>首先删除mysql:<br><code>sudo apt-get remove mysql-*</code><br>然后清理残留的数据<br><code>dpkg -l |grep ^rc|awk &#39;&#123;print $2&#125;&#39; |sudo xargs dpkg -P</code></p><ul><li>查看状态 <code>sudo systemctl status mysql</code></li><li>启动 <code>sudo systemctl start mysql</code></li><li>重启 <code>sudo systemctl restart mysql</code></li><li>关闭 <code>sudo systemctl stop mysql</code></li></ul></blockquote><h1 id="3-安装和配置FreeRADIUS"><a href="#3-安装和配置FreeRADIUS" class="headerlink" title="3 安装和配置FreeRADIUS"></a>3 安装和配置FreeRADIUS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Ubuntu 18.04上安装的FreeRADIUS版本是v3.0，使用以下命令从官方Ubuntu apt存储库安装</span></span><br><span class="line">sudo apt-get install freeradius freeradius-mysql freeradius-utils</span><br><span class="line"><span class="comment"># 检测是否安装成功</span></span><br><span class="line">ps -ef | grep freeradius</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看普通用户是否有读取文件权限</span></span><br><span class="line">ll /etc/freeradius/3.0/mods-config/sql/main/mysql/schema.sql</span><br><span class="line"><span class="comment"># 改权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 666 /etc/freeradius/3.0/mods-config/sql/main/mysql/schema.sql</span><br><span class="line"><span class="comment"># 导入freeradius MySQL数据库方案</span></span><br><span class="line">mysql -u root -p radius &lt; /etc/freeradius/3.0/mods-config/sql/main/mysql/schema.sql</span><br><span class="line"><span class="comment"># 查看创建的表</span></span><br><span class="line">mysql -u root -p -e <span class="string">&quot;use radius; show tables;&quot;</span></span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_radius |</span><br><span class="line">+------------------+</span><br><span class="line">| nas              |</span><br><span class="line">| radacct          |</span><br><span class="line">| radcheck         |</span><br><span class="line">| radgroupcheck    |</span><br><span class="line">| radgroupreply    |</span><br><span class="line">| radpostauth      |</span><br><span class="line">| radreply         |</span><br><span class="line">| radusergroup     |</span><br><span class="line">+------------------+</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/freeradius/3.0/mods-enabled/下为sql模块创建一个软链接</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /etc/freeradius/3.0/mods-available/sql /etc/freeradius/3.0/mods-enabled/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置SQL模块并更改数据库连接参数以适合你的环境</span></span><br><span class="line">sudo vim /etc/freeradius/3.0/mods-enabled/sql</span><br><span class="line">   <span class="comment"># 修改</span></span><br><span class="line">    sql &#123;</span><br><span class="line">        driver = <span class="string">&quot;rlm_sql_mysql&quot;</span></span><br><span class="line">        dialect = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">        <span class="comment"># Connection info:</span></span><br><span class="line">        server = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">        port = 3306</span><br><span class="line">        login = <span class="string">&quot;radius&quot;</span></span><br><span class="line">        password = <span class="string">&quot;radiuspassword&quot;</span></span><br><span class="line">        <span class="comment"># Database table configuration for everything except Oracle</span></span><br><span class="line">        radius_db = <span class="string">&quot;radius&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set to ‘yes’ to read radius clients from the database (‘nas’ table)</span></span><br><span class="line">        <span class="comment"># Clients will ONLY be read on server startup.</span></span><br><span class="line">        read_clients = <span class="built_in">yes</span></span><br><span class="line">        <span class="comment"># Table to keep radius client info</span></span><br><span class="line">        client_table = <span class="string">&quot;nas&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 更改/etc/freeradius/3.0/mods-enabled/sql的组权限</span></span><br><span class="line">sudo <span class="built_in">chgrp</span> -h freerad /etc/freeradius/3.0/mods-available/sql</span><br><span class="line">sudo <span class="built_in">chown</span> -R freerad:freerad /etc/freeradius/3.0/mods-enabled/sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启freeradius服务</span></span><br><span class="line">sudo systemctl restart freeradius.service</span><br></pre></td></tr></table></figure><h1 id="4-安装和配置Daloradius"><a href="#4-安装和配置Daloradius" class="headerlink" title="4 安装和配置Daloradius"></a>4 安装和配置Daloradius</h1><p>我们需要安装Daloradius才能获得FreeRADIUS Web管理界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载Daloradius</span></span><br><span class="line">wget https://github.com/lirantal/daloradius/archive/master.zip</span><br><span class="line">unzip master.zip</span><br><span class="line"><span class="built_in">mv</span> daloradius-master/ daloradius</span><br><span class="line"><span class="built_in">cd</span> daloradius</span><br><span class="line"><span class="comment"># 配置daloradius，现在导入Daloradius mysql表</span></span><br><span class="line">mysql -u root -p radius &lt; contrib/db/fr2-mysql-daloradius-and-freeradius.sql</span><br><span class="line">mysql -u root -p radius &lt; contrib/db/mysql-daloradius.sql</span><br><span class="line"><span class="comment"># 配置daloRADIUS数据库连接详细信息</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">sudo <span class="built_in">mv</span> daloradius /var/www/html/</span><br><span class="line"><span class="comment"># 更改http文件夹的权限并为daloradius配置文件设置正确的权限</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R www-data:www-data /var/www/html/daloradius/</span><br><span class="line">sudo <span class="built_in">chmod</span> 664 /var/www/html/daloradius/library/daloradius.conf.php</span><br><span class="line"><span class="comment"># 修改filedaloradius.conf.php以调整数据库信息 对应/etc/freeradius/3.0/mods-enabled/sql</span></span><br><span class="line">sudo vim /var/www/html/daloradius/library/daloradius.conf.php</span><br><span class="line">    <span class="comment"># 主要是</span></span><br><span class="line">    CONFIG_DB_USER</span><br><span class="line">    CONFIG_DB_PASS</span><br><span class="line">    CONFIG_DB_NAME</span><br><span class="line"><span class="comment"># 重新启动freeradius和apache2</span></span><br><span class="line">systemctl restart freeradius apache2</span><br></pre></td></tr></table></figure><p>打开浏览器，访问**<code>http://ip-address/daloradius/login.php</code>**</p><p><img data-src="/assets/Build-FreeRADIUS-server-based-on-Ubuntu18/image-20200822142751997.png" alt="image-20200822142751997"></p><p>默认的管理员账户密码是 administrator:radius</p><blockquote><p>查看syslog和daloradius.log时，可能会报错，修改syslog权限为644即可，加到用户组或许效果更好；至于daloradius.log去Config&gt;Logging Settings中把想要监听的log设置成yes就好了</p></blockquote><h1 id="5-修改FreeRADIUS测试账户"><a href="#5-修改FreeRADIUS测试账户" class="headerlink" title="5 修改FreeRADIUS测试账户"></a>5 修改FreeRADIUS测试账户</h1><p>FreeRADIUS的配置默认是文件，打开测试账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/freeradius/3.0/users</span><br><span class="line">    <span class="comment"># 找到下面这段信息 注释全打开</span></span><br><span class="line">    73     steve   Cleartext-Password := <span class="string">&quot;testing&quot;</span></span><br><span class="line">    74     Service-Type = Framed-User,</span><br><span class="line">    75     Framed-Protocol = PPP,</span><br><span class="line">    76     Framed-IP-Address = 172.16.3.33,</span><br><span class="line">    77     Framed-IP-Netmask = 255.255.255.0,</span><br><span class="line">    78     Framed-Routing = Broadcast-Listen,</span><br><span class="line">    79     Framed-Filter-Id = <span class="string">&quot;std.ppp&quot;</span>,</span><br><span class="line">    80     Framed-MTU = 1500,</span><br><span class="line">    81     Framed-Compression = Van-Jacobsen-TCP-IP</span><br></pre></td></tr></table></figure><p>配置路由器或交换机的账号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/freeradius/3.0/clients.conf</span><br><span class="line">    <span class="comment"># 按照这个格式 里面有个localhost 用作本机测试的</span></span><br><span class="line">    client x.x.x.x &#123;  <span class="comment"># 路由器或交换机的ip</span></span><br><span class="line">        ipaddr = x.x.x.x  <span class="comment"># 路由器或交换机的ip</span></span><br><span class="line">        secret = xxxxx  <span class="comment"># 路由器或交换机访问radius的密码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重新开一终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改了配置文件 需要重启一下服务</span></span><br><span class="line">service freeradius restart</span><br><span class="line"><span class="comment"># 测试账户 接收到 Received Access-Accept 就表示没问题了</span></span><br><span class="line">radtest steve testing localhost 1812 testing123</span><br><span class="line"><span class="comment"># radtest 账号 密码 client_ip radius端口 client_secret</span></span><br></pre></td></tr></table></figure><p>这也确实，表明FreeRADIUS是通过文件进行配置的，接下来将其改为sql模式，上面改得差不多了，再改俩就行</p><p>修改配置文件<code>/etc/freeradius/3.0/sites-enabled/default</code></p><p>1 找到<code>authorize &#123;</code>(273行)，注释其中的<code>files</code>，并将<code>sql</code>去掉注释或<code>-</code></p><p>2 找到<code>preacct &#123;</code>(555行)，注释其中的<code>files</code></p><p>3 找到<code>accounting &#123;</code>(608行)，去掉<code>sql</code>的注释或<code>-</code></p><p>4 找到<code>session &#123;</code>(677行)，去掉<code>sql</code>的注释或<code>-</code></p><p>5 找到<code>post-auth &#123;</code>(689行)，去掉<code>sql</code>的注释或<code>-</code></p><p>6 找到<code>pre-proxy &#123;</code>(861行)，注释掉<code>files</code></p><p>修改配置文件<code>/etc/freeradius/3.0/sites-enabled/inner-tunnel</code>，和上面一样，注释掉<code>files</code>，去掉<code>sql</code>的注释或<code>-</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启一下相关的服务</span></span><br><span class="line">service mysql restart</span><br><span class="line">service apache2 restart</span><br><span class="line">service freeradius restart</span><br></pre></td></tr></table></figure><hr><p>下面进行测试，直接进入MySQL可以通过Navicat或者直接终端(<code>mysql -u root -p; use radius;</code>)，输入下面的sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户组</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radgroupreply (groupname, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;locahost&#x27;</span>, <span class="string">&#x27;Service-Type&#x27;</span>, <span class="string">&#x27;:=&#x27;</span>, <span class="string">&#x27;Framed-User&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radgroupreply (groupname, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;locahost&#x27;</span>, <span class="string">&#x27;Framed-Protocol&#x27;</span>, <span class="string">&#x27;:=&#x27;</span>, <span class="string">&#x27;PPP&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radgroupreply (groupname, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;locahost&#x27;</span>, <span class="string">&#x27;Framed-IP-Address&#x27;</span>, <span class="string">&#x27;:=&#x27;</span>, <span class="string">&#x27;192.168.1.109&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radgroupreply (groupname, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;locahost&#x27;</span>, <span class="string">&#x27;Framed-IP-Netmask&#x27;</span>, <span class="string">&#x27;:=&#x27;</span>, <span class="string">&#x27;255.255.255.0&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radgroupreply (groupname, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;locahost&#x27;</span>, <span class="string">&#x27;Framed-Routing&#x27;</span>, <span class="string">&#x27;:=&#x27;</span>, <span class="string">&#x27;Broadcast-Listen&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radgroupreply (groupname, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;locahost&#x27;</span>, <span class="string">&#x27;Framed-Filter-Id&#x27;</span>, <span class="string">&#x27;:=&#x27;</span>, <span class="string">&#x27;&quot;std.ppp&quot;&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radgroupreply (groupname, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;locahost&#x27;</span>, <span class="string">&#x27;Framed-MTU&#x27;</span>, <span class="string">&#x27;:=&#x27;</span>, <span class="string">&#x27;1500&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radgroupreply (groupname, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;locahost&#x27;</span>, <span class="string">&#x27;Framed-Compression&#x27;</span>, <span class="string">&#x27;:=&#x27;</span>, <span class="string">&#x27;Van-Jacobsen-TCP-IP&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 创建用户</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radcheck (username, attribute, op, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;Cleartext-Password&#x27;</span>, <span class="string">&#x27;==&#x27;</span>, <span class="string">&#x27;password1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 将用户加入组</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> radius.radusergroup (username, groupname) <span class="keyword">VALUES</span> (<span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;locahost&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行完之后，另打开一个终端进行本地测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 能接收到 Received Access-Accept 就表示没问题</span></span><br><span class="line">radtest user1 password1 localhost 1812 testing123</span><br></pre></td></tr></table></figure><p>由于没有路由器和交换机，就只能再开一个Win虚拟机，进行测试，首先向<code>/etc/freeradius/3.0/clients.conf</code>添加Win虚拟机的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/freeradius/3.0/clients.conf</span><br><span class="line">    <span class="comment"># 按照这个格式 里面有个localhost 用作本机测试的</span></span><br><span class="line">    client 192.168.1.109 &#123;  <span class="comment"># Win虚拟机ip</span></span><br><span class="line">        ipaddr = 192.168.1.109  <span class="comment"># Win虚拟机ip</span></span><br><span class="line">        secret = justpwd  <span class="comment"># Win虚拟机访问radius的密码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>好了，这时候，Win虚拟机上需要一个软件，NTRadPing，测试手法如下</p><p>天翼云：<a href="https://cloud.189.cn/t/AFJnYfy6Jbq2%EF%BC%88%E8%AE%BF%E9%97%AE%E7%A0%81%EF%BC%9Akb1q%EF%BC%89">https://cloud.189.cn/t/AFJnYfy6Jbq2（访问码：kb1q）</a></p><p>蓝奏云：<a href="https://sidneygod.lanzous.com/iHcxEfxkqgf">https://sidneygod.lanzous.com/iHcxEfxkqgf</a></p><p><img data-src="/assets/Build-FreeRADIUS-server-based-on-Ubuntu18/NTRadPing_Test.jpg" alt="NTRadPing_Test"></p><p>RADIUS Server&#x2F;port就填安装freeradius的ip和freeradius的默认端口1812</p><p>Reply timeout这一行就这样</p><p>RADIUS Secret key就是上面配置的secret值</p><p>User-Name和Password还是之前的user1和password1</p><p>其余不用管，点击send，右侧就会得到服务器返回的数据</p><hr><p>毕竟我们有前端页面了，所以添加用户组和用户什么的，肯定不用手动去输MySQL语句，不友好。</p><p>添加用户组：Management &gt; Profiles</p><p>添加用户：Management &gt; Users</p><p>其实这些页面应该对应着数据库的操作..没咋研究，但是像client似乎比如通过配置文件，毕竟路由器没那么多吧..</p><p>还有，关于路由器和交换机的配置，由于手头没设备，没法玩..看教程，tplink的wap2能设置radius服务器信息</p><h1 id="6-拾遗"><a href="#6-拾遗" class="headerlink" title="6 拾遗"></a>6 拾遗</h1><h2 id="6-1-环境问题"><a href="#6-1-环境问题" class="headerlink" title="6.1 环境问题"></a>6.1 环境问题</h2><p>用Ubuntu16搞了一上午，php和MariaDB都不行，然后果断选择Ubuntu18，基本上没出啥错，哦，用的是清华源，不知道和这个有没有关系，本来觉得阿里源挺好，但是16上用的就是，想着换一下..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"><span class="comment"># 把里面内容全换了</span></span><br><span class="line">sudo gedit /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完了之后记得更新源</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt upgrade</span><br></pre></td></tr></table></figure><h2 id="6-1-重启服务报错"><a href="#6-1-重启服务报错" class="headerlink" title="6.1 重启服务报错"></a>6.1 重启服务报错</h2><p>用systemctl或者service进行重启freeradius时，有时候会报错，说启动不了。大概长这样子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Job <span class="keyword">for</span> freeradius.service failed because the control process exited with error code.</span><br><span class="line">See <span class="string">&quot;systemctl status freeradius.service&quot;</span> and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p><strong>直接reboot就好</strong>，当然了，实在启动不了，也可以执行<code>sudo freeradius -X</code>，可以看到调试信息</p><h2 id="6-1-关于log"><a href="#6-1-关于log" class="headerlink" title="6.1 关于log"></a>6.1 关于log</h2><p>daloradius有个Reports模块，默认显示四种log：daloRADIUS Log，Radius Log，System Log，Boot Log。其中前俩正常，就是后俩，syslog有这个文件，但是没权限；Boot Log显示的是dmesg，但Ubuntu18上却不是<code>/var/log/dmesg</code>这个文件，而是<code>/var/log/kern.log</code></p><p>于是，修改文件：<code>/var/www/html/daloradius/library/exten-boot_log.php</code>，加三句话</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$logfile_loc1 = &#x27;/var/log/dmesg&#x27;;</span><br><span class="line">$logfile_loc2 = &#x27;/usr/local/var/log/dmesg&#x27;;</span><br><span class="line"><span class="addition">+ $logfile_loc3 = &#x27;/var/log/kern.log&#x27;;</span></span><br><span class="line"> </span><br><span class="line">if (file_exists($logfile_loc1))</span><br><span class="line">    $logfile = $logfile_loc1;</span><br><span class="line">else if (file_exists($logfile_loc2))</span><br><span class="line">    $logfile = $logfile_loc2;</span><br><span class="line"><span class="addition">+ else if (file_exists($logfile_loc3))</span></span><br><span class="line"><span class="addition">+     $logfile = $logfile_loc3;</span></span><br><span class="line">else &#123; </span><br></pre></td></tr></table></figure><p>但是呢，还是有权限问题，因为<code>syslog</code>和<code>kern.log</code>，要是把这俩文件权限改为644倒是没问题，问题是重启就又不行了。顺带一提，mysql，apache2，freeradius都是开机自启的。不是syslog用户或adm组是没有读文件权限的，于是就把<code>www-data</code>加到adm用户组了，问题解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a www-data adm</span><br></pre></td></tr></table></figure><p>如果<code>/var/log/</code>下连syslog，kern.log..都没有，查看<code>/etc/rsyslog.d/50-default.conf</code>，是不是把那些log给禁用了，打开注释就好了</p><h2 id="6-1-证书配置"><a href="#6-1-证书配置" class="headerlink" title="6.1 证书配置"></a>6.1 证书配置</h2><p>参考：<a href="https://blog.csdn.net/lassewang/article/details/9159543">https://blog.csdn.net/lassewang/article/details/9159543</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/opsprobe/p/9420502.html&quot;&gt;https://www.cnblogs.com/opsprobe/p/9420502.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lassewang/article/details/9159543&quot;&gt;https://blog.csdn.net/lassewang/article/details/9159543&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0-RADIUS&quot;&gt;&lt;a href=&quot;#0-RADIUS&quot; class=&quot;headerlink&quot; title=&quot;0 RADIUS&quot;&gt;&lt;/a&gt;0 RADIUS&lt;/h1&gt;&lt;p&gt;RADIUS：（Remote Authentication Dial In User Service）中文名为远程用户拨号认证服务，简称RADIUS，是目前应用最广泛的AAA协议（认证、授权和计费）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/assets/Build-FreeRADIUS-server-based-on-Ubuntu18/202205243456723.png&quot; alt=&quot;202205243456723&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中Device（例如交换机）向远程接入用户提供接入及与RADIUS服务器交互的服务。RADIUS服务器上则存储用户的身份信息、授权信息以及访问记录，对用户进行认证、授权和计费服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认证过程如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）客户端向接入设备发送一个EAPoL-Start报文，开始802.1x认证接入；&lt;/p&gt;
&lt;p&gt;（2）接入设备向客户端发送EAP-Request&amp;#x2F;Identity报文，要求客户端将用户名送上来；&lt;/p&gt;</summary>
    
    
    
    <category term="Other" scheme="https://sidneyding.cn/categories/Other/"/>
    
    
    <category term="freeradius" scheme="https://sidneyding.cn/tags/freeradius/"/>
    
    <category term="radius" scheme="https://sidneyding.cn/tags/radius/"/>
    
    <category term="daloradius" scheme="https://sidneyding.cn/tags/daloradius/"/>
    
  </entry>
  
  <entry>
    <title>[Relearning C/Cpp] Statements and Preprocessor</title>
    <link href="https://sidneyding.cn/posts/4163f7c1/"/>
    <id>https://sidneyding.cn/posts/4163f7c1/</id>
    <published>2020-08-09T16:02:25.000Z</published>
    <updated>2022-05-24T14:54:56.205Z</updated>
    
    <content type="html"><![CDATA[<p>突然发现两个不错的网址</p><p><a href="https://en.cppreference.com/w/cpp/language">https://en.cppreference.com/w/cpp/language</a></p><p><a href="https://en.cppreference.com/w/c/language">https://en.cppreference.com/w/c/language</a></p><p>书籍千千万，不如这个定义来得直接啊</p><span id="more"></span><h1 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h1><p>if…else，switch…case，while，for，do…while，break，continue，goto，return，空语句(一个分号)，try…catch</p><p>一些比较简单的就不说了，着重说一些没啥概念的</p><p><strong>switch…case</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">/* 可选的 */</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">/* 可选的 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 您可以有任意数量的 case 语句 */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选的 */</span></span><br><span class="line">       <span class="built_in">statement</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。</span></span><br><span class="line"><span class="comment">// C++中可以是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</span></span><br><span class="line"><span class="comment">// case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量</span></span><br></pre></td></tr></table></figure><p>这里就有一个问题了，if…else和switch…case谁效率更高呢？我发现比较有意思的事情是，没那么绝对，得看编译器给不给你优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种情况下，if...else啥也没干直接被优化掉了，没错直接删代码那种，但是switch还在</span></span><br></pre></td></tr></table></figure><p>汇编出来的代码是这样子的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">pushq%rbp</span><br><span class="line">...</span><br><span class="line">.seh_endprologue</span><br><span class="line">call__main</span><br><span class="line">movl$3, -4(%rbp)  # int a = 3;</span><br><span class="line">cmpl$2, -4(%rbp)  # 和2比较</span><br><span class="line">je.L5</span><br><span class="line">cmpl$3, -4(%rbp)  # 和3比较</span><br><span class="line">jmp.L3</span><br><span class="line">.L5:</span><br><span class="line">nop</span><br><span class="line">.L3:</span><br><span class="line">movl$0, %eax</span><br><span class="line">addq$48, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>但是这种情况肯定是不常用的，神经病啊..写个没用的代码？我们让代码变得有用一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: a = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: a = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: a = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显然这次代码变得有用多了</span></span><br></pre></td></tr></table></figure><p>再汇编一下瞅瞅</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">pushq%rbp</span><br><span class="line">...</span><br><span class="line">.seh_endprologue</span><br><span class="line">call__main</span><br><span class="line">movl$3, -4(%rbp)  # int a = 3;</span><br><span class="line">cmpl$1, -4(%rbp)  # if (a == 1)</span><br><span class="line">jne.L2               # 不等于1的话  所以.L2和.L4都是if的</span><br><span class="line">movl$1, -4(%rbp)  # 等于就直接赋值</span><br><span class="line">jmp.L3               # 这里应当是到switch</span><br><span class="line">.L2:</span><br><span class="line">cmpl$2, -4(%rbp)</span><br><span class="line">jne.L4</span><br><span class="line">movl$2, -4(%rbp)</span><br><span class="line">jmp.L3</span><br><span class="line">.L4:</span><br><span class="line">movl$3, -4(%rbp)</span><br><span class="line">.L3:                      # 这么看的话好像差不多，switch还比if多一句呢</span><br><span class="line">cmpl$2, -4(%rbp)</span><br><span class="line">je.L5</span><br><span class="line">cmpl$3, -4(%rbp)</span><br><span class="line">jne.L6</span><br><span class="line">movl$2, -4(%rbp)</span><br><span class="line">jmp.L7</span><br><span class="line">.L5:</span><br><span class="line">movl$1, -4(%rbp)</span><br><span class="line">jmp.L7</span><br><span class="line">.L6:</span><br><span class="line">movl$3, -4(%rbp)</span><br><span class="line">.L7:</span><br><span class="line">movl$0, %eax</span><br><span class="line">addq$48, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>但是…<a href="https://blog.csdn.net/jeremyjone/article/details/103428009">https://blog.csdn.net/jeremyjone/article/details/103428009</a> 网上都总结好了，我还折腾啥呢</p><p>这都是基本操作，就不说了，我们再看<strong>try…catch</strong>，这个东西只有C++有，叫做异常处理，有仨关键字：try，catch，throw，看看代码实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 抛出个异常</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Division by zero condition!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;  <span class="comment">// 需要注意的是 C++中没有finally</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="type">int</span> level, std::string str)</span><br><span class="line">            : <span class="built_in">level</span>(level), <span class="built_in">msg</span>(std::<span class="built_in">move</span>(str)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里，what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因</span></span><br><span class="line">    <span class="function">std::string <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg + <span class="string">&quot; -- &quot;</span> + std::<span class="built_in">to_string</span>(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    std::string msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出自定义的异常 总体使用和Java的异常还是很像的</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="number">1</span>, <span class="string">&quot;something wrong!&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (MyException &amp;e) &#123;</span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准C++是没有类似finally这样的语句结构的。C#&#x2F;Java 中保证无论是否出现异常，finally block 的代码均会得到执行；而 C++ 中，不论是否出现异常，局部变量的析构函数是会保证执行的，所以相对应与 finally block，C++ 的解决办法是 RAII，即Resource Aquisition Is Initialization。</p><p>基本的思路是，通过一个局部对象来表现资源，于是局部对象的析构函数将会释放资源。这样，程序员就不会忘记释放资源了。但是写析构函数是个技术活啊</p><p>C++11开始支持”Range-based for loop”，就是Java中的增强for循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; int_vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item : int_vec) &#123;  <span class="comment">// 这个几乎和Java增强for循环一样</span></span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    PAIR map[]&#123;&#123;<span class="string">&quot;key&quot;</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">               &#123;<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">               &#123;<span class="string">&quot;key3&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 这个需要C++17特性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[key, value] : map) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot; -- value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个类似的函数<code>std::for_each()</code></p><h1 id="2-宏"><a href="#2-宏" class="headerlink" title="2 宏"></a>2 宏</h1><p>首先最常见的<code>#include</code>，导入头文件，一般分为<code>#include &lt;filename&gt;</code>和<code>#include &quot;filename&quot;</code></p><p>一般来说，用<code>&lt;&gt;</code>表示搜索标准库里面的；用<code>&quot;&quot;</code>表示搜索自己写的，如果自己写的没找到，再去搜标准库。所以我们直接用<code>&quot;&quot;</code>是没问题的</p><p>其次常见的就是<code>#define</code>了，定义常量，比如说我们会防止头文件重复导入，在头文件上定义一个常量来标识</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XXX_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XXX_H</span></span><br><span class="line"><span class="comment">//blablabla..</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//XXX_H</span></span></span><br></pre></td></tr></table></figure><p>这里又认识了<code>#ifndef</code>和<code>#endif</code>(结束判断)，意思就是if not define，当然也会有<code>ifdef</code>，这样就可以防止头文件被多次导入引出的麻烦了</p><p>还有我们常说的宏开关<code>#if</code>，这其实就是if的功能，看起来高大上一点而已，还有<code>#else</code>，和<code>#elif</code>(就是else if)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ee</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aa</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>还有<code>#pragma</code>，这个宏在visual studio中常见，这个宏用起来比较复杂，其一般格式是<code>#pragma para</code>，其中para表示参数，瞅瞅常见参数</p><p><strong>#pragma message</strong></p><p>常常这么用<code>#pragma message(&quot;some msg..&quot;)</code>，当编译器遇到这条指令时就在<strong>编译输出窗口</strong>中将消息文本打印出来，编译时才会打印哦</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\Workspace\CCpp\test&gt;g++ -std=c++<span class="number">17</span> <span class="selector-tag">main</span><span class="selector-class">.cpp</span> -o x</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.cpp</span>:<span class="number">1</span>:<span class="number">31</span>: note: <span class="selector-id">#pragma</span> message: hello world!</span><br><span class="line"> <span class="selector-id">#pragma</span> <span class="built_in">message</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>同时，**还有<code>#error</code>和<code>#warning</code>**，也是针对编译时的，其中warning只是发出警告，error会停止编译</p><p><strong>#pragma code_seg</strong></p><p><code>#pragma code_seg( [&quot;section-name&quot;[,&quot;section-class&quot;] ] )</code>，它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它</p><p><strong>#pragma once</strong></p><p>只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，和上面提到的宏定义道理是一样的，这个宏在VS经常见到，但不是标准的，所以可能有的不兼容</p><p><strong>#pragma pack</strong></p><p>使用指令<code>#pragma pack (n)</code>，编译器将按照n个字节对齐。使用指令<code>#pragma pack ()</code>，编译器将取消自定义字节对齐方式。关于字节对齐，其实就是性能和空间之间的平衡</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestStruct1</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> c1;</span><br><span class="line">   <span class="type">short</span> s;</span><br><span class="line">   <span class="type">char</span> c2;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照常理说，如果c1的内存位置是0，那么s就是1-2，c2就是3，i就是4-7；实际上呢，地址开头是0，2，4，8。意思就是默认四字节对齐</p><p>首先，每个成员分别按自己的方式对齐,并能最小化长度。</p><p>其次，复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式,这样在成员是复杂类型时,可以最小化长度。</p><p>然后，对齐后的长度必须是成员中最大的对齐参数的整数倍,这样在处理数组时可以保证每一项都边界对齐。</p><p>还有其他的，不了解了..</p><p>下一个是**<code>#line</code>**，说到这个，就不得不说<code>__LINE__</code>和<code>__FILE__</code>，一般来说这LINE和FILE就是单纯的行数和文件名，然而这个LINE和FILE就是固定的吗？显然不是，这个line就可以重新定义这两个宏</p><p>语法：<code>#line lineNum fileName</code>，其中lineNum是数字；fileName是字符串，可省略。这个宏定义了lineNum，那下一行的数字就是lineNum</p><p>再说<strong>可变参数宏</strong>，源码里面常见的打log的工具</p><p><code>#define ERROR(format, ...)  fprintf(stderr, format, __VA_ARGS__)</code></p><p>这<code>__VA_ARGS__</code>就是可变参数宏，嗯，可变参数..</p><p>再说源码里面常用的**<code>#，##，#@</code>**</p><p><code>#</code>: 对应变量字符串化</p><p><code>##</code>: 连接符</p><p><code>#@</code>: 将单字符的标记转成单字符 举个栗子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> x1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 1 #</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> trace(x, format) printf(#x <span class="string">&quot; = %&quot;</span> #format <span class="string">&quot;\n&quot;</span>, x)</span></span><br><span class="line"><span class="built_in">trace</span>(i, d);  <span class="comment">// 相当于 printf(&quot;i = %d\n&quot;, i);</span></span><br><span class="line"><span class="comment">// 2 ##</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> trace2(a) trace(x##i, d)</span></span><br><span class="line"><span class="built_in">trace2</span>(<span class="number">1</span>);  <span class="comment">// 相当于 trace(x1, d)</span></span><br><span class="line"><span class="comment">// 3 #@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B(x) #@x</span></span><br><span class="line"><span class="built_in">B</span>(a);  <span class="comment">// 即为 &#x27;a&#x27;, 但 B(abc); 没效果</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;突然发现两个不错的网址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language&quot;&gt;https://en.cppreference.com/w/cpp/language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.cppreference.com/w/c/language&quot;&gt;https://en.cppreference.com/w/c/language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;书籍千千万，不如这个定义来得直接啊&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="https://sidneyding.cn/categories/Language/"/>
    
    <category term="C/Cpp" scheme="https://sidneyding.cn/categories/Language/C-Cpp/"/>
    
    
    <category term="Relearning C/Cpp" scheme="https://sidneyding.cn/tags/Relearning-C-Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Quickly build gitbook</title>
    <link href="https://sidneyding.cn/posts/95b3592b/"/>
    <id>https://sidneyding.cn/posts/95b3592b/</id>
    <published>2020-06-20T15:14:37.000Z</published>
    <updated>2022-05-24T15:09:45.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-start"><a href="#0-start" class="headerlink" title="0 start"></a>0 start</h1><p>感觉最近看的不少东西都是用gitbook写的，看起来也确实怪舒服的，举个例子：<a href="https://lingcoder.github.io/OnJava8/#/sidebar">https://lingcoder.github.io/OnJava8/#/sidebar</a>，既能当博客又能当Wiki，于是我准备自己搭建一个。参考网上的步骤：</p><ol><li><p>文档编写采用统一标准，都用Markdown格式的，最后可以用gitbook自动生成静态网页；</p></li><li><p>分配好各阶段（版本）相关责任人编写的文档，待文档编写完成后统一上传到git；</p></li><li><p>jenkins负责拉取正式版本（release开头）的文档，用gitbook编译后，同步到云端文档服务器</p></li><li><p>云端服务器制作一个入口页面，页面里面可以指引各个版本文档；http服务用nginx，指引到这个页面；</p></li></ol><p>其中第三步我觉得没必要用Jenkins，直接设置一个定时任务就好了。。其实搭建一个从零开始搭建一个完整Gitbook还是比较麻烦的，详情参考下方的参考文档。我既然说了快速，那必然是简单而又傻瓜式的搭建了..Let’s go!</p><span id="more"></span><p>参考文档：</p><p><a href="http://huaqianlee.github.io/2019/05/05/Git/gitlab-jenkins-gitbook-to-create-LAN-gitbook/">Gitbook + Jenkins + Gitlab 搭建内网自动构建的 Gitbook</a></p><p><a href="http://gitbook.zhangjikai.com/installation.html">Gitbook使用教程</a></p><p><a href="https://www.bookstack.cn/read/yangzh-gitbook/f515035a29711964.md">Gitbook学习笔记</a></p><p><a href="GitBook%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86">Gitbook插件整理</a></p><p><a href="https://blog.zhenglin.work/other/devops_practices_gitbook_web.html#%E5%88%A9%E7%94%A8gitbookgitjenkinsnodejs%E6%90%AD%E5%BB%BA%E8%B5%B7%E4%B8%80%E5%A5%97%E5%A4%9A%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E%E7%9A%84%E6%96%87%E6%A1%A3%E7%BD%91%E7%AB%99">利用gitbook+git+jenkins+nodejs搭建起一套多版本说明的文档网站</a></p><h1 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1 准备环境"></a>1 准备环境</h1><h2 id="1-1-设置root密码"><a href="#1-1-设置root密码" class="headerlink" title="1.1 设置root密码"></a>1.1 设置root密码</h2><p>准备环境这一步很基础也很重要，我使用的是Ubuntu16的虚拟机，打开虚拟机后<strong>先确保root用户是有密码</strong>的，不是sudo的密码，可以在终端试试<code>su</code>能不能切换到root，如果不行，先给root设置密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sidney@ubuntu:~$ sudo passwd root  <span class="comment"># 设置一次密码就好了 以后就可以用su切换root了</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> sidney: </span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">sidney@ubuntu:~$ </span><br></pre></td></tr></table></figure><h2 id="1-2-创建git用户"><a href="#1-2-创建git用户" class="headerlink" title="1.2 创建git用户"></a>1.2 创建git用户</h2><p>为了不影响当前的环境，我们先创建一个git用户，这个git也可以换成其他喜欢的字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sidney@ubuntu:~$ sudo adduser git</span><br><span class="line">Adding user `git<span class="string">&#x27; ...</span></span><br><span class="line"><span class="string">Adding new group `git&#x27;</span> (1001) ...</span><br><span class="line">Adding new user `git<span class="string">&#x27; (1001) with group `git&#x27;</span> ...</span><br><span class="line">Creating home directory `/home/git<span class="string">&#x27; ...</span></span><br><span class="line"><span class="string">Copying files from `/etc/skel&#x27;</span> ...</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information <span class="keyword">for</span> git</span><br><span class="line">Enter the new value, or press ENTER <span class="keyword">for</span> the default</span><br><span class="line">Full Name []: </span><br><span class="line">Room Number []: </span><br><span class="line">Work Phone []: </span><br><span class="line">Home Phone []: </span><br><span class="line">Other []: </span><br><span class="line">Is the information correct? [Y/n] y</span><br><span class="line">sidney@ubuntu:~$ </span><br></pre></td></tr></table></figure><p>创建好git用户后，应该就有<code>/home/git</code>目录了，如果没有的话..自己想办法吧..</p><h2 id="1-3-下载环境"><a href="#1-3-下载环境" class="headerlink" title="1.3 下载环境"></a>1.3 下载环境</h2><p>这里用我打包好的环境，省时省力，解压改点东西就能用了，下载链接：</p><p>蓝奏云：<a href="https://sidneygod.lanzous.com/iwOFzdwazyj">https://sidneygod.lanzous.com/iwOFzdwazyj</a><br>密码:sidney</p><p>天翼云：<a href="https://cloud.189.cn/t/eAnyamUNBrum">https://cloud.189.cn/t/eAnyamUNBrum</a><br>访问码：jtv3</p><p>没错，就是不提供百度云..这里先把git和openssh-server安装了，顺便当前用户生成个公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">sidney@ubuntu:~$ sudo apt-get install git  <span class="comment"># 安装git 我安装过了 所以结果不一样</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">git is already the newest version (1:1.9.1-1ubuntu0.10).</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 1 not upgraded.</span><br><span class="line">sidney@ubuntu:~$ sudo apt-get install openssh-server  <span class="comment"># 安装openssh-server</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">openssh-server is already the newest version (1:6.6p1-2ubuntu2.13).</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 1 not upgraded.</span><br><span class="line">sidney@ubuntu:~$ ssh-keygen  <span class="comment"># 生成公钥 这个我也生成过了..</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/sidney/.ssh/id_rsa): </span><br><span class="line">/home/sidney/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /home/sidney/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /home/sidney/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line"><span class="built_in">cd</span>:f8:18:9a:8b:de:91:d0:e0:ce:d3:5c:93:5a:37:dc sidney@ubuntu</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|    .            |</span></span><br><span class="line"><span class="string">|   . o   * .     |</span></span><br><span class="line"><span class="string">|    o . S * E    |</span></span><br><span class="line"><span class="string">|   o + B * .     |</span></span><br><span class="line"><span class="string">|    + O . .      |</span></span><br><span class="line"><span class="string">|     + o         |</span></span><br><span class="line"><span class="string">|   .o o          |</span></span><br><span class="line"><span class="string">+-----------------+</span></span><br><span class="line"><span class="string">sidney@ubuntu:~$ sudo vim /etc/ssh/ssh_config  # 大概在39行 把Port 22注释打开 默认端口</span></span><br><span class="line"><span class="string">sidney@ubuntu:~$ sudo /etc/init.d/ssh stop  # 重启一下ssh服务</span></span><br><span class="line"><span class="string">[ ok ] Stopping ssh (via systemctl): ssh.service.</span></span><br><span class="line"><span class="string">sidney@ubuntu:~$ sudo /etc/init.d/ssh start</span></span><br><span class="line"><span class="string">[ ok ] Starting ssh (via systemctl): ssh.service.</span></span><br><span class="line"><span class="string">sidney@ubuntu:~$</span></span><br></pre></td></tr></table></figure><p>哦，对了，如果没配置git，顺便把git配置一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Sidney Ding&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;sidneyding183@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>这个环境配置的差不多了..接下来该处理我们下载下来的文件<code>git.zip</code>了</p><h2 id="1-4-解压git-zip"><a href="#1-4-解压git-zip" class="headerlink" title="1.4 解压git.zip"></a>1.4 解压git.zip</h2><p>首先，在终端切换用户到git，并把git.zip拷贝到<code>/home/git</code>下，然后来一个一个配置..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sidney@ubuntu:~$ su git  <span class="comment"># 切换用户</span></span><br><span class="line">Password: </span><br><span class="line">git@ubuntu:/home/sidney$ <span class="built_in">cd</span> ~  <span class="comment"># 进入git的home目录</span></span><br><span class="line">git@ubuntu:~$ ll git.zip </span><br><span class="line">-rw-r--r-- 1 root root 96128663 Jun 21 00:20 git.zip</span><br><span class="line">git@ubuntu:~$ sudo <span class="built_in">chmod</span> 666 git.zip  <span class="comment"># 改变模式失败..</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> git: </span><br><span class="line">git is not <span class="keyword">in</span> the sudoers file.  This incident will be reported.</span><br><span class="line">git@ubuntu:~$ </span><br></pre></td></tr></table></figure><p>在git中调用<code>sudo</code>，不出意外都会报这个错的<code>git is not in the sudoers file.  This incident will be reported.</code>，接下来的操作，**<font color='red'>一定要确保root有密码！一定要确保root有密码！一定要确保root有密码！</font>**</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git@ubuntu:~$ su  <span class="comment"># 切换到root用户</span></span><br><span class="line">Password: </span><br><span class="line">root@ubuntu:/home/git<span class="comment"># ll /etc/sudoers  # 查看文件权限</span></span><br><span class="line">-r--r----- 1 root root 755 Jun 20 23:54 /etc/sudoers</span><br><span class="line">root@ubuntu:/home/git<span class="comment"># chmod 0660 /etc/sudoers  # 加个可以写的权限</span></span><br><span class="line">root@ubuntu:/home/git<span class="comment"># vim /etc/sudoers  # 在这个文件中加一句  git ALL=(ALL) ALL </span></span><br><span class="line">root@ubuntu:/home/git<span class="comment"># chmod 0440 /etc/sudoers  # 一定要把权限改回去 不然大家都不能用sudo了</span></span><br><span class="line">root@ubuntu:/home/git<span class="comment"># ll /etc/sudoers</span></span><br><span class="line">-r--r----- 1 root root 773 Jun 21 00:30 /etc/sudoers</span><br><span class="line">root@ubuntu:/home/git<span class="comment"># exit  # 退出root</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">git@ubuntu:~$ sudo <span class="built_in">chmod</span> 666 git.zip  <span class="comment"># 再次修改git.zip权限</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> git: </span><br><span class="line">git@ubuntu:~$ ll git.zip </span><br><span class="line">-rw-rw-rw- 1 root root 96128663 Jun 21 00:20 git.zip  <span class="comment"># 没毛病</span></span><br><span class="line">git@ubuntu:~$ </span><br></pre></td></tr></table></figure><p>如果你在这不小心，用sudo改了<code>/etc/sudoers</code>的模式，然后你还没有root密码..作孽啊，用下面的方法试试能不能救..不然重装系统吧</p><p><a href="https://www.cnblogs.com/sea-stream/p/9852478.html">sudo: &#x2F;etc&#x2F;sudoers is world writable sudo: no valid sudoers sources found</a></p><p>终于可以解压了..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git@ubuntu:~$ unzip git.zip </span><br><span class="line">Archive:  git.zip</span><br><span class="line">   creating: book/</span><br><span class="line">  inflating: book/serve.log          </span><br><span class="line">  inflating: book/book.json          </span><br><span class="line">  inflating: book/package-lock.json  </span><br><span class="line">  inflating: book/commands.txt</span><br><span class="line">  ...</span><br><span class="line">git@ubuntu:~$ ll  <span class="comment"># 解压完的目录应该是这样的</span></span><br><span class="line">total 93932</span><br><span class="line">drwxr-xr-x 7 git  git      4096 Jun 21 00:38 ./</span><br><span class="line">drwxr-xr-x 4 root root     4096 Jun 21 00:02 ../</span><br><span class="line">-rw------- 1 git  git       100 Jun 21 00:24 .bash_history</span><br><span class="line">-rw-r--r-- 1 git  git       220 Jun 21 00:02 .bash_logout</span><br><span class="line">-rw-r--r-- 1 git  git      3771 Jun 21 00:02 .bashrc  <span class="comment"># 这个必须在</span></span><br><span class="line">drwxrwxr-x 6 git  git      4096 Jun 20 22:39 book/  <span class="comment"># 必须</span></span><br><span class="line">drwxrwxr-x 7 git  git      4096 Jun 20 09:10 book.git/  <span class="comment"># 必须</span></span><br><span class="line">-rw-r--r-- 1 git  git      8980 Jun 21 00:02 examples.desktop</span><br><span class="line">-rw-rw-rw- 1 root root 96128663 Jun 21 00:20 git.zip</span><br><span class="line">drwxrwxr-x 6 git  git      4096 Jun 20 22:45 nginx/  <span class="comment"># 必须</span></span><br><span class="line">drwxr-xr-x 9 git  git      4096 Jun 20 22:30 nginx-1.18.0/</span><br><span class="line">drwxr-xr-x 7 git  git      4096 Jun 20 09:30 node-v12.18.1-linux-x64/  <span class="comment"># 必须</span></span><br><span class="line">-rw-r--r-- 1 git  git       655 Jun 21 00:02 .profile  <span class="comment"># 必须</span></span><br></pre></td></tr></table></figure><p>如果缺了必须的文件，是一件很麻烦的事..</p><h2 id="1-5-配置环境"><a href="#1-5-配置环境" class="headerlink" title="1.5 配置环境"></a>1.5 配置环境</h2><p>接下来要配置的就不多了</p><h3 id="1-5-1-node-js"><a href="#1-5-1-node-js" class="headerlink" title="1.5.1 node.js"></a>1.5.1 node.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置node.js环境变量</span></span><br><span class="line">git@ubuntu:~$ <span class="built_in">cd</span> node-v12.18.1-linux-x64/bin</span><br><span class="line">git@ubuntu:~/node-v12.18.1-linux-x64/bin$ <span class="built_in">pwd</span></span><br><span class="line">/home/git/node-v12.18.1-linux-x64/bin  <span class="comment"># 注意这个路径</span></span><br><span class="line">git@ubuntu:~/node-v12.18.1-linux-x64/bin$ vim ~/.bashrc  <span class="comment"># 主要是把那个路径添加到环境变量</span></span><br><span class="line">    <span class="comment"># node.js</span></span><br><span class="line">    <span class="built_in">export</span> PATH=/home/git/node-v12.18.1-linux-x64/bin:<span class="variable">$PATH</span></span><br><span class="line">git@ubuntu:~/node-v12.18.1-linux-x64/bin$ <span class="built_in">source</span> ~/.bashrc</span><br><span class="line">git@ubuntu:~/node-v12.18.1-linux-x64/bin$ node -v</span><br><span class="line">v12.18.1  <span class="comment"># 能正确显示版本 说明没问题</span></span><br><span class="line">git@ubuntu:~/node-v12.18.1-linux-x64/bin$</span><br></pre></td></tr></table></figure><h3 id="1-5-2-gitbook"><a href="#1-5-2-gitbook" class="headerlink" title="1.5.2 gitbook"></a>1.5.2 gitbook</h3><p>先去看看gitbook能不能用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git@ubuntu:~/node-v12.18.1-linux-x64/bin$ <span class="built_in">cd</span> ~/book</span><br><span class="line">git@ubuntu:~/book$ gitbook -V  <span class="comment"># 耐心等一会，需要安装点东西</span></span><br><span class="line">CLI version: 2.3.2</span><br><span class="line">Installing GitBook 3.2.3</span><br><span class="line">...</span><br><span class="line">GitBook version: 3.2.3</span><br><span class="line">git@ubuntu:~/book$ gitbook serve  <span class="comment"># 先爽一下 报error不用管 那个是我故意写错的 一个插件导致的</span></span><br><span class="line">Live reload server started on port: 35729</span><br><span class="line">Press CTRL+C to quit ...</span><br><span class="line">...</span><br><span class="line">Starting server ...</span><br><span class="line">Serving book on http://localhost:4000</span><br></pre></td></tr></table></figure><p>这个时候，打开浏览器，访问<code>http://127.0.0.1:4000</code>应该是能访问的，如下图</p><p><img data-src="/assets/Quickly-build-gitbook/gitbook_display.png" alt="gitbook_display"></p><h3 id="1-5-3-git"><a href="#1-5-3-git" class="headerlink" title="1.5.3 git"></a>1.5.3 git</h3><p>再配置一下我们的仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">git@ubuntu:~/book$ cd docs/</span><br><span class="line">git@ubuntu:~/book/docs$ ifconfig  # 先看一下本机ip 毕竟要大家一起玩嘛..</span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:6b:c5:06  </span><br><span class="line">          inet addr:192.168.1.109  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">git@ubuntu:~/book/docs$ vim .git/config</span><br><span class="line">    [remote &quot;origin&quot;]</span><br><span class="line">            url = git@192.168.1.109:/home/git/book.git  # 重点是这句 自行修改一下</span><br><span class="line">            fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没问题的话 我们更新一下代码试试</span></span><br><span class="line">git@ubuntu:~/book/docs$ git pull origin master  # 更新代码应该是没问题的 并且是最新的</span><br><span class="line">The authenticity of host &#x27;192.168.1.109 (192.168.1.109)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is 0a:0a:d6:c8:7d:cf:b1:75:8e:c4:fe:ac:13:16:aa:f8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &#x27;192.168.1.109&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line">git@192.168.1.109&#x27;s password: </span><br><span class="line">From 192.168.1.109:/home/git/book</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Already up-to-date.</span><br><span class="line">git@ubuntu:~/book/docs$ vim README.md  # 我们修改一下README.md  干掉那个error</span><br><span class="line">git@ubuntu:~/book/docs$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 71a64d2..7119efd 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -3,4 +3,7 @@ just for a test..</span><br><span class="line"> </span><br><span class="line"> test2..</span><br><span class="line"> what is Markdown?</span><br><span class="line">+&#x27;&#x27;&#x27;bash  # 主要是把这里的txt换成一种语言</span><br><span class="line">+hahaha, kanni zenme ban?</span><br><span class="line">+&#x27;&#x27;&#x27;</span><br><span class="line">git@ubuntu:~/book/docs$ git add README.md  # 下面是验证一笔提交..</span><br><span class="line">git@ubuntu:~/book/docs$ git commit -m &quot;change txt to bash&quot;</span><br><span class="line"></span><br><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">  git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br><span class="line">to set your account&#x27;s default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br><span class="line"></span><br><span class="line">fatal: empty ident name (for &lt;git@ubuntu.(none)&gt;) not allowed</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忘了配置git了..</span></span><br><span class="line">git@ubuntu:~/book/docs$ git config --global user.email &quot;sidneyding183@gmail.com&quot;</span><br><span class="line">git@ubuntu:~/book/docs$ git config --global user.name &quot;SidneyGod&quot;</span><br><span class="line">git@ubuntu:~/book/docs$ git commit -m &quot;change txt to bash&quot;</span><br><span class="line">[master 3906bd7] change txt to bash</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line">git@ubuntu:~/book/docs$ git push origin master  # 说明push也没有问题</span><br><span class="line">git@192.168.1.109&#x27;s password: </span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 350 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">To git@192.168.1.109:/home/git/book.git</span><br><span class="line">   f242669..3906bd7  master -&gt; master</span><br><span class="line">git@ubuntu:~/book/docs$ </span><br><span class="line">git@ubuntu:~/book/docs$ cd ../</span><br><span class="line">git@ubuntu:~/book$ gitbook build &amp;&amp; gitbook serve  # 这次就不会报error了</span><br><span class="line">info: 29 plugins are installed </span><br><span class="line">info: 24 explicitly listed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这一步其实是为了确定仓库是好的，我才不会用<code>gitbook serve</code>呢！</p><h3 id="1-5-4-nginx"><a href="#1-5-4-nginx" class="headerlink" title="1.5.4 nginx"></a>1.5.4 nginx</h3><p>这东西也不用了解太多，用就完事了..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git@ubuntu:~/book$ <span class="built_in">cd</span> ../nginx</span><br><span class="line">git@ubuntu:~/nginx$ <span class="built_in">pwd</span></span><br><span class="line">/home/git/nginx</span><br><span class="line">git@ubuntu:~/nginx$ vim conf/nginx.conf  <span class="comment"># 先看一下第29行配置对不对</span></span><br><span class="line">    <span class="built_in">alias</span> /home/git/book/_book;  <span class="comment"># 如果_book不在这个目录 修改一下</span></span><br><span class="line">git@ubuntu:~/nginx$ </span><br><span class="line">git@ubuntu:~/nginx$ sudo ./sbin/nginx -p /home/git/nginx  <span class="comment"># 运行nginx</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> git: </span><br><span class="line">git@ubuntu:~/nginx$ <span class="built_in">ls</span>  <span class="comment"># 运行完 多几个temp才是正常的</span></span><br><span class="line">client_body_temp  conf  fastcgi_temp  html  logs  proxy_temp  sbin  scgi_temp  uwsgi_temp</span><br></pre></td></tr></table></figure><p>这个时候应该可以通过<code>http://192.168.1.109/book</code>来访问了，访问成改表示nginx配置成功，<code>http://192.168.1.109/</code>就可以用来”<strong>制作一个入口页面，页面里面可以指引各个版本文档</strong>“，多本gitbook才是最终目标</p><h3 id="1-5-5-git-hook"><a href="#1-5-5-git-hook" class="headerlink" title="1.5.5 git hook"></a>1.5.5 git hook</h3><p>之前用的定时..感觉还是不行，不好用，于是发现git新大陆，叫git hook，先到<code>book.git</code>仓库看看吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git@ubuntu:~/book.git/hooks$ <span class="built_in">pwd</span>  <span class="comment"># 注意这个目录</span></span><br><span class="line">/home/git/book.git/hooks</span><br><span class="line">git@ubuntu:~/book.git/hooks$ vim post-receive  <span class="comment"># 创建post-receive文件 当有push就会执行</span></span><br><span class="line">git@ubuntu:~/book.git/hooks$ <span class="built_in">chmod</span> a+x post-receive  <span class="comment"># 加可执行权限</span></span><br></pre></td></tr></table></figure><p>以下是<code>post-receive</code>内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> -e  <span class="comment"># 这两句调试用的</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> -x</span></span><br><span class="line"></span><br><span class="line">PATH=/home/git/node-v12.18.1-linux-x64/bin/:$PATH  # 这里路径</span><br><span class="line"></span><br><span class="line">IS_BARE=$(git rev-parse --is-bare-repository)</span><br><span class="line">if [ -z &quot;$IS_BARE&quot; ]; then</span><br><span class="line">    echo &gt;&amp;2 &quot;fatal: post-receive: IS_NOT_BARE&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset GIT_DIR</span><br><span class="line">cd &#x27;/home/git/book/docs&#x27;  # 注意这里的路径</span><br><span class="line">echo &quot;deploying the gitbook..&quot;</span><br><span class="line">result=`git pull origin master`</span><br><span class="line">[[ $result = &quot;Already up-to-date.&quot; ]] &amp;&amp; exit 0 || echo &quot;File updated&quot;</span><br><span class="line">cd &#x27;/home/git/book&#x27;  # 还有这里</span><br><span class="line">gitbook build</span><br></pre></td></tr></table></figure><p>这样就特别完美了..哈哈..比定时任务高大上多了..</p><h3 id="1-5-6-crontab"><a href="#1-5-6-crontab" class="headerlink" title="1.5.6 crontab"></a><del>1.5.6 crontab</del></h3><p>其实到这里就已经好了，让nginx一直在后台运行就好了，如果<code>/home/git/book/docs</code>有变动，比如新的文档啥的，就在<code>/home/git/book</code>目录下执行一次<code>gitbook build</code>就好了，但是怎么说呢？太累。写完文档push完了，你还得再去pull一次，麻烦，所以才有上面的Jenkins监听push行为，然后自动进行更新docs，并执行<code>gitbook build</code>，我觉得这太大材小用了，webhookit或许不错，不过我最终还是觉得定时任务最方便..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先 把本机的公钥加到.ssh/authorized_keys中</span></span><br><span class="line">git@ubuntu:~/book$ ssh-keygen</span><br><span class="line">git@ubuntu:~/book$ <span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br><span class="line">git@ubuntu:~/book$ vim ~/.ssh/authorized_keys  <span class="comment"># 什么没有这个文件 那建一个呗</span></span><br><span class="line"><span class="comment"># 然后写一个简单的脚本..</span></span><br><span class="line">git@ubuntu:~/book$ vim build.sh  <span class="comment"># 简单的更新并build的脚本</span></span><br><span class="line">    <span class="comment">#!/bin/bash</span></span><br><span class="line">    <span class="built_in">set</span> -e</span><br><span class="line">    <span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line">    PATH=/home/git/node-v12.18.1-linux-x64/bin/:<span class="variable">$PATH</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&#x27;/home/git/book/docs&#x27;</span></span><br><span class="line">    result=`git pull origin master`</span><br><span class="line">    [[ <span class="variable">$result</span> = <span class="string">&quot;Already up-to-date.&quot;</span> ]] &amp;&amp; <span class="built_in">exit</span> 0 || <span class="built_in">echo</span> <span class="string">&quot;File updated&quot;</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&#x27;/home/git/book&#x27;</span></span><br><span class="line">    gitbook build</span><br><span class="line">git@ubuntu:~/book$ <span class="built_in">chmod</span> a+x build.sh</span><br><span class="line"><span class="comment"># 设置定时任务</span></span><br><span class="line">git@ubuntu:~/book$ crontab -e</span><br><span class="line"></span><br><span class="line">Select an editor.  To change later, run <span class="string">&#x27;select-editor&#x27;</span>.</span><br><span class="line">  1. /bin/ed</span><br><span class="line">  2. /bin/nano        &lt;---- easiest</span><br><span class="line">  3. /usr/bin/vim.basic</span><br><span class="line"></span><br><span class="line">Choose 1-3 [2]: 3</span><br><span class="line">    <span class="comment"># 加了这么一句 一分钟执行一次脚本，并输出log..</span></span><br><span class="line">    */1 * * * * /bin/bash /home/git/book/build.sh &gt;&gt; /home/git/book/crontab.log 2&gt;&amp;1</span><br><span class="line">crontab: installing new crontab</span><br><span class="line">git@ubuntu:~/book$ service cron restart  <span class="comment"># 重启cron服务</span></span><br></pre></td></tr></table></figure><p>可算是大功告成了！</p><h1 id="2-多人协作"><a href="#2-多人协作" class="headerlink" title="2 多人协作"></a>2 多人协作</h1><p>要git本就是为了多人协作，这时候再开一个终端，查看另一个用户的公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sidney@ubuntu:~$ <span class="built_in">cat</span> .ssh/id_rsa.pub  <span class="comment"># 注意 这里不是 git@ubuntu了</span></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDkdVqvsdIjn28XEA4wC29SyiQALP9eLyOXC/WRuPR4WHagVCu8JO415oHgUo8uAlXIQAS2AcAQA+1bzuipSmCEo2RtIgLovjoI1Iqw475NP+ExlkRjw4Z sidney@ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将sidney的公钥加到git的.ssh/authorized_keys中</span></span><br><span class="line">git@ubuntu:~$ vim ~/.ssh/authorized_keys  <span class="comment"># 注意这里是git@ubuntu</span></span><br></pre></td></tr></table></figure><p>接下来呢，当然是要尝试拉代码和推代码了，哦不，是文档..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">sidney@ubuntu:~$ <span class="built_in">cd</span> Downloads/</span><br><span class="line"><span class="comment"># 克隆仓库 没有问题..</span></span><br><span class="line">sidney@ubuntu:~/Downloads$ git <span class="built_in">clone</span> git@192.168.1.109:/home/git/book.git</span><br><span class="line">Cloning into <span class="string">&#x27;book&#x27;</span>...</span><br><span class="line">remote: Counting objects: 46, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (35/35), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 46 (delta 11), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (46/46), 4.94 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (11/11), <span class="keyword">done</span>.</span><br><span class="line">Checking connectivity... <span class="keyword">done</span>.</span><br><span class="line">sidney@ubuntu:~/Downloads$ <span class="built_in">cd</span> book/</span><br><span class="line">sidney@ubuntu:~/Downloads/book$ <span class="built_in">ls</span></span><br><span class="line">ch1  GLOSSARY.md  last_ch  README.md  SUMMARY.md</span><br><span class="line">sidney@ubuntu:~/Downloads/book$ vim README.md  <span class="comment"># 修改README.md</span></span><br><span class="line">sidney@ubuntu:~/Downloads/book$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">sidney@ubuntu:~/Downloads/book$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index aae20fc..a35bf2b 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1,4 +1,5 @@</span><br><span class="line"> <span class="comment"># Introduction</span></span><br><span class="line">+我是最棒的！</span><br><span class="line"> just <span class="keyword">for</span> a <span class="built_in">test</span>..</span><br><span class="line"> </span><br><span class="line"> test2..</span><br><span class="line">sidney@ubuntu:~/Downloads/book$ git add README.md</span><br><span class="line">sidney@ubuntu:~/Downloads/book$ git commit -m <span class="string">&quot;test&quot;</span></span><br><span class="line">[master 7f99d72] <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">sidney@ubuntu:~/Downloads/book$ git push origin master  <span class="comment"># 推也没问题</span></span><br><span class="line">Counting objects: 5, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 366 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0)</span><br><span class="line">To git@192.168.1.109:/home/git/book.git</span><br><span class="line">   3906bd7..7f99d72  master -&gt; master</span><br><span class="line">sidney@ubuntu:~/Downloads/book$ git pull origin master  <span class="comment"># 拉代码也没问题</span></span><br><span class="line">From 192.168.1.109:/home/git/book</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Already up-to-date.</span><br><span class="line">sidney@ubuntu:~/Downloads/book$</span><br></pre></td></tr></table></figure><p>耐心等待个一两分钟..再刷新页面，应该是能看到变化的，如果没变化，那么可能是定时任务出问题了，或者脚本有问题..这么看的话，多人协作是没有问题的了</p><h1 id="3-gitbook使用"><a href="#3-gitbook使用" class="headerlink" title="3 gitbook使用"></a>3 gitbook使用</h1><p>想知道详细信息的可以百度或者看上面我提供的几条链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git@ubuntu:~/book$ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── _book  <span class="comment"># gitbook生成的静态网页的地方</span></span><br><span class="line">├── book.json  <span class="comment"># gitbook配置文件 包括安装插件什么的 我已经安装差不多了</span></span><br><span class="line">├── build.sh  <span class="comment"># 自己写的更新脚本</span></span><br><span class="line">├── commands.txt  <span class="comment"># 常用命令记录</span></span><br><span class="line">├── docs  <span class="comment"># 存储源文档仓库</span></span><br><span class="line">├── node_modules  <span class="comment"># 安装的插件</span></span><br><span class="line">├── package-lock.json  <span class="comment"># 安装的插件列表/信息</span></span><br><span class="line">├── serve.log</span><br><span class="line">└── style  <span class="comment"># 自定义样式表</span></span><br></pre></td></tr></table></figure><p>由于配置啥的我已经弄得差不多了，直接说说怎么用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git@ubuntu:~/book$ tree docs/</span><br><span class="line">docs/</span><br><span class="line">├── ch1</span><br><span class="line">│   ├── ch1.1</span><br><span class="line">│   │   └── ch1.1.md</span><br><span class="line">│   └── Chapter1.md</span><br><span class="line">├── GLOSSARY.md</span><br><span class="line">├── last_ch</span><br><span class="line">│   └── last_ch.md</span><br><span class="line">├── README.md</span><br><span class="line">└── SUMMARY.md</span><br><span class="line"></span><br><span class="line">3 directories, 6 files</span><br></pre></td></tr></table></figure><h2 id="3-1-SUMMARY-md"><a href="#3-1-SUMMARY-md" class="headerlink" title="3.1 SUMMARY.md"></a>3.1 SUMMARY.md</h2><p>概要文件主要存放 GitBook 的文件目录信息，左侧的目录就是根据这个文件来生成的，默认对应的文件是 SUMMARY.md，可以在book.json重新定义该文件的对应值。它通过Markdown中的<strong>列表语法</strong>(其实就是<strong>通过缩进</strong>)来表示文件的父子关系，下面是一个简单的示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Summary</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> [<span class="string">Introduction</span>](<span class="link">README.md</span>)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="section"># PART I  &lt;!-- 这个懂吧 --&gt;</span></span><br><span class="line"><span class="bullet">*</span> [<span class="string">CHAPTER 1</span>](<span class="link">./ch1/Chapter1.md</span>)</span><br><span class="line"><span class="bullet">    *</span> [<span class="string">ch1.1</span>](<span class="link">./ch1/ch1.1/ch1.1.md</span>)  &lt;!-- 支持文档做子目录 --&gt;</span><br><span class="line"></span><br><span class="line">------  &lt;!-- 章节分割线 --&gt;</span><br><span class="line"><span class="bullet">*</span> [<span class="string">Last Chapter</span>](<span class="link">./last_ch/last_ch.md</span>)</span><br><span class="line"><span class="bullet">    *</span> [<span class="string">title1</span>](<span class="link">./last_ch/last_ch.md#title1</span>)  &lt;!-- 也支持文件中的锚点做目录 --&gt;</span><br><span class="line"><span class="bullet">    *</span> [<span class="string">title2</span>](<span class="link">./last_ch/last_ch.md#title2</span>)</span><br><span class="line"><span class="bullet">        *</span> [<span class="string">title2.1</span>](<span class="link">./last_ch/last_ch.md#title2-1</span>)</span><br><span class="line"><span class="bullet">            *</span> [<span class="string">title2.1</span>](<span class="link">./last_ch/last_ch.md#title2-1-1</span>)</span><br><span class="line"><span class="bullet">        *</span> [<span class="string">title2.2</span>](<span class="link">./last_ch/last_ch.md#title2-2</span>)</span><br></pre></td></tr></table></figure><p>可以对比着看</p><h2 id="3-2-GLOSSARY-md"><a href="#3-2-GLOSSARY-md" class="headerlink" title="3.2 GLOSSARY.md"></a>3.2 GLOSSARY.md</h2><p>专业词汇表文件，默认对应的文件是 <code>GLOSSARY.md</code>。该文件主要存储词汇信息，如果在其他页面中出现了该文件中的词汇，鼠标放到词汇上会给出词汇示意，看一下基本格式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## Markdown</span></span><br><span class="line">简洁优雅的排版语言,简化版的 <span class="code">`HTML`</span>,加强版的 <span class="code">`TXT`</span>,详情请google</span><br><span class="line"></span><br><span class="line"><span class="section">## git</span></span><br><span class="line">分布式版本控制系统,详情请google</span><br></pre></td></tr></table></figure><h2 id="3-3-book-json"><a href="#3-3-book-json" class="headerlink" title="3.3 book.json"></a>3.3 book.json</h2><p>这个是全局的额配置文件，节选部分</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./docs&quot;</span><span class="punctuation">,</span>  <span class="comment">// 定义文档的根目录</span></span><br><span class="line">    <span class="attr">&quot;links&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;sidebar&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Baidu&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.baidu.com/&quot;</span>  <span class="comment">// 这个是侧边栏的链接</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;language&quot;</span><span class="punctuation">:</span> <span class="string">&quot;en&quot;</span><span class="punctuation">,</span>  <span class="comment">// 定义语言</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;No description!&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;978-0-13-601970-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SidneyGod&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A Book with Gitbook&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">// 安装的插件列表</span></span><br><span class="line">        <span class="string">&quot;-lunr&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-search&quot;</span><span class="punctuation">,</span> <span class="string">&quot;search-pro&quot;</span><span class="punctuation">,</span></span><br><span class="line">        ...<span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;anchor-navigation-ex&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pluginsConfig&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 插件配置</span></span><br><span class="line">        <span class="attr">&quot;chart&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c3&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        ...<span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;prism&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;css&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;prism-themes/themes/prism-base16-ateliersulphurpool.light.css&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;styles&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 自定义样式表</span></span><br><span class="line">        <span class="attr">&quot;website&quot;</span><span class="punctuation">:</span> <span class="string">&quot;styles/website.css&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ebook&quot;</span><span class="punctuation">:</span> <span class="string">&quot;styles/ebook.css&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pdf&quot;</span><span class="punctuation">:</span> <span class="string">&quot;styles/pdf.css&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;mobi&quot;</span><span class="punctuation">:</span> <span class="string">&quot;styles/mobi.css&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;epub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;styles/epub.css&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-new-doc"><a href="#3-4-new-doc" class="headerlink" title="3.4 new doc"></a>3.4 new doc</h2><p>添加新文档，我建议还是一条目录一个markdown文件比较好，文件夹分级与<code>SUMMARY.md</code>保持一致，我安装了很多插件，基本上所有的效果都能实现。尽情用markdown挥洒吧..</p><p>关于之前的<code>gitbook serve</code>报error问题，是因为prsim插件不识别<code>txt</code>语言导致，就是写代码块指定prsim认识的语言才不会报错，不过报错也不影响使用。prsim目前支持218种语言：<a href="https://prismjs.com/#supported-languages">https://prismjs.com/#supported-languages</a></p><p>其他问题，自行Google..局域网中可以访问，没毛病..</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0-start&quot;&gt;&lt;a href=&quot;#0-start&quot; class=&quot;headerlink&quot; title=&quot;0 start&quot;&gt;&lt;/a&gt;0 start&lt;/h1&gt;&lt;p&gt;感觉最近看的不少东西都是用gitbook写的，看起来也确实怪舒服的，举个例子：&lt;a href=&quot;https://lingcoder.github.io/OnJava8/#/sidebar&quot;&gt;https://lingcoder.github.io/OnJava8/#/sidebar&lt;/a&gt;，既能当博客又能当Wiki，于是我准备自己搭建一个。参考网上的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;文档编写采用统一标准，都用Markdown格式的，最后可以用gitbook自动生成静态网页；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分配好各阶段（版本）相关责任人编写的文档，待文档编写完成后统一上传到git；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;jenkins负责拉取正式版本（release开头）的文档，用gitbook编译后，同步到云端文档服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;云端服务器制作一个入口页面，页面里面可以指引各个版本文档；http服务用nginx，指引到这个页面；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中第三步我觉得没必要用Jenkins，直接设置一个定时任务就好了。。其实搭建一个从零开始搭建一个完整Gitbook还是比较麻烦的，详情参考下方的参考文档。我既然说了快速，那必然是简单而又傻瓜式的搭建了..Let’s go!&lt;/p&gt;</summary>
    
    
    
    <category term="Other" scheme="https://sidneyding.cn/categories/Other/"/>
    
    
    <category term="blog" scheme="https://sidneyding.cn/tags/blog/"/>
    
    <category term="gitbook" scheme="https://sidneyding.cn/tags/gitbook/"/>
    
    <category term="wiki" scheme="https://sidneyding.cn/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>[Relearning C/Cpp] Operators and Expressions</title>
    <link href="https://sidneyding.cn/posts/ea0e14e5/"/>
    <id>https://sidneyding.cn/posts/ea0e14e5/</id>
    <published>2020-06-17T15:15:07.000Z</published>
    <updated>2021-12-26T15:07:46.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1 算数运算符"></a>1 算数运算符</h1><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">把两个操作数相加</td><td align="left">A + B 将得到 30</td></tr><tr><td align="left">-</td><td align="left">从第一个操作数中减去第二个操作数</td><td align="left">A - B 将得到 -10</td></tr><tr><td align="left">*</td><td align="left">把两个操作数相乘</td><td align="left">A * B 将得到 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">分子除以分母</td><td align="left">B &#x2F; A 将得到 2</td></tr><tr><td align="left">%</td><td align="left">取模运算符，整除后的余数</td><td align="left">B % A 将得到 0</td></tr><tr><td align="left">++</td><td align="left">自增运算符，整数值增加 1</td><td align="left">A++ 将得到 11</td></tr><tr><td align="left">–</td><td align="left">自减运算符，整数值减少 1</td><td align="left">A– 将得到 9</td></tr></tbody></table><p>没啥好说的，可能比较有意思的是，<code>++</code>和<code>--</code>了</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        s = s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s: %d\n&quot;</span>, s);  <span class="comment">// s: 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一眼看过去，那不得炸毛？啥，不说等于10，起码也得等于9吧。说好的先运算，再自加1呢。其实感觉都被那句话给带偏了，前置++是先自增，再运算；后置++是先运算，再自增。这句话是不准确的，准确来说，无论前置++还是后置++，都是先+1，再运算，区别是后置++会先将原来的值存在一个临时变量中，运算的时候用这个临时变量运算。</p><p>在第五版的C++ Primer的132页，有这么一句话：<strong>前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容</strong>。也就是说，真实情况应该是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = s;</span><br><span class="line">        s = s + <span class="number">1</span>;</span><br><span class="line">        s = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s: %d\n&quot;</span>, s);  <span class="comment">// s: 0 这样毫无疑问是等于0的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不信？我们看看汇编代码(<code>gcc -S main.cpp -o main.s</code>)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; 略...</span><br><span class="line">call__main</span><br><span class="line">movl$0, -4(%rbp)    ; 这个是int s = 0;</span><br><span class="line">movl$0, -8(%rbp)    ; int i = 0;</span><br><span class="line">.L5:</span><br><span class="line">cmpl$9, -8(%rbp)    ; i和9作比较</span><br><span class="line">jg.L4                 ; 大于9就跳到.L4</span><br><span class="line">movl-4(%rbp), %eax  ; 把s的值放到eax先 是0</span><br><span class="line">leal1(%rax), %edx   ; rax + 1放到edx，rax没出现过，就当是0好了</span><br><span class="line">movl%edx, -4(%rbp)  ; 把edx值1放到s中 s = 1</span><br><span class="line">movl%eax, -4(%rbp)  ; 把eax的值放到s中 s = 0</span><br><span class="line">addl$1, -8(%rbp)    ; i = i + 1</span><br><span class="line">jmp.L5                 ; 跳回到.L5</span><br><span class="line">.L4:</span><br><span class="line">; 略...</span><br></pre></td></tr></table></figure><p>所以C++ Primer中<strong>推荐优先使用前置运算符</strong></p><h1 id="2-逻辑和关系运算符"><a href="#2-逻辑和关系运算符" class="headerlink" title="2 逻辑和关系运算符"></a>2 逻辑和关系运算符</h1><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td align="left">(A &amp;&amp; B) 为假。</td></tr><tr><td align="left">||</td><td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td align="left">(A || B) 为真。</td></tr><tr><td align="left">!</td><td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td align="left"></td></tr><tr><td align="left">&#x3D;&#x3D;</td><td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">(A &#x3D;&#x3D; B) 不为真。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td align="left">(A !&#x3D; B) 为真。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt; B) 不为真。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt; B) 为真。</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt;&#x3D; B) 不为真。</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt;&#x3D; B) 为真。</td></tr></tbody></table><p>注意&amp;&amp;和||是短路的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(expr1) &amp;&amp; (expr2);  <span class="comment">// 如果计算出expr1是false，就不会再去计算expr2</span></span><br><span class="line">(expr1) || (expr2);  <span class="comment">// 如果计算出expr1是true，就不会再去计算expr2</span></span><br></pre></td></tr></table></figure><h1 id="3-赋值运算符"><a href="#3-赋值运算符" class="headerlink" title="3 赋值运算符"></a>3 赋值运算符</h1><p>任何一种复合赋值运算符都等价于<code>a = a op b</code>。例如：<code>a += 1;</code>就等价于<code>a = a + 1;</code>。唯一的区别就是，使用复合赋值运算符只求值一次，使用普通赋值运算需要求值两次。第一次，右边运算求一次值；第二次，赋值的时候左侧运算对象求值。这么说来还是复合赋值运算符好一点</p><h1 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4 位运算符"></a>4 位运算符</h1><p>假设变量 A 的值为 60，变量 B 的值为 13，则：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td align="left">(A | B) 将得到 61，即为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td align="left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td align="left">~</td><td align="left">二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td><td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><p><strong>位运算符作用于位，并逐位执行操作。</strong>在kernel中经常喜欢用位运算做flag判断，感受一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> FLAG_0 = <span class="number">0b000</span>;  <span class="comment">// 0</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> FLAG_1 = <span class="number">0b001</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> FLAG_2 = <span class="number">0b010</span>;  <span class="comment">// 2</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> FLAG_4 = <span class="number">0b100</span>;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> flag_0 = FLAG_0;</span><br><span class="line"><span class="type">unsigned</span> flag_1 = FLAG_1;</span><br><span class="line"><span class="type">unsigned</span> flag_0_1 = FLAG_0 | FLAG_1;</span><br><span class="line"><span class="type">unsigned</span> flag_1_2 = FLAG_1 | FLAG_2;</span><br><span class="line"><span class="type">unsigned</span> flag_1_2_4 = FLAG_1 | FLAG_2 | FLAG_4;</span><br><span class="line"></span><br><span class="line"><span class="comment">// |表示+?</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_0_1: %d\n&quot;</span>, flag_0_1);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2: %d\n&quot;</span>, flag_1_2);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2_4: %d\n&quot;</span>, flag_1_2_4);  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0和&amp; 可以用来清空</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_0 &amp; FLAG_0: %d\n&quot;</span>, flag_0 &amp; FLAG_0);  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1 &amp; FLAG_0: %d\n&quot;</span>, flag_1 &amp; FLAG_0);  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非0和&amp; 可以用来判断包不包含当前的FLAG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1 &amp; FLAG_1: %d\n&quot;</span>, flag_1 &amp; FLAG_1);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1 &amp; FLAG_2: %d\n&quot;</span>, flag_1 &amp; FLAG_2);  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// |并不是单纯的+ 不包含则+ 包含则不加；&amp;(~FLAG)表示减去这个FLAG 有则减 无则不用管</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2 | FLAG_1: %d\n&quot;</span>, flag_1_2 | FLAG_1);  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2 &amp; FLAG_1: %d\n&quot;</span>, flag_1_2 &amp; FLAG_1);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2 &amp; (FLAG_1 | FLAG_4): %d\n&quot;</span>, flag_1_2 &amp; (FLAG_1 | FLAG_4));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2 &amp; (~FLAG_1): %d\n&quot;</span>, flag_1_2 &amp; (~FLAG_1));  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2 &amp; (~(FLAG_1 | FLAG_4)): %d\n&quot;</span>, flag_1_2 &amp; (~(FLAG_1 | FLAG_4)));  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2_4 | FLAG_1 | FLAG_2: %d\n&quot;</span>, flag_1_2_4 | FLAG_1 | FLAG_2);  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2_4 &amp; (FLAG_1 | FLAG_2): %d\n&quot;</span>, flag_1_2_4 &amp; (FLAG_1 | FLAG_2));  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag_1_2_4 &amp; (~(FLAG_1 | FLAG_2)): %d\n&quot;</span>, flag_1_2_4 &amp; (~(FLAG_1 | FLAG_2)));  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>强烈建议位运算只用于无符号数..</strong></p><h1 id="5-杂项"><a href="#5-杂项" class="headerlink" title="5 杂项"></a>5 杂项</h1><p>条件运算符：<code>?:</code>，唯一一个三元运算符，就是一个简化版的if-else，但是效率比if-else高</p><p>sizeof运算符：<code>sizeof(expr)</code>，事实上并<strong>不会去使用expr</strong>，所以即使<code>sizeof(*ptr)</code>，其中ptr是null，也不会报错，多用于求数组长度，毕竟C&#x2F;C++没有<code>arr.length</code>的用法</p><p>逗号运算符：<code>v = expr1, expr2</code>，从左向右的顺序依次求值，然后丢弃左侧结果的值，<strong>真正返回的是右侧的值</strong></p><h1 id="6-成员访问运算符"><a href="#6-成员访问运算符" class="headerlink" title="6 成员访问运算符"></a>6 成员访问运算符</h1><p>就是点运算符<code>.</code>和箭头运算符<code>-&gt;</code>。其中点运算符是获取类对象的一个成员。<code>ptr-&gt;mem</code>或<code>(*ptr).mem</code>，注意<strong>解引用运算符低于点运算符</strong></p><p>运算符优先级：<a href="https://blog.csdn.net/yuliying/article/details/72898132">https://blog.csdn.net/yuliying/article/details/72898132</a></p><table border="1" cellspacing="0" cellpadding="0" width="612"><tbody><tr><td><p align="center"><strong>优先级</strong></p></td><td><p align="center"><strong>运算符</strong></p></td><td><p align="center"><strong>名称或含义</strong></p></td><td><p align="center"><strong>使用形式</strong></p></td><td><p align="center"><strong>结合方向</strong></p></td><td><p align="center"><strong>说明</strong></p></td></tr><tr><td rowspan="4"><p align="center"><strong>1</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">[]</span></strong></p></td><td><p>数组下标</p></td><td><p>数组名[常量表达式]</p></td><td rowspan="4"><p align="center">左到右</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">()</span></strong></p></td><td><p>圆括号</p></td><td><p>(表达式）/函数名(形参表)</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">.</span></strong></p></td><td><p>成员选择（对象）</p></td><td><p>对象.成员名</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">-&gt;</span></strong></p></td><td><p>成员选择（指针）</p></td><td><p>对象指针-&gt;成员名</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="9"><p align="center"><strong>2</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">-</span></strong></p></td><td><p>负号运算符</p></td><td><p>-表达式</p></td><td rowspan="9"><p align="center"><strong><span style="color:#FF0000;">右到左</span></strong></p></td><td rowspan="7"><p align="center">单目运算符</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">~</span></strong></p></td><td><p>按位取反运算符</p></td><td><p>~表达式</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">++</span></strong></p></td><td><p>自增运算符</p></td><td><p>++变量名/变量名++</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">--</span></strong></p></td><td><p>自减运算符</p></td><td><p>--变量名/变量名--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">*</span></strong></p></td><td><p>取值运算符</p></td><td><p>*指针变量</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">&amp;</span></strong></p></td><td><p>取地址运算符</p></td><td><p>&amp;变量名</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">!</span></strong></p></td><td><p>逻辑非运算符</p></td><td><p>!表达式</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">(</span><span style="color:#0000FF;">类型</span><span style="color:#0000FF;">)</span></strong></p></td><td><p>强制类型转换</p></td><td><p>(数据类型)表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">sizeof</span></strong></p></td><td><p>长度运算符</p></td><td><p>sizeof(表达式)</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="3"><p align="center"><strong>3</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">/</span></strong></p></td><td><p>除</p></td><td><p>表达式/表达式</p></td><td rowspan="3"><p align="center">左到右</p></td><td rowspan="3"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">*</span></strong></p></td><td><p>乘</p></td><td><p>表达式*表达式</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">%</span></strong></p></td><td><p>余数（取模）</p></td><td><p>整型表达式%整型表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>4</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">+</span></strong></p></td><td><p>加</p></td><td><p>表达式+表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">-</span></strong></p></td><td><p>减</p></td><td><p>表达式-表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>5</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">&lt;&lt;&nbsp;</span></strong></p></td><td><p>左移</p></td><td><p>变量&lt;&lt;表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">&gt;&gt;&nbsp;</span></strong></p></td><td><p>右移</p></td><td><p>变量&gt;&gt;表达式</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="4"><p align="center"><strong>6</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">&gt;&nbsp;</span></strong></p></td><td><p>大于</p></td><td><p>表达式&gt;表达式</p></td><td rowspan="4"><p align="center">左到右</p></td><td rowspan="4"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">&gt;=</span></strong></p></td><td><p>大于等于</p></td><td><p>表达式&gt;=表达式</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">&lt;&nbsp;</span></strong></p></td><td><p>小于</p></td><td><p>表达式&lt;表达式</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">&lt;=</span></strong></p></td><td><p>小于等于</p></td><td><p>表达式&lt;=表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>7</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">==</span></strong></p></td><td><p>等于</p></td><td><p>表达式==表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">！</span><span style="color:#0000FF;">=</span></strong></p></td><td><p>不等于</p></td><td><p>表达式!= 表达式</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>8</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">&amp;</span></strong></p></td><td><p>按位与</p></td><td><p>表达式&amp;表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>9</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">^</span></strong></p></td><td><p>按位异或</p></td><td><p>表达式^表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>10</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">|</span></strong></p></td><td><p>按位或</p></td><td><p>表达式|表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>11</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">&amp;&amp;</span></strong></p></td><td><p>逻辑与</p></td><td><p>表达式&amp;&amp;表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>12</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">||</span></strong></p></td><td><p>逻辑或</p></td><td><p>表达式||表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>13</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">?:</span></strong></p></td><td><p>条件运算符</p></td><td><p>表达式1?</p><p>表达式2: 表达式3</p></td><td><p align="center"><strong><span style="color:#FF0000;">右到左</span></strong></p></td><td><p align="center"><span style="color:#FF0000;">三目运算符</span></p></td></tr><tr><td width="612" colspan="6"><p><span style="color:#FF0000;">&nbsp;</span></p></td></tr><tr><td rowspan="11"><p align="center"><strong>14</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">=</span></strong></p></td><td><p>赋值运算符</p></td><td><p>变量=表达式</p></td><td rowspan="11"><p align="center"><strong><span style="color:#FF0000;">右到左</span></strong></p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">/=</span></strong></p></td><td><p>除后赋值</p></td><td><p>变量/=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">*=</span></strong></p></td><td><p>乘后赋值</p></td><td><p>变量*=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">%=</span></strong></p></td><td><p>取模后赋值</p></td><td><p>变量%=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">+=</span></strong></p></td><td><p>加后赋值</p></td><td><p>变量+=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">-=</span></strong></p></td><td><p>减后赋值</p></td><td><p>变量-=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">&lt;&lt;=</span></strong></p></td><td><p>左移后赋值</p></td><td><p>变量&lt;&lt;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">&gt;&gt;=</span></strong></p></td><td><p>右移后赋值</p></td><td><p>变量&gt;&gt;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">&amp;=</span></strong></p></td><td><p>按位与后赋值</p></td><td><p>变量&amp;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">^=</span></strong></p></td><td><p>按位异或后赋值</p></td><td><p>变量^=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="color:#0000FF;">|=</span></strong></p></td><td><p>按位或后赋值</p></td><td><p>变量|=表达式</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>15</strong></p></td><td><p align="center"><strong><span style="color:#0000FF;">,</span></strong></p></td><td><p>逗号运算符</p></td><td><p>表达式,表达式,…</p></td><td><p align="center">左到右</p></td><td><p align="center">--</p></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-算数运算符&quot;&gt;&lt;a href=&quot;#1-算数运算符&quot; class=&quot;headerlink&quot; title=&quot;1 算数运算符&quot;&gt;&lt;/a&gt;1 算数运算符&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;运算符&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;描述&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;+&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;把两个操作数相加&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;A + B 将得到 30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;-&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;从第一个操作数中减去第二个操作数&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;A - B 将得到 -10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;*&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;把两个操作数相乘&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;A * B 将得到 200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&amp;#x2F;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;分子除以分母&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;B &amp;#x2F; A 将得到 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;%&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;取模运算符，整除后的余数&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;B % A 将得到 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;++&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;自增运算符，整数值增加 1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;A++ 将得到 11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;–&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;自减运算符，整数值减少 1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;A– 将得到 9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;没啥好说的，可能比较有意思的是，&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;--&lt;/code&gt;了&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="https://sidneyding.cn/categories/Language/"/>
    
    <category term="C/Cpp" scheme="https://sidneyding.cn/categories/Language/C-Cpp/"/>
    
    
    <category term="Relearning C/Cpp" scheme="https://sidneyding.cn/tags/Relearning-C-Cpp/"/>
    
  </entry>
  
  <entry>
    <title>[Relearning C/Cpp] Foundation Type</title>
    <link href="https://sidneyding.cn/posts/6a5ea6b7/"/>
    <id>https://sidneyding.cn/posts/6a5ea6b7/</id>
    <published>2020-06-16T14:13:04.000Z</published>
    <updated>2022-05-24T14:52:26.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-标识符-关键字"><a href="#1-标识符-关键字" class="headerlink" title="1 标识符 关键字"></a>1 标识符 关键字</h1><p>标识符命名规则：</p><ol><li>变量名只能是字母（A-Z，a-z）和数字（0-9）或者下划线（_）或者美元符号（**$**）组成</li><li>第一个字母不能是数字</li><li>不能使用C&#x2F;C++关键字来命名变量</li><li>变量名区分大小写</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> $name1, _name2, Name3;</span><br></pre></td></tr></table></figure><blockquote><p>似乎有的版本不支持<code>$</code>..我试了gcc8.1是可以的</p></blockquote><p>C语言关键字：</p><span id="more"></span><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>声明自动变量</td></tr><tr><td>short</td><td>声明短整型变量或函数</td></tr><tr><td>int</td><td>声明整型变量或函数</td></tr><tr><td>long</td><td>声明长整型变量或函数</td></tr><tr><td>float</td><td>声明浮点型变量或函数</td></tr><tr><td>double</td><td>声明双精度变量或函数</td></tr><tr><td>char</td><td>声明字符型变量或函数</td></tr><tr><td>struct</td><td>声明结构体变量或函数</td></tr><tr><td>union</td><td>声明共用数据类型</td></tr><tr><td>enum</td><td>声明枚举类型</td></tr><tr><td>typedef</td><td>用以给数据类型取别名</td></tr><tr><td>const</td><td>声明只读变量</td></tr><tr><td>unsigned</td><td>声明无符号类型变量或函数</td></tr><tr><td>signed</td><td>声明有符号类型变量或函数</td></tr><tr><td>extern</td><td>声明变量是在其他文件正声明</td></tr><tr><td>register</td><td>声明寄存器变量</td></tr><tr><td>static</td><td>声明静态变量</td></tr><tr><td>volatile</td><td>说明变量在程序执行中可被隐含地改变</td></tr><tr><td>void</td><td>声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td>if</td><td>条件语句</td></tr><tr><td>else</td><td>条件语句否定分支（与 if 连用）</td></tr><tr><td>switch</td><td>用于开关语句</td></tr><tr><td>case</td><td>开关语句分支</td></tr><tr><td>for</td><td>一种循环语句</td></tr><tr><td>do</td><td>循环语句的循环体</td></tr><tr><td>while</td><td>循环语句的循环条件</td></tr><tr><td>goto</td><td>无条件跳转语句</td></tr><tr><td>continue</td><td>结束当前循环，开始下一轮循环</td></tr><tr><td>break</td><td>跳出当前循环</td></tr><tr><td>default</td><td>开关语句中的“其他”分支</td></tr><tr><td>sizeof</td><td>计算数据类型长度</td></tr><tr><td>return</td><td>子程序返回语句（可以带参数，也可不带参数）循环条件</td></tr></tbody></table><p>C++关键字：</p><p><img data-src="/assets/00_Relearning-C-Cpp-Foundation-Type/Cpp_Keywords.jpg" alt="Cpp_Keywords"></p><p><a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html">https://www.runoob.com/w3cnote/cpp-keyword-intro.html</a></p><h1 id="2-变量声明-定义-初始化"><a href="#2-变量声明-定义-初始化" class="headerlink" title="2 变量声明 定义 初始化"></a>2 变量声明 定义 初始化</h1><p>补充知识，C语言从源文件到可执行文件一般经历四个步骤：预处理，编译，汇编，链接</p><p><strong>声明</strong>：声明是只是向编译器声明一下我用到的变量或者类型，与分配内存毫无关系</p><p><strong>定义</strong>：给变量分配了空间才叫做定义。定义往往是附庸于声明的，通俗地说，也就是只当你先声明了一个变量，才有可能为其分配空间（定义）</p><p><strong>初始化</strong>：定义只是给变量分配了内存空间，但一开始决定这内存空间存放什么值是由初始化决定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在C中直接这样写IDE是不会报错的 就是说在预处理阶段是不会有问题的</span></span><br><span class="line"><span class="comment">// 在C++中要指明aa的类型 即 extern int aa;</span></span><br><span class="line"><span class="keyword">extern</span> aa;  <span class="comment">// 声明没有分配空间 即使是extern int aa;也没有分配空间 其实在c中不加类型 默认是int</span></span><br><span class="line"><span class="type">int</span> aa;  <span class="comment">// 这里分配了int大小的空间给aa，即定义aa的大小</span></span><br><span class="line">aa = <span class="number">10</span>;  <span class="comment">// 这里初始化aa的值</span></span><br><span class="line"><span class="type">int</span> a &#123;<span class="number">10</span>&#125;;  <span class="comment">// 在C++中初始化不一定就是=，还可以用&#123;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="3-变量类型-大小-类型转换"><a href="#3-变量类型-大小-类型转换" class="headerlink" title="3 变量类型 大小 类型转换"></a>3 变量类型 大小 类型转换</h1><p><strong>变量类型</strong></p><p>C变量类型：</p><table><thead><tr><th>说  明</th><th>字符型</th><th>短整型</th><th>整型</th><th>长整型</th><th>单精度浮点型</th><th>双精度浮点型</th><th>无类型</th></tr></thead><tbody><tr><td>数据类型</td><td>char</td><td>short</td><td>int</td><td>long</td><td>float</td><td>double</td><td>void</td></tr></tbody></table><p>除了<code>float</code>，<code>double</code>，<code>void</code>都还可以再加个<code>unsigned</code>修饰；(还有就是<code>struct</code>，<code>enum</code>，<code>union</code>复合类型了，只说基础变量类型)</p><p>C++变量类型：除了C语言的，还有<code>bool</code>，<code>wchar_t</code>(宽字符类型)，还有一个和<code>struct</code>差不多的<code>class</code></p><p><strong>变量大小</strong></p><p>ANSI&#x2F;ISO制订的4条铁定的原则</p><ol><li>sizeof(short int)&lt;&#x3D;sizeof(int)</li><li>sizeof(int)&lt;&#x3D;sizeof(long int)</li><li>short int至少应为16位（2字节）</li><li>long int至少应为32位</li></ol><p>常见系统情况</p><p>参考：<a href="https://blog.csdn.net/weixin_30367359/article/details/81211393">https://blog.csdn.net/weixin_30367359/article/details/81211393</a></p><p><strong>类型转换</strong></p><p>C中<strong>自动类型转换</strong>：编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生</p><p>将一种类型的数据赋值给另外一种类型的变量时就会发生自动类型转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">100</span>;  <span class="comment">// 这里100是int型，需要先转换为float型才能赋值给f</span></span><br></pre></td></tr></table></figure><p>在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换规则如下：</p><p><img data-src="/assets/00_Relearning-C-Cpp-Foundation-Type/type_conversion.png" alt="type_conversion"></p><p>也就是说，在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型转换为左边变量的类型，这可能会导致数据失真，或者精度降低；所以说，<strong>自动类型转换并不一定是安全的</strong>。对于不安全的类型转换，编译器一般会给出警告。</p><p>C中<strong>强制类型转换</strong>：在代码中明确地提出要进行类型转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强转规则 (type_name) expression</span></span><br><span class="line">(<span class="type">float</span>) <span class="number">100</span>;  <span class="comment">// 将100转为float类型</span></span><br><span class="line"></span><br><span class="line">(<span class="type">double</span>) <span class="number">10</span> / <span class="number">4</span>;  <span class="comment">// 2.500000</span></span><br><span class="line">(<span class="type">double</span>) (<span class="number">10</span> / <span class="number">4</span>);  <span class="comment">// 2.000000</span></span><br><span class="line"><span class="comment">// 因为()优先级比/高 这一点需要注意</span></span><br></pre></td></tr></table></figure><p>如何理解<strong>类型转换只是临时性的</strong></p><p>无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">5.5</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> id = (<span class="type">int</span>) d;</span><br><span class="line"><span class="type">double</span> result = d / i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %lf, %lf\n&quot;</span>, id, d, result);  <span class="comment">// 5, 5.500000, 1.100000</span></span><br><span class="line"><span class="comment">// 虽然第3行对d进行强转了，但是并没有改变d的值</span></span><br></pre></td></tr></table></figure><p>C++中类型转换，首先C语言能用的，C++都能用，不过强制类型转换，C++有自己的一套</p><p><strong>static_cast</strong>：<code>static_cast&lt;type_id&gt; (expression)</code></p><p>用于类层次结构中基类和派生类之间指针或引用的转换</p><p>用于基本数据类型之间的转换，如把int转换成char</p><p>把空指针转换成目标类型的空指针</p><p>把任何类型的表达式转换为void类型</p><p><strong>注意：static_cast不能转换掉expression的<code>const</code>、<code>volitale</code>或者<code>__unaligned</code>属性</strong></p><p><strong>const_cast</strong>：<code>const_cast&lt;type_id&gt; (expression)</code></p><p>用来修改类型的const或volatile属性。除了const或volatile修饰之外，type_id和expression的类型是一样的</p><p>常量指针被转化成非常量指针，并且仍然指向原来的对象</p><p>常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象</p><p><strong>const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">101</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *p = 22;  // 只读 不允许修改</span></span><br><span class="line"><span class="comment">// int b = const_cast&lt;int&gt;(a);  // const_cast强制转换对象必须为指针或引用</span></span><br><span class="line"><span class="type">int</span>* c = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(p);  <span class="comment">// 去掉const属性</span></span><br><span class="line">*c = <span class="number">22</span>;  <span class="comment">// 没毛病 *p值就能改了</span></span><br></pre></td></tr></table></figure><p><strong>reinterpret_cast</strong>：<code>reinterpret_cast&lt;type_id&gt; (expression)</code></p><p>改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转换为指针或引用类型</p><p>type_id必须是一个指针、引用、算术类型、函数指针或者成员指针</p><p><strong>在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 万物皆可转..</span></span><br><span class="line"><span class="type">int</span> *i = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">double</span> *d = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span> *&gt;(i);</span><br></pre></td></tr></table></figure><p><strong>dynamic_cast</strong>：<code>dynamic_cast&lt;type_id&gt; (expression)</code></p><p><strong>其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查</strong></p><p><strong>不能用于内置的基本数据类型的强制转换</strong></p><p><strong>dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL</strong></p><p><strong>使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过</strong>(需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表)</p><p><strong>在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</strong></p><p><strong>向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败</strong></p><p>嗯..略..</p><h1 id="4-变量作用域"><a href="#4-变量作用域" class="headerlink" title="4 变量作用域"></a>4 变量作用域</h1><p>能不能简单理解为一个<code>&#123;&#125;</code>就是一个域，总有没套在<code>&#123;&#125;</code>里面的，那肯定比在<code>&#123;&#125;</code>里活得久啊</p><p>变量作用域，一是看其能覆盖到哪，二是看其能活多久</p><p>首先，强龙压不过地头蛇，其次，你得让人作用域见过你</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 没有被&#123;&#125;包裹 全局变量 活得久</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);  <span class="comment">// 这个肯定没问题 声明在上面见过 作用域比a小</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, b);  // 找不到b的声明</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">11</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);  <span class="comment">// 11 这就叫强龙压不过地头蛇 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>这又牵扯到了声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">extern</span> bb;  <span class="comment">// 这里声明一下 让编译器去找</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, bb);  <span class="comment">// 在这个作用域就可以用了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, bb);  // 这个就不行 在这个作用域中没有声明过 找不到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bb = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>再说说全局变量和局部变量</p><ul><li>在函数或一个代码块内部定义的变量，称为局部变量</li><li>在函数参数的定义中定义的变量，称为形式参数</li><li>在所有函数外部定义的变量，称为全局变量</li></ul><p>为什么说extern修饰的变量是全局变量？其实我觉得和extern没关系，毕竟extern只是声明，不分配空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">extern</span> a, b;</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;, a);  // 既声明也在下面定义了 但是编译的时候还是会报错 undefined</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);  <span class="comment">// 全局的就没问题了 也就是说extern是在全局变量中找 而不是声明为全局</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>可以看到，C语言的作用域还是蛮简单的，C++还有个域操作符<code>::</code>，其实也很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> names &#123;  <span class="comment">// 这就声明一个命名空间</span></span><br><span class="line">    <span class="type">int</span> aa = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> aa = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> aa = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 10 - 20 - 30  有内味了 names下的aa，没名字下的aa，没名字就叫全局</span></span><br><span class="line">    std::cout &lt;&lt; names::aa &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; ::aa &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; aa &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再说一点class的知识</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;  <span class="comment">// 这叫声明一个函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AA::print</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 这叫定义一个函数 你不说明是aa的print，那编译器哪知道是不是</span></span><br></pre></td></tr></table></figure><h1 id="5-变量存储位置"><a href="#5-变量存储位置" class="headerlink" title="5 变量存储位置"></a>5 变量存储位置</h1><p>一个C&#x2F;C++程序的内存占用情况</p><p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量的值等</p><p>堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式类似于链表</p><p>全局区&#x2F;静态区：全局变量和静态变量的存储是放在一块的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量又放在相邻的另一块区域中。程序结束后由系统释放</p><p>常量区：字符串常量和其他类型常量存放位置。程序结束后由系统释放</p><p>代码区：存放函数体的二进制代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">// 全局初始化区</span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">// 全局未初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> b; <span class="comment">// 栈 </span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// s在栈 &quot;abc\0&quot;在常量区</span></span><br><span class="line">    <span class="type">char</span> *p2; <span class="comment">// 栈 </span></span><br><span class="line">    <span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 123456\0 在常量区，p3在栈上。 </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>; <span class="comment">// 全局（静态）初始化区 </span></span><br><span class="line">    p1 = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">// 分配得来得10和20字节的区域就在堆区</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>); <span class="comment">// 123456\0放在常量区，编译器可能会做优化，指向p3指向的&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的划分的区对应到操作系统(深入理解计算机系统)的各种段：</p><p>bss段：Block Started by Symbol，通常是指用来存放程序中未初始化的全局变量的一块内存区域，不给该段的数据分配空间，只是记录数据所需空间的大小，bss段属于静态内存分配</p><p>data段：通常是指用来存放程序中已初始化的全局变量的一块内存区域，数据分配空间，数据保存在目标文件中，data段属于静态内存分配</p><p>rodata段：read only data segment，存放常量数据(但不是所有，有些马上数与指令编译在一起直接放在代码段)，用const修饰的全局变量是放入常量区的，可是使用const修饰的局部变量仅仅是设置为只读起到防止改动的效果，没有放入常量区，有些系统中rodata段是多个进程共享的，目的是为了提高空间的利用率</p><p>text段：通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。在text段中，也有可能包含一些只读的常数变量(<code>int a = 10;</code>中的10)等</p><p>heap：用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p><p>stack：用户存放程序临时创建的局部变量。也就是括弧<code>&#123;&#125;</code>中定义的变量（但不包括static声明的变量，static意味着在data段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存&#x2F;恢复调用现场。</p><blockquote><p><strong>一个程序本质上都是由 bss段、data段、text段三个组成的</strong>。这样的概念，不知道最初来源于哪里的规定，但在当前的计算机程序设计中是很重要的一个基本概念。一般在初始化时bss段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。比如，在C语言之类的程序编译完成之后，已初始化的全局变量保存在<code>.data</code>段中，未初始化的全局变量保存在<code>.bss</code>段中。</p><p>text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。</p></blockquote><p>应该放上一段汇编的，奈何看不太明白，mark几条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 汇编代码 8086 或者 AT&amp;T，Linux上一般是ATT的</span></span><br><span class="line">gcc -S -O2 -masm=intel main.c -o main.s</span><br><span class="line">gcc -S -O2 -masm=att main.c -o main.s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反汇编</span></span><br><span class="line">objdump -sd test.exe</span><br><span class="line">objdump -h test.exe  <span class="comment"># 查看代码段啥的..</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出目标文件的符号清单</span></span><br><span class="line">nm test.exe</span><br></pre></td></tr></table></figure><p><strong>静态变量(static)</strong></p><p>在C&#x2F;C++中，static 关键字不仅可以用来修饰变量，还可以用来修饰函数。在使用static关键字修饰变量时，我们称此变量为静态变量。静态变量的存储方式与全局变量一样，都是静态存储方式，但是全局变量不是静态变量</p><p>全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，全局变量在各个源文件中都是有效的；全局变量之前加上关键字static来实现，使全局变量被定义成为一个静态全局变量，此时该变量只能在本文件中使用，起到了对其他源文件进行<strong>隐藏与隔离</strong>的作用</p><p>如果希望函数中局部变量的值在<strong>函数调用结束之后不会消失</strong>，而仍然保留其原值，即它所占用的存储单元不释放，在下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值，此时，应该将该局部变量用关键字static声明为<strong>静态局部变量</strong>，当将局部变量声明为静态局部变量的时候，也就改变了局部变量的存储位置，即从原来的栈中存放改为静态存储区存放。这让它看起来很像全局变量，其实静态局部变量与全局变量的主要区别就在于可见性，静态局部变量只在其被声明的代码块中是可见的</p><p>在静态数据区，内存中所有的字节默认值都是0x00。静态变量与全局变量也一样，它们都存储在静态数据区中，因此其变量的值默认也为0(对自动变量不赋初值，其值是不定的，所以说有的不初始化的静态变量，有可能被优化到data段)</p><p>static对函数的修饰与对全局变量的修饰相似，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，所以satic函数又被称为内部函数</p><p><strong>寄存器变量(register)</strong></p><p><code>&#39;register&#39; storage class specifier is deprecated and incompatible with C++17</code></p><p>使用修饰符register声明的变量属于寄存器存储类型。该类型与自动存储类型相似，具有自动存储时期、代码块作用域和内连接。声明为register仅仅是一个请求，因此该变量仍然可能是普通的自动变量。无论哪种情况，用<strong>register修饰的变量都无法获取地址</strong>(在C++中，register变量在内存中有副本，可以获取到副本的地址)。如果没有被初始化，它的值是未定的。register可以加速变量值访问速度，如果不存在竞争条件，并且该变量会被频繁的访问使用，可以使用register。</p><p><strong>volatile</strong></p><p>因为访问寄存器要比访问内存单元快的多，所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。遇到volatile声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用volatile，则编译器将对所声明的语句进行优化。当一个变量存在竞争条件时，如果没有上锁，为了维护数据的统一性，则必须显式的使用volatile进行声明。在对变量声明时，默认的是使用volatile声明，但是如果没有显式的使用该修饰付，那么编译器可能会优化成register变量。</p><p>使用volatile的场景：中断服务程序中修改的供其它程序检测的变量需要；多任务环境下各任务间共享的标志；存储器映射的硬件寄存器，因为每次对它的读写都可能有不同意义</p><p><strong>const</strong></p><p>内存被初始化后，<strong>程序</strong>(硬件可以，所以const可以和volatile一起用)便不能对其进行修改。const修饰的全局变量的链接性为内部的(就像加了static)。若希望某个常量的链接性为外部的，则可以<strong>使用关键字extern覆盖默认的内部链接性</strong>，这种情况下所有使用该常量的文件都要使用extern来引用声明它，<strong>只能在其中一个文件初始化该变量，且之后该变量不可修改</strong></p><p><strong>常量：固定值</strong>，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。一般说到常量，就不得不提<code>#define</code>和<code>const</code>。define是宏定义，程序在预处理阶段将用define定义的内容进行了替换。因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存(就存储来看，我觉得不能算常量)。const定义的常量，在程序运行时在常量表中，系统为它分配内存。define定义的常量，预处理时只是直接进行了替换。所以编译时不能进行数据类型检验。const定义的常量，在编译时进行严格的类型检验，可以避免出错。define定义表达式时要注意<strong>边缘效应</strong>(就是要记得加括号，仅仅是替换)</p><p>说常量是只读的，只是个笑话，实质上内存永远都可以被用户随意修改，只是编译器给用户的代码注入了一些自己的保护代码，通过软件手段将这段内存软保护起来。这种保护在汇编级别可以轻松突破，其保护也就无效了</p><h1 id="6-类型推导"><a href="#6-类型推导" class="headerlink" title="6 类型推导"></a>6 类型推导</h1><p>在C++11之前的版本（C++98和C++03）中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；但是在一些比较灵活的语言中，比如 C#、JavaScript、PHP、Python 等，程序员在定义变量时可以不指明具体的类型，而是让编译器（或者解释器）自己去推导，这就让代码的编写更加方便，阅读更加费事(我觉得就不应该出现这玩意，编译器能推导出来是啥类型，我可不行啊)</p><p><strong>auto</strong></p><p>在之前的C++版本中，auto关键字用来指明变量的存储类型，它和static关键字是相对的。auto表示变量是自动存储的，这也是编译器的默认规则，所以写不写都一样，一般我们也不写，这使得auto关键字的存在变得非常鸡肋。C++11赋予auto关键字新的含义，使用它来做自动类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这全篇auto写下来，代码还能看？</span></span><br><span class="line"><span class="keyword">auto</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = <span class="number">12.8</span>;</span><br><span class="line"><span class="keyword">auto</span> p = &amp;n;</span><br><span class="line"><span class="keyword">auto</span> url = <span class="string">&quot;123456&quot;</span>;</span><br></pre></td></tr></table></figure><p>注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p><p>不能在函数的参数中使用；不能作用于类的非静态成员变量；不能定义数组；不能作用于模板参数</p><p><strong>decltype</strong></p><p>declare type，和auto的功能一样，都用来在编译时期进行自动类型推导，这个关键字的出现肯定为了弥补auto不足之处，用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式</span></span><br><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname[ = value];</span><br></pre></td></tr></table></figure><p>decltype能够根据变量、字面量、带有运算符的表达式推导出变量的类型</p><p>推到规则：</p><ul><li>如果exp是一个不被括号<code>()</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么<code>decltype(exp)</code>的类型就和exp一致，这是最普遍最常见的情况</li><li>如果exp是函数调用，那么<code>decltype(exp)</code>的类型就和函数返回值的类型一致</li><li>如果exp是一个左值，或者被括号<code>()</code>包围，那么<code>decltype(exp)</code>的类型就是exp的引用；假设exp的类型为<code>T</code>，那么<code>decltype(exp)</code>的类型就是<code>T&amp;</code></li></ul><p>两者之间的区别：</p><p>auto要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而decltype不要求，初始化与否都不影响变量的类型。这很容易理解，因为auto是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。</p><p>auto将变量的类型和初始值绑定在一起，而decltype将变量的类型和初始值分开；虽然auto的书写更加简洁，但decltype的使用更加灵活</p><p>如果表达式的类型不是指针或者引用，auto会把cv(const volatile)限定符直接抛弃，推导成non-const或者non-volatile类型；如果表达式的类型是指针或者引用，auto将保留cv限定符</p><p><strong>decltype会保留cv限定符</strong></p><h1 id="7-typedef"><a href="#7-typedef" class="headerlink" title="7 typedef"></a>7 typedef</h1><p><a href="https://blog.csdn.net/Andrewniu/article/details/80566324">https://blog.csdn.net/Andrewniu/article/details/80566324</a></p><p>C语言允许用户使用 typedef 关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称、数组类型名称、指针类型名称与用户自定义的结构型名称、共用型名称、枚举型名称等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>;</span><br><span class="line"><span class="comment">// 在C语言中也可以愉快地使用bool了</span></span><br><span class="line"><span class="type">bool</span> aFlag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>为基本数据类型定义新的类型名</strong></p><p>为了跨平台，定义一种类型与平台无关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SIZE_T_DEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int64    <span class="type">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> _W64 <span class="type">unsigned</span> <span class="type">int</span>   <span class="type">size_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SIZE_T_DEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称</strong></p><p>先看C语言的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagMyNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagMyNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; MyNode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagMyNode</span> *<span class="title">mTagNode</span>;</span>  <span class="comment">// 老长了</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main2</span><span class="params">()</span> &#123;</span><br><span class="line">    MyNode.data = <span class="number">8</span>;</span><br><span class="line">    mTagNode-&gt;data = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********用了typedef之后***********/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagMyNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; MyNode;</span><br><span class="line"></span><br><span class="line">MyNode *mTagNode;  <span class="comment">// 事实上等价于 typedef struct tagMyNode MyNode;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// MyNode.data = 10;</span></span><br><span class="line">    mTagNode-&gt;data = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********再来个有趣的**********/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagMyNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; MyNode, Node;</span><br><span class="line"></span><br><span class="line">MyNode *mTagNode;  <span class="comment">// typedef struct tagMyNode MyNode;</span></span><br><span class="line">Node *mNode;  <span class="comment">// typedef struct tagMyNode Node;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    mTagNode-&gt;data = <span class="number">10</span>;</span><br><span class="line">    mNode-&gt;data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看C++有没有什么不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tagMyNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tagMyNode</span> *next;</span><br><span class="line">&#125; MyNode;</span><br><span class="line"></span><br><span class="line">tagMyNode *mTagNode;  <span class="comment">// 这里其实是把struct当class用了</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tagMyNode</span> *mTagNode2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyNode.data = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// tagMyNode-&gt;data = 10;  // 没有初始化的类不能操作 但可以 mTagNode = new tagMyNode;</span></span><br><span class="line">    mTagNode2-&gt;data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********使用typedef*************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagMyNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tagMyNode</span> *next;</span><br><span class="line">&#125; MyNode;</span><br><span class="line"></span><br><span class="line">tagMyNode *mTagNode;  <span class="comment">// 事实上这里是 class tagMyNode;</span></span><br><span class="line">MyNode *mTagNode2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tagMyNode-&gt;data = 10;</span></span><br><span class="line">    mTagNode2-&gt;data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为数组定义简介类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT_ARR_LEN_10[<span class="number">10</span>];</span><br><span class="line">INT_ARR_LEN_10 arr;</span><br></pre></td></tr></table></figure><p><strong>为指针定义简洁的名称</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* PCHAR;</span><br><span class="line">PCHAR pc;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> PCHAR pChar;  <span class="comment">// 等价于const char* pChar;吗？</span></span><br><span class="line"><span class="comment">// 其实是不等价的，typedef不是字符串替换，这里const应当是修饰指针的，即指针常量(网上通俗叫法)</span></span><br><span class="line"><span class="comment">// 所以等价于char* const，而不是const char*，有点懵？</span></span><br></pre></td></tr></table></figure><blockquote><p>先补充一下，对于<code>int *const p = &amp;a;</code>，网上通常的叫法是指针常量，而在C++ Primer第五版中叫做常量指针，虽然叫法不一样，但是大家的意思是一样的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p1 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 指向常量的变量指针 从右向左看</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *p2 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 指向常量的变量指针</span></span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> p3 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 指向变量的常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> <span class="type">const</span> *p4 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 其实这里的第二个const是多余的</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> p5 = <span class="string">&quot;abc&quot;</span>;  <span class="comment">// 指向常量的常量指针</span></span><br><span class="line"></span><br><span class="line">p1 = &amp;c;  <span class="comment">// p1的值可以变</span></span><br><span class="line"><span class="comment">// *p1 = c;  // p1指向的值不能变</span></span><br><span class="line"></span><br><span class="line">p2 = &amp;c;  <span class="comment">// 同上</span></span><br><span class="line"><span class="comment">// *p1 = c;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p3 = &amp;c;  // p3的值不可以变 p3是指针(地址) 是常量</span></span><br><span class="line">*p3 = c;  <span class="comment">// *p3的值可以变</span></span><br><span class="line"></span><br><span class="line">p4 = &amp;c;  <span class="comment">// 同p1</span></span><br><span class="line"><span class="comment">// *p4 = c;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p5 = &amp;c;  // 指针(地址)常量 不可变</span></span><br><span class="line"><span class="comment">// *p5 = c;  // 指向常量 不可变</span></span><br></pre></td></tr></table></figure><p>按照C++ Primer的说法，<strong>从右向左看</strong>似乎是能看通的，没啥大问题。不过这么想，const优先和左边结合，左边没有再和右边结合，反正const就是不允许变的意思，并且这样就能说得通上面的<code>const PCHAR</code>是<code>PCHAR const</code>，也就是<code>char* const</code>，而不是<code>const char *</code>或<code>char const *</code>了。</p><p>这里的指针换成C++的引用也是同样适用的</p><p>话又说回来，<strong>一般使用typedef去简化指针的时候似乎都会加个const</strong>，例如：<code>typedef const char* PCHAR;</code>，以使得该指针本身是常量，而不是对象</p><h1 id="8-sizeof"><a href="#8-sizeof" class="headerlink" title="8 sizeof"></a>8 sizeof</h1><p>这个其实没啥好说的，就是这是个关键字，不是个函数..比如说，写一段cpp代码，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">pushq%rbp</span><br><span class="line">...  # 先不管中间是啥</span><br><span class="line">.seh_endprologue</span><br><span class="line">call__main  # 程序入口 main函数 从汇编来看 main并不是第一阶段</span><br><span class="line">movl$4, -4(%rbp)  # 这一步我觉得是 int a = sizeof(int);</span><br><span class="line">movl$4, %ecx  # 这一步我觉得是 a = 4，fun的形参</span><br><span class="line">call_Z3funi  # 这才是调用函数fun，可见，如果是函数必然是要call的</span><br><span class="line">movl$0, %eax</span><br><span class="line">addq$48, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>从汇编代码来看，在编译阶段就已经知道<code>sizeof(int)</code>的值了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-标识符-关键字&quot;&gt;&lt;a href=&quot;#1-标识符-关键字&quot; class=&quot;headerlink&quot; title=&quot;1 标识符 关键字&quot;&gt;&lt;/a&gt;1 标识符 关键字&lt;/h1&gt;&lt;p&gt;标识符命名规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变量名只能是字母（A-Z，a-z）和数字（0-9）或者下划线（_）或者美元符号（**$**）组成&lt;/li&gt;
&lt;li&gt;第一个字母不能是数字&lt;/li&gt;
&lt;li&gt;不能使用C&amp;#x2F;C++关键字来命名变量&lt;/li&gt;
&lt;li&gt;变量名区分大小写&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; $name1, _name2, Name3;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;似乎有的版本不支持&lt;code&gt;$&lt;/code&gt;..我试了gcc8.1是可以的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C语言关键字：&lt;/p&gt;</summary>
    
    
    
    <category term="Language" scheme="https://sidneyding.cn/categories/Language/"/>
    
    <category term="C/Cpp" scheme="https://sidneyding.cn/categories/Language/C-Cpp/"/>
    
    
    <category term="Relearning C/Cpp" scheme="https://sidneyding.cn/tags/Relearning-C-Cpp/"/>
    
  </entry>
  
</feed>
