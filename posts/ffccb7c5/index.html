<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/pink/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"sidneygod.gitlab.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><link rel="canonical" href="https://sidneygod.gitlab.io/posts/ffccb7c5/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sidneygod.gitlab.io/posts/ffccb7c5/","path":"posts/ffccb7c5/","title":"[Make MyOS] Find kernel"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>[Make MyOS] Find kernel | Sidney God</title><script src="/lib/fireworks.js"></script><script>let titleTime,originTitile=document.title;document.addEventListener("visibilitychange",(function(){let i=document.querySelector('link[rel="icon"]');document.hidden?(i.setAttribute("href","/images/favicon.ico"),document.title="(つェ⊂) 我藏好了哦~"+originTitile,clearTimeout(titleTime)):(i.setAttribute("href","/images/favicon.ico"),document.title="(*´∇｀*) 被你发现啦~"+originTitile,titleTime=setTimeout((function(){document.title=originTitile}),2e3))}))</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Sidney God" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Sidney God</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Keep quiet time for time</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">18</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">23</span></a></li><li class="menu-item menu-item-resources"><a href="/resources/" rel="section"><i class="fa fa-book fa-fw"></i>Resources</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">Catalogue</li><li class="sidebar-nav-overview">Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">1 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">1.1 初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-BITS%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-text">1.2 BITS伪指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E6%89%93%E5%BC%80A20%E5%8A%9F%E8%83%BD"><span class="nav-text">1.3 打开A20功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%AF%BB%E6%89%BEkernel-bin"><span class="nav-text">1.4 寻找kernel.bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%8A%A0%E8%BD%BDkernel-bin"><span class="nav-text">1.5 加载kernel.bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%AF%95"><span class="nav-text">1.6 加载完毕</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="nav-text">1.7 获取内存信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-%E8%8E%B7%E5%8F%96SVGA%E4%BF%A1%E6%81%AF"><span class="nav-text">1.8 获取SVGA信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-%E8%BE%93%E5%87%BASVGA%E4%BF%A1%E6%81%AF"><span class="nav-text">1.9 输出SVGA信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-%E8%AE%BE%E7%BD%AESVGA%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.10 设置SVGA模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-%E5%88%87%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.11 切换模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-1-%E5%88%87%E6%8D%A2%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.11.1 切换保护模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-2-%E5%88%87%E6%8D%A2IA-32e%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.11.2 切换IA-32e模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%AE%9E%E8%B7%B5"><span class="nav-text">2 实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%AE%89%E8%A3%85bochs"><span class="nav-text">2.1 安装bochs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4"><span class="nav-text">2.2 第一条指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E6%89%A7%E8%A1%8CMBR"><span class="nav-text">2.3 执行MBR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-loader-bin"><span class="nav-text">2.4 loader.bin</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E9%98%B6%E6%AE%B5%E5%B0%8F%E7%BB%93"><span class="nav-text">3 阶段小结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Sidney Ding" src="/images/avatar.png"><p class="site-author-name" itemprop="name">Sidney Ding</p><div class="site-description" itemprop="description">You laugh at me for being different, but I laugh at you for being the same.</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/SidneyGod" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SidneyGod" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:sidneyding183@gmail.com" title="E-Mail → mailto:sidneyding183@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://google.com/" title="https:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">Google</a></li><li class="links-of-blogroll-item"><a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a></li></ul></div></div></div><div class="back-to-top animated" role="button" aria-label="Back to top"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class="sidebar-dimmer"></div></header><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/SidneyGod" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sidneygod.gitlab.io/posts/ffccb7c5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Sidney Ding"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sidney God"><meta itemprop="description" content="You laugh at me for being different, but I laugh at you for being the same."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="[Make MyOS] Find kernel | Sidney God"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">[Make MyOS] Find kernel</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-01-16 21:54:41" itemprop="dateCreated datePublished" datetime="2022-01-16T21:54:41+08:00">2022-01-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-07-04 18:50:21" itemprop="dateModified" datetime="2022-07-04T18:50:21+08:00">2022-07-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/Make-OS/" itemprop="url" rel="index"><span itemprop="name">Make OS</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Changyan: </span><a title="[Make MyOS] Find kernel" href="/posts/ffccb7c5/#SOHUCS" itemprop="discussionUrl"><span id="sourceId::e698f94222e8890b1f35fd855238c8a2" class="cy_cmt_count" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>38k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>35 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>《64位》比《32位》多了一步loader.bin似乎，《32位》的下一步直接就是导入C语言，开始搞系统了，《64位》还得再来个loader，接着干吧..这一节很重要，承上启下，甚至于内容也是</p><p>这次把书上的源码上传的gitee了: <a target="_blank" rel="noopener" href="https://gitee.com/SidneyGod/make-os/tree/master/00_一个64位操作系统的设计与实现/一个64位操作系统的设计与实现-源代码/第二部分 初级篇/第3章/程序/程序3-4">00_一个64位操作系统的设计与实现/一个64位操作系统的设计与实现-源代码/第二部分 初级篇/第3章/程序/程序3-4 · Sidney/MakeOS - 码云 - 开源中国 (gitee.com)</a></p><p>书上说，Loader的作用很大，大概包括：</p><ul><li><p>检测硬件信息</p><p>主要是通过BIOS中断服务程序来获取和检测硬件信息。BIOS上电自检的大部分信息只能在实模式下获取，内核运行在非实模式下，所以需要在进入内核前将信息检测出来，再作为参数提供给内核程序使用。比如获取ROM，RAM，设备寄存器和内存空洞等资源的物理地址范围交给内存管理单元模块维护；通过VBE功能检测出显示器支持的分辨率，显示模式，刷新率以及显存物理地址以配置合理的显示模式</p></li><li><p>处理器模式切换</p><p>BIOS运行的实模式到32位操作系统用的保护模式，再到64位操作系统用的IA-32e模式(长模式)</p></li><li><p>向内核传递数据</p><p>向内核传递两种数据，控制信息：控制内核执行流程或限制内核某些功能；硬件数据信息：检测出来的硬件数据信息，保存在固定的内存地址中，并将数据其实内存地址和数据长度作为参数传递给内核。</p></li></ul><span id="more"></span><h1 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1 源码分析"></a>1 源码分析</h1><p>然后就是分析loader源码了，六百多行吧..但是其实和boot差不多，又是一个找kernel的过程，这下没画图了，感觉还好..</p><h2 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">; 程序从物理地址0x10000(1M)处 也就是boot加载loader的地址</span><br><span class="line">org 10000h</span><br><span class="line">jmp Label_Start</span><br><span class="line">; 相当于C语言中的include 也就是FAT12文件的系统结构</span><br><span class="line">%include    "fat12.inc"</span><br><span class="line"></span><br><span class="line">BaseOfKernelFile    equ 0x00</span><br><span class="line">OffsetOfKernelFile  equ 0x100000  ; kernel真正加载的位置</span><br><span class="line"></span><br><span class="line">BaseTmpOfKernelAddr equ 0x00</span><br><span class="line">; 内核程序临时转存空间 因为内核程序读取操作是通过BIOS中断服务int 13h实现的</span><br><span class="line">; BIOS在实模式下只支持上限为1MB的物理地址空间寻址，所以需要先搬到临时转存空间</span><br><span class="line">; 再通过特殊方式搬运到1MB以上的内存空间</span><br><span class="line">OffsetTmpOfKernelFile   equ 0x7E00</span><br><span class="line"></span><br><span class="line">; 真正用途 存储物理内存结构</span><br><span class="line">MemoryStructBufferAddr  equ 0x7E00</span><br><span class="line"></span><br><span class="line">; 32位段描述表</span><br><span class="line">[SECTION gdt]</span><br><span class="line">LABEL_GDT:      dd  0,0  ; 空描述符</span><br><span class="line">LABEL_DESC_CODE32:  dd  0x0000FFFF,0x00CF9A00  ; 代码段</span><br><span class="line">LABEL_DESC_DATA32:  dd  0x0000FFFF,0x00CF9200  ; 数据段</span><br><span class="line">GdtLen  equ $ - LABEL_GDT  ; GDT长度</span><br><span class="line">GdtPtr  dw  GdtLen - 1  ; 这个就是 limit</span><br><span class="line">        dd  LABEL_GDT  ; GDT基址</span><br><span class="line">SelectorCode32  equ LABEL_DESC_CODE32 - LABEL_GDT  ; 代码段选择子</span><br><span class="line">SelectorData32  equ LABEL_DESC_DATA32 - LABEL_GDT  ; 数据段选择子</span><br><span class="line"></span><br><span class="line">; 64位段描述表</span><br><span class="line">[SECTION gdt64]</span><br><span class="line">LABEL_GDT64:        dq  0x0000000000000000</span><br><span class="line">LABEL_DESC_CODE64:  dq  0x0020980000000000</span><br><span class="line">LABEL_DESC_DATA64:  dq  0x0000920000000000</span><br><span class="line">GdtLen64    equ $ - LABEL_GDT64</span><br><span class="line">GdtPtr64    dw  GdtLen64 - 1</span><br><span class="line">            dd  LABEL_GDT64</span><br><span class="line">SelectorCode64  equ LABEL_DESC_CODE64 - LABEL_GDT64</span><br><span class="line">SelectorData64  equ LABEL_DESC_DATA64 - LABEL_GDT64</span><br></pre></td></tr></table></figure><p>这里的转存空间只是临时用，用完可以另作他用了</p><h2 id="1-2-BITS伪指令"><a href="#1-2-BITS伪指令" class="headerlink" title="1.2 BITS伪指令"></a>1.2 BITS伪指令</h2><p>此处追加定义了一个名为<code>.s16</code>的段，BITS伪指令可以通知NASM编译器生成的代码，将运行在16位或32位的处理器上，语法是<code>BITS 16</code>或<code>BITS 32</code></p><p>当NASM编译器处于16位下，使用32位数据指令需要在指令前加前缀<code>0x66</code>，使用32位地址指令时需要在指令前加入前缀<code>0x67</code>。而在32位下，使用16位指令也需要加指令前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s16]  ; 定义一个名为 .s16 的段</span><br><span class="line">[BITS 16]  ; 通知NASM编译器生成的代码将运行在16位宽的处理器上</span><br><span class="line">Label_Start:</span><br><span class="line">    mov ax, cs</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, 0x7c00</span><br><span class="line"></span><br><span class="line">;=======    display on screen : Start Loader......</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000fh</span><br><span class="line">    mov dx, 0200h       ;row 2</span><br><span class="line">    mov cx, 12</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartLoaderMessage</span><br><span class="line">    int 10h  ; 屏幕上输出"Start Loader"</span><br></pre></td></tr></table></figure><h2 id="1-3-打开A20功能"><a href="#1-3-打开A20功能" class="headerlink" title="1.3 打开A20功能"></a>1.3 打开A20功能</h2><p>这个在第0天提到了，就是A20M# pin，参考Intel manual volume 3 chapter 8.7.13.4。</p><blockquote><p><strong>A20M# pin</strong> — On an IA-32 processor, the A20M# pin is typically provided for compatibility with the Intel 286 processor. Asserting this pin causes bit 20 of the physical address to be masked (forced to zero) for all external bus memory accesses. Processors supporting Intel Hyper-Threading Technology provide one A20M# pin, which affects the operation of both logical processors within the physical processor.<br>The functionality of A20M# is used primarily by older operating systems and not used by modern operating systems. On newer Intel 64 processors, A20M# may be absent.</p></blockquote><p>意思就是历史原因，最初处理器只有20根地址线，使得处理器只能寻址1MB以内物理地址空间，但是现在的处理器已经远超20位地址线了，但是为了兼容，出现了开启或禁止1MB以上地址空间开关(也就是只用20根地址线，还是用更多)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;=======    open address A20</span><br><span class="line">    push ax</span><br><span class="line">    in  al, 92h  ; 从92端口读入A20地址线的状态</span><br><span class="line">    or  al, 00000010b  ; 将第2位置1</span><br><span class="line">    out 92h, al  ; 写回92号端口 打开A20</span><br><span class="line">    pop ax</span><br><span class="line">    cli  ; 关中断 因为保护模式下中断处理的机制不同，不关中断会出现错误</span><br><span class="line">    db  0x66  ; 声明在16位情况下使用32位宽数据指令</span><br><span class="line">    ; 加载到gdtr，因为现在段描述符表在内存中，我们必须要让CPU知道段描述符表在哪个位置</span><br><span class="line">    ; 通过使用lgdt就可以将源加载到gdtr寄存器中</span><br><span class="line">    lgdt [GdtPtr]</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or  eax, 1</span><br><span class="line">    mov cr0, eax  ; 这3句将寄存器CR0的第0位置1开启保护模式</span><br><span class="line">    mov ax, SelectorData32</span><br><span class="line">    mov fs, ax  ; 这2句 将数据段的选择子加载到FS段寄存器</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    and al, 11111110b</span><br><span class="line">    mov cr0, eax  ; 这3句 将cr0的bit0置0，也就是关掉保护模式，重新进入实模式</span><br><span class="line">    sti  ; 与cli对应，恢复外部中断</span><br><span class="line">;=======    reset floppy</span><br><span class="line">    xor ah, ah</span><br><span class="line">    xor dl, dl</span><br><span class="line">    int 13h  ; 重置软盘</span><br></pre></td></tr></table></figure><p>开启A20功能可以通过键盘(8042键盘控制器上恰好有空闲的端口引脚，输出端口P2，引脚P21)，但是键盘是低速设备，开启较慢。所以**可以使用A20快速门，使用IO端口0x92处理A20信号线(注意0x92的0位用于向机器发送复位信号，置位会导致重启)**。还可以通过BIOS中断程序INT 15h主功能号AX=2401可开启A20地址线，功能号AX=2400可禁用A20地址线，功能号AX=2403可查询A20地址线当前状态。还有一种方法是通过读0xee端口来开启A20信号线，写该端口则会禁止。</p><p>当进入保护模式后，为FS段加载新的数据段值，一旦完成数据段加载就从保护模式退出，并开启外部中断，目的是为了让FS段寄存器可以在实模式下寻址能力超过1MB(扩展到32位4GB)，可以借助FS段寄存器的特殊寻址能力将内核程序转移到1MB以上的内存地址空间中。注意，在物理平台下，当段寄存器拥有这种特殊能力之后，如果对其重新赋值就会失去特殊能力，转变成原始的实模式段寄存器</p><h2 id="1-4-寻找kernel-bin"><a href="#1-4-寻找kernel-bin" class="headerlink" title="1.4 寻找kernel.bin"></a>1.4 寻找kernel.bin</h2><p>这段内容与<code>boot.asm</code>中找<code>loader.bin</code>类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">;=======    search kernel.bin</span><br><span class="line">    mov word [SectorNo], SectorNumOfRootDirStart  ; 依旧是从第19个扇区开始</span><br><span class="line">Lable_Search_In_Root_Dir_Begin:</span><br><span class="line">    cmp word [RootDirSizeForLoop], 0  ; RootDirSizeForLoop初始值为根目录扇区数 每找完一个扇区就-- 若等于0表示没找到</span><br><span class="line">    jz  Label_No_LoaderBin  ; 找不到就跳到Label_No_LoaderBin</span><br><span class="line">    dec word [RootDirSizeForLoop]  ; RootDirSizeForLoop--</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov es, ax  ; 不能通过立即数给es赋值，需要通过ax中转一下 es=00H</span><br><span class="line">    mov bx, 8000h  ; bx=8000H</span><br><span class="line">    mov ax, [SectorNo]  ; ax=19</span><br><span class="line">    mov cl, 1  ; cl=1</span><br><span class="line">    call Func_ReadOneSector  ; 调用Func_ReadOneSector 读取一个扇区的内容到bx开始的内存地址</span><br><span class="line">    mov si, KernelFileName  ; 将文件名"kernel.bin"加载到ds:si中</span><br><span class="line">    mov di, 8000h  ; 将es:di指向扇区内容起始地址</span><br><span class="line">    cld  ; 清除EFLAGS.DF置0，这样通过LODSB从ds:si加载内容到al后，si就会递增1</span><br><span class="line">    mov dx, 10h  ; dx记录一个扇区可容纳的目录项个数。一个扇区最多有512B/32B=16=0x10个目录项</span><br><span class="line"></span><br><span class="line">Label_Search_For_LoaderBin:</span><br><span class="line">    cmp dx, 0</span><br><span class="line">    jz  Label_Goto_Next_Sector_In_Root_Dir</span><br><span class="line">    dec dx  ; 上面三句就是一个扇区所有目录项都找完了 可以去下一个扇区找了</span><br><span class="line">    mov cx, 11  ; 文件名的长度11B 包括文件名和扩展名 但不包括分隔符"."</span><br><span class="line"></span><br><span class="line">Label_Cmp_FileName:</span><br><span class="line">    cmp cx, 0  ; 文件名都比较完了 都相等 那当然就是找到了 跳到Label_FileName_Found</span><br><span class="line">    jz  Label_FileName_Found</span><br><span class="line">    dec cx</span><br><span class="line">    lodsb  ; 从ds:si读取一个字节到寄存器AL 然后si+=1(取决于EFLAGS.DF)</span><br><span class="line">    cmp al, byte [es:di]  ; 一个字符一个字符去比较</span><br><span class="line">    jz  Label_Go_On  ; 如果相等 继续</span><br><span class="line">    jmp Label_Different  ; 如果不相等</span><br><span class="line"></span><br><span class="line">Label_Go_On:</span><br><span class="line">    inc di  ; di++</span><br><span class="line">    jmp Label_Cmp_FileName</span><br><span class="line"></span><br><span class="line">Label_Different:</span><br><span class="line">    and di, 0FFE0h</span><br><span class="line">    add di, 20h</span><br><span class="line">    mov si, KernelFileName</span><br><span class="line">    jmp Label_Search_For_LoaderBin</span><br><span class="line"></span><br><span class="line">Label_Goto_Next_Sector_In_Root_Dir:</span><br><span class="line">    add word    [SectorNo], 1</span><br><span class="line">    jmp Lable_Search_In_Root_Dir_Begin</span><br><span class="line">    </span><br><span class="line">;=======    display on screen : ERROR:No KERNEL Found</span><br><span class="line">Label_No_LoaderBin:  ; 没找到kernel.bin就会跳到这，结束</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0300h       ; row 3</span><br><span class="line">    mov cx, 21</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, NoLoaderMessage  ; 屏幕上输出"ERROR:No KERNEL Found"</span><br><span class="line">    int 10h</span><br><span class="line">    jmp $</span><br></pre></td></tr></table></figure><h2 id="1-5-加载kernel-bin"><a href="#1-5-加载kernel-bin" class="headerlink" title="1.5 加载kernel.bin"></a>1.5 加载kernel.bin</h2><p>找到<code>kernel.bin</code>，就将其读到内存中，与<code>boot.asm</code>找到<code>loader.bin</code>后的操作差不多，只是这里更加曲折一点，是先读取到0x7e00~0x7fff这段中，再通过FS段寄存器挪到0x100000之上的物理内存空间。但是这里段寄存器被重新赋值了，导致在实际物理平台上会出问题，书上说第7章再解决这个问题..</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">;=======    found kernel.bin name in root director struct</span><br><span class="line">Label_FileName_Found:  ; 找到了kernel.bin就到这..</span><br><span class="line">    mov ax, RootDirSectors</span><br><span class="line">    and di, 0FFE0h</span><br><span class="line">    add di, 01Ah</span><br><span class="line">    mov cx, word [es:di]</span><br><span class="line">    push cx</span><br><span class="line">    add cx, ax</span><br><span class="line">    add cx, SectorBalance  ; 得到实际起始扇区号</span><br><span class="line">    mov eax, BaseTmpOfKernelAddr ; eax=00H</span><br><span class="line">    mov es, eax</span><br><span class="line">    mov bx, OffsetTmpOfKernelFile   ; bx=7E00H</span><br><span class="line">    mov ax, cx  ; 将存储文件实际扇区号放到ax中</span><br><span class="line"></span><br><span class="line">Label_Go_On_Loading_File:</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    mov ah, 0Eh</span><br><span class="line">    mov al, '.'</span><br><span class="line">    mov bl, 0Fh</span><br><span class="line">    int 10h  ; 每读一个扇区就在屏幕上打印一个 .</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    mov cl, 1</span><br><span class="line">    call Func_ReadOneSector  ; 将一个扇区的内容读到0x7E00~0x7FF这段内存中</span><br><span class="line">    pop ax</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">    push cx</span><br><span class="line">    push eax</span><br><span class="line">    push fs</span><br><span class="line">    push edi</span><br><span class="line">    push ds</span><br><span class="line">    push esi</span><br><span class="line"></span><br><span class="line">    mov cx, 200h  ; 200h = 512</span><br><span class="line">    mov ax, BaseOfKernelFile  ; 00H</span><br><span class="line">    mov fs, ax</span><br><span class="line">    ; 目的地址 fs:edi = 0x00:0x100000，此处使用了FS段寄存器的超能力，它可以寻址到4G</span><br><span class="line">    mov edi, dword [OffsetOfKernelFileCount]  ; OffsetOfKernelFile 0x100000</span><br><span class="line">    mov ax, BaseTmpOfKernelAddr  ; 00H</span><br><span class="line">    mov ds, ax</span><br><span class="line">    ; 源地址 ds:esi = 0x00:0x7e00</span><br><span class="line">    mov esi, OffsetTmpOfKernelFile  ; 7E00H</span><br><span class="line"></span><br><span class="line">Label_Mov_Kernel:</span><br><span class="line">    ; 一个字节一个字节将0x7e00之后的512字节东西挪到0x100000</span><br><span class="line">    mov al, byte [ds:esi]</span><br><span class="line">    mov byte [fs:edi], al</span><br><span class="line">    inc esi</span><br><span class="line">    inc edi</span><br><span class="line">    loop Label_Mov_Kernel  ; 执行loop指令前，先要将cx--，若cx不为0则跳到Label_Mov_Kernel</span><br><span class="line"></span><br><span class="line">    mov eax, 0x1000  ; loader.bin起始于内存地址0x1000:0x00</span><br><span class="line">    mov ds, eax</span><br><span class="line">    ; 每移动512字节内容后，保存新的内存地址到内存OffsetOfKernelFileCount字段处</span><br><span class="line">    mov dword [OffsetOfKernelFileCount],  edi</span><br><span class="line"></span><br><span class="line">    pop esi</span><br><span class="line">    pop ds</span><br><span class="line">    pop edi</span><br><span class="line">    pop fs</span><br><span class="line">    pop eax</span><br><span class="line">    pop cx</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">    call    Func_GetFATEntry</span><br><span class="line">    cmp ax, 0FFFh  ; 直到读到文件尾</span><br><span class="line">    jz  Label_File_Loaded  ; 文件已加载..</span><br><span class="line">    push ax</span><br><span class="line">    mov dx, RootDirSectors</span><br><span class="line">    add ax, dx</span><br><span class="line">    add ax, SectorBalance</span><br><span class="line">    jmp Label_Go_On_Loading_File  ; 继续下一个扇区</span><br></pre></td></tr></table></figure><h2 id="1-6-加载完毕"><a href="#1-6-加载完毕" class="headerlink" title="1.6 加载完毕"></a>1.6 加载完毕</h2><p>加载完毕后会在屏幕上打印一个字符<code>G</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Label_File_Loaded:</span><br><span class="line">    mov ax, 0B800h</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ah, 0Fh             ; 0000: 黑底    1111: 白字</span><br><span class="line">    ; 将’G’这个字符放到了内存中gs:((80 * 0 + 39) * 2)的这个地方，这个gs在这里是0B800h以这里为起点，向后偏移一段区域的内存专门用于存储在屏幕上显示的字，每个字占位两个字节，每行最多显示80个字符，所以就有上面的公式：((80 * 0 + 39) * 2)这表示第0行的39列显示该字符</span><br><span class="line">    mov al, 'G'</span><br><span class="line">    mov [gs:((80 * 0 + 39) * 2)], ax    ; 屏幕第 0 行, 第 39 列。</span><br><span class="line"></span><br><span class="line">; 当Loader引导加载程序完成内核程序的加载工作后，软盘驱动器将不再使用</span><br><span class="line">KillMotor:  ; 关闭全部软盘驱动器</span><br><span class="line">    push dx</span><br><span class="line">    mov dx, 03F2h</span><br><span class="line">    mov al, 0</span><br><span class="line">    out dx, al</span><br><span class="line">    pop dx</span><br></pre></td></tr></table></figure><p>这段代码首先将GS段寄存器的基地址设置在0B800H地址处；并将AH寄存器赋值为0FH，表示黑底白字；将AL寄存器赋值为字母’G’，要打印的字符；然后将AX寄存器的值填充到0B800H向后偏移<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.566ex" xmlns="http://www.w3.org/2000/svg" width="16.845ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7445.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1611.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(2611.4,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(3333.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4333.9,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(5333.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5945.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(6945.3,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container>处，每个字符占2个字节，每行最多显示80个字符，所以就是0行39列显示’G’。<strong>从内存地址0B800H开始，是一段专门用于显示字符的内存空间，其中每个字符占用两个字节的内存空间，低字节保存显示的字符，高字节保存字符的颜色属性</strong>。该方法相比于INT 10H中断相比更符合操作显卡内存的习惯，后面会通过像素内存在屏幕上作画或播放视频。</p><p>I/O端口3F2H控制着软盘驱动器不少硬件功能</p><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>7</td><td>MOT_EN3</td><td>控制软驱D马达，1：启动；0：关闭</td></tr><tr><td>6</td><td>MOT_EN2</td><td>控制软驱C</td></tr><tr><td>5</td><td>MOT_EN1</td><td>控制软驱B</td></tr><tr><td>4</td><td>MOT_EN0</td><td>控制软驱A</td></tr><tr><td>3</td><td>DMA_INT</td><td>1：允许DMA和中断请求；0：禁止DMA和中断请求</td></tr><tr><td>2</td><td>RESET</td><td>1：允许软盘控制器发送控制信息；0：复位软盘驱动器</td></tr><tr><td>1</td><td>DRV_SEL1</td><td>00~11用于选择软盘驱动器A~D</td></tr><tr><td>0</td><td>DRV_SEL0</td><td>同上</td></tr></tbody></table><h2 id="1-7-获取内存信息"><a href="#1-7-获取内存信息" class="headerlink" title="1.7 获取内存信息"></a>1.7 获取内存信息</h2><p>当内核程序不再借助临时转存空间后，这块临时转存空间将用于保存物理内存地址空间信息</p><p>物理地址空间信息由一个结构体数组构成，计算机平台地址划分情况都能从这个结构体数组成反映出来，它记录的地址空间类型包括可用物理内存地址空间、设备寄存器地址空间、内存空洞等。系统会在初始化内存管理单元时解析该结构数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">;=======    get memory address size type</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0400h       ;row 4</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetMemStructMessage</span><br><span class="line">    int 10h  ; 打印 "Start Get Memory Struct."</span><br><span class="line"></span><br><span class="line">    ; 当内核程序不再借助临时转存空间后，这块临时转存空间 0x7E00~0x7FFF将用于保存物理地址空间信息</span><br><span class="line">    mov ebx, 0  ; 指向内存区域，第一次调用时ebx=0，被称为continuation value</span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov di, MemoryStructBufferAddr  ; 设置填充地址es:di=0x00:0x7e00</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_Struct:</span><br><span class="line">    mov eax, 0x0E820  ; 功能号</span><br><span class="line">    mov ecx, 20       ; 固定读取20字节</span><br><span class="line">    mov edx, 0x534D4150  ; 固定值SMAP</span><br><span class="line">    int 15h  ; 使用INT 15H来获取物理地址空间信息</span><br><span class="line">    jc  Label_Get_Mem_Fail  ; 没有进位表示读取成功</span><br><span class="line"></span><br><span class="line">    add di, 20  ; 推进填充地址</span><br><span class="line">    cmp ebx, 0  ; 输出时，ebx表示下一个内存区域，当ebx=0 &amp;&amp; CF=0时，表示当前是内存最后一个区域</span><br><span class="line">    jne Label_Get_Mem_Struct  ; 循环读取</span><br><span class="line">    jmp Label_Get_Mem_OK</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_Fail:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0500h       ;row 5</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetMemStructErrMessage</span><br><span class="line">    int 10h  ; 输出 Get Memory Struct ERROR</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_OK:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0600h       ;row 6</span><br><span class="line">    mov cx, 29</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetMemStructOKMessage</span><br><span class="line">    int 10h ; 输出 Get Memory Struct SUCCESSFUL!</span><br></pre></td></tr></table></figure><p>INT 15H：每执行一次这个指令将会将一个描述内存区域的数据结构保存到<code>ES:DI</code>，然后返回一个ebx，用于确定下一个能够探测的内存区域，当ebx=0时，表示当前已经时最后一个内存区域了。那么ebx的初始值呢，就是设置成ebx=0。其中可能遇到检查发生错误的情况，这个指令就会直接将CF设置为1。</p><p>输入时各个寄存器作用：</p><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td>eax</td><td>功能码，当输入e820h时能够探测内存</td></tr><tr><td>ebx</td><td>主要用于指向内存区域，第一次调用时ebx=0，被称为continuation value</td></tr><tr><td>es:di</td><td>用于指令执行后，在指向的内存写入描述内存区域的数据结构ARDS(Address Range Descriptor Structure)</td></tr><tr><td>ecx</td><td>用于限制指令填充的ARDS的大小，实际上大多数情况这个是无效的，无论ecx设置为多少，BIOS始终会填充20字节的ARDS</td></tr><tr><td>edx</td><td>0534D4150h，表示4个ASCII字符(‘SMAP’)，只是个签名，输入时在edx，输出时将会在eax中</td></tr></tbody></table><p>输出时各个寄存器结果:</p><table><thead><tr><th>寄存器</th><th>结果</th></tr></thead><tbody><tr><td>CF</td><td>当没有发生错误时，CF=0，否则CF=1</td></tr><tr><td>eax</td><td>0534D4150h</td></tr><tr><td>ebx</td><td>指向下一个内存区域，而不是调用之前的内存区域，当ebx=0且CF=0时，表示当前是最后一个内存区域。</td></tr><tr><td>es:di</td><td>和调用之前一样，如果要保存多个ARDS，需要手动修改es:di</td></tr><tr><td>ecx</td><td>返回写入的ARDS的大小</td></tr></tbody></table><p>看一下Linux对E820H的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bionic/libc/kernel/uapi/asm-x86/asm/e820.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820entry</span> {</span></span><br><span class="line">    __u64 addr; <span class="comment">/* start of memory segment */</span></span><br><span class="line">    __u64 size; <span class="comment">/* size of memory segment */</span></span><br><span class="line">    __u32 type; <span class="comment">/* type of memory segment 能被OS使用的；保留的(不能被OS使用的)*/</span></span><br><span class="line">} __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> {</span></span><br><span class="line">    __u32 nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820entry</span> <span class="title">map</span>[<span class="title">E820_X_MAX</span>];</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>BIOS查找出一个一个的内存布局entry，并放入到一个保存地址范围描述符结构的缓冲区中</p><h2 id="1-8-获取SVGA信息"><a href="#1-8-获取SVGA信息" class="headerlink" title="1.8 获取SVGA信息"></a>1.8 获取SVGA信息</h2><p>这一段并不重要..</p><p>获取SVGA(Super Video Graphics Array) VBE相关信息，这玩意不百度不知道，一百度，tmd又是一门难搞的技术..参考《最新VESA SVGA图形图像编程秘技》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">;=======    get SVGA information</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0800h       ;row 8</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetSVGAVBEInfoMessage</span><br><span class="line">    int 10h</span><br><span class="line"></span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov di, 0x8000  ; 指向存放VbeInfoBlock结构体的缓冲区指针</span><br><span class="line">    mov ax, 4F00h  ; 返回VBE控制器信息</span><br><span class="line">    int 10h</span><br><span class="line">    cmp ax, 004Fh  ; VBE返回状态</span><br><span class="line">    jz  .KO</span><br><span class="line"></span><br><span class="line">;=======    Fail</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0900h       ;row 9</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAVBEInfoErrMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA VBE Info ERROR"</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">.KO:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0A00h       ;row 10</span><br><span class="line">    mov cx, 29</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAVBEInfoOKMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA VBE Info SUCCESSFUL!"</span><br></pre></td></tr></table></figure><p>VBE功能调用的共同点：</p><p>AH必须等于4F，表示是VBE标准；</p><p>AL是VBE功能号，其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.312ex" xmlns="http://www.w3.org/2000/svg" width="15.26ex" height="1.932ex" role="img" focusable="false" viewBox="0 -716 6745.1 854"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1833.6,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(2583.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(3542.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(4598.1,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mi" transform="translate(5098.1,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(5857.1,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>；</p><p>BL等于子功能号，可以没有子功能；</p><p>调用INT 10H；</p><p>返回值。</p><p>VBE功能调用返回值一般均在AX中：</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="11.089ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4901.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1708.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2764.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(3264.6,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(4013.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：支持该功能；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.486ex" xmlns="http://www.w3.org/2000/svg" width="11.089ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 4901.6 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1708.8,0)"><path data-c="2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"></path></g><g data-mml-node="mn" transform="translate(2764.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(3264.6,0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(4013.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：不支持该功能；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="10.994ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4859.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1915.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2971.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(3971.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：功能调用成功；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="10.994ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4859.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1915.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2971.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(3971.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：功能调用失败；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="10.994ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4859.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1915.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2971.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(3971.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：当前硬件配置不支持该功能；</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.186ex" xmlns="http://www.w3.org/2000/svg" width="10.994ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 4859.6 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(1915.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2971.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(3971.6,0)"><path data-c="1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container>：当前显示模式不支持该功能</p><p>这里使用的就是INT 10H AH=00H：返回VBE信息</p><p>输入：</p><p>AX=4F00H</p><p>ES:DI=指向VBE信息块的指针</p><p>输出：</p><p>AX=VBE返回值</p><p>其中VbeInfoBlock的定义参考Linux，<strong>VBE 1.x版本的信息块大小为256B；VBE 2.0+及后续版本VbeInfoBlock大小为512B</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/drivers/gpu/drm/radeon/atombios.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_INFO_BLOCK</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VBE_VERSION_UNION           UpdatableVBE_Info;</span><br><span class="line">    UCHAR                       Reserved[<span class="number">222</span>];  <span class="comment">// 保留</span></span><br><span class="line">    UCHAR                       OemData[<span class="number">256</span>];   <span class="comment">// VESA2.0版以上定义</span></span><br><span class="line">} VBE_INFO_BLOCK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">VBE_VERSION_UNION</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VBE_2_0_INFO_BLOCK_UPDATABLE    VBE_2_0_InfoBlock;</span><br><span class="line">    VBE_1_2_INFO_BLOCK_UPDATABLE    VBE_1_2_InfoBlock;</span><br><span class="line">} VBE_VERSION_UNION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_2_0_INFO_BLOCK_UPDATABLE</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VBE_1_2_INFO_BLOCK_UPDATABLE CommonBlock;</span><br><span class="line">    USHORT                       OemSoftRev;  <span class="comment">// VBE软件的OEM修订版本号，BCD码</span></span><br><span class="line">    PTR_32_BIT_UNION             OemVendorNamePtr;  <span class="comment">// 指向显示卡制造厂商的字符串指针</span></span><br><span class="line">    PTR_32_BIT_UNION             OemProductNamePtr;  <span class="comment">// 指向显示卡制造商的字符串的指针</span></span><br><span class="line">    PTR_32_BIT_UNION   OemProductRevPtr;  <span class="comment">// 指向显示卡修订版本号或唱片等级的字符串的指针</span></span><br><span class="line">} VBE_2_0_INFO_BLOCK_UPDATABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_1_2_INFO_BLOCK_UPDATABLE</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    UCHAR               VbeSignature[<span class="number">4</span>];  <span class="comment">// 字符串"VESA"  offset:0</span></span><br><span class="line">    USHORT              VbeVersion;       <span class="comment">// VBE版本号，BCD码  offset:4</span></span><br><span class="line">    PTR_32_BIT_UNION    OemStringPtr;     <span class="comment">// 指向OEM厂商的标志串的指针  offset:6</span></span><br><span class="line">    UCHAR               Capabilities[<span class="number">4</span>];  <span class="comment">// 显示卡特性  offset:10</span></span><br><span class="line">    PTR_32_BIT_UNION    VideoModePtr;     <span class="comment">// 指向所支持显示模式列表的指针  offset:14</span></span><br><span class="line">    USHORT              TotalMemory;      <span class="comment">// 显示内存大小，单位为64KB</span></span><br><span class="line">} VBE_1_2_INFO_BLOCK_UPDATABLE;</span><br></pre></td></tr></table></figure><h2 id="1-9-输出SVGA信息"><a href="#1-9-输出SVGA信息" class="headerlink" title="1.9 输出SVGA信息"></a>1.9 输出SVGA信息</h2><p>上面只是获取到了VBE信息，完了还得打印出来了呢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">;=======    Get SVGA Mode Info</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0C00h       ;row 12</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetSVGAModeInfoMessage</span><br><span class="line">    int 10h  ; 输出 "Start Get SVGA Mode Info"</span><br><span class="line"></span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov si, 0x800e  ; es:si=0x0000:0x800e</span><br><span class="line">    mov esi, dword [es:si]  ; 取出指针存入esi</span><br><span class="line">    mov edi, 0x8200  ; es:di=0x0000:0x8200</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_Get:  ; 循环获取所有的svga_mode_info</span><br><span class="line">    mov cx, word [es:esi]</span><br><span class="line">;=======    display SVGA mode information</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov al, ch</span><br><span class="line">    call Label_DispAL  ; 显示16进制数值在屏幕上 后面再看</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov al, cl</span><br><span class="line">    call Label_DispAL</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    cmp cx, 0FFFFh  ; 如果是最后要给word则跳到Finish</span><br><span class="line">    jz  Label_SVGA_Mode_Info_Finish</span><br><span class="line"></span><br><span class="line">    mov ax, 4F01h</span><br><span class="line">    int 10h  ; 4F01H显示特定模式信息，获取成功则向ES:DI填充256字节</span><br><span class="line"></span><br><span class="line">    cmp ax, 004Fh</span><br><span class="line">    jnz Label_SVGA_Mode_Info_FAIL   </span><br><span class="line">    add esi, 2  ; 获取list中下一个word</span><br><span class="line">    add edi, 0x100  ; 刚填充了256字节，继续前进256字节</span><br><span class="line">    jmp Label_SVGA_Mode_Info_Get</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_FAIL:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0D00h       ;row 13</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAModeInfoErrMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA Mode Info ERROR"</span><br><span class="line"></span><br><span class="line">Label_SET_SVGA_Mode_VESA_VBE_FAIL:</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_Finish:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0E00h       ;row 14</span><br><span class="line">    mov cx, 30</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAModeInfoOKMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA Mode Info SUCCESSFUL!"</span><br></pre></td></tr></table></figure><p><strong>问题1：为什么是0x800e？为什么是dword？为什么从0x8200开始？</strong></p><p>因为VideoModePtr在VBE_INFO_BLOCK的偏移就是14，就是e；VideoModePtr大小是4B；因为VBE 2.0+版本之后的VbeInfoBlock大小是512B，所以还是往后挪256B稳妥点</p><p><strong>问题2：INT 10H AX=4F10H</strong></p><p>这个功能号的作用是返回VBE特定模式信息</p><p>输入：</p><p>AX=4F01H</p><p>CX=模式号</p><p>ES:DI=指向VBE特定模式信息块的指针</p><p>输出：</p><p>AX=VBE返回值</p><p>其中特定模式信息块数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/drivers/gpu/drm/radeon/atombios.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VESA_MODE_INFO_BLOCK</span></span></span><br><span class="line"><span class="class">{</span>  <span class="comment">// 共256B</span></span><br><span class="line"><span class="comment">// Mandatory information for all VBE revisions</span></span><br><span class="line">    USHORT ModeAttributes;  <span class="comment">// dw  ?   ; mode attributes</span></span><br><span class="line">    UCHAR  WinAAttributes;  <span class="comment">// db  ?   ; window A attributes</span></span><br><span class="line">    UCHAR  WinBAttributes;  <span class="comment">// db  ?   ; window B attributes</span></span><br><span class="line">    USHORT WinGranularity;  <span class="comment">// dw  ?   ; window granularity</span></span><br><span class="line">    USHORT WinSize;         <span class="comment">// dw  ?   ; window size</span></span><br><span class="line">    USHORT WinASegment;     <span class="comment">// dw  ?   ; window A start segment</span></span><br><span class="line">    USHORT WinBSegment;     <span class="comment">// dw  ?   ; window B start segment</span></span><br><span class="line">    ULONG  WinFuncPtr;      <span class="comment">// dd  ?   ; real mode pointer to window function</span></span><br><span class="line">    USHORT BytesPerScanLine;<span class="comment">// dw  ?   ; bytes per scan line</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 1.2 and above</span></span><br><span class="line">    USHORT XResolution;      <span class="comment">// dw  ?   ; horizontal resolution in pixels or characters</span></span><br><span class="line">    USHORT YResolution;      <span class="comment">// dw  ?   ; vertical resolution in pixels or characters</span></span><br><span class="line">    UCHAR  XCharSize;        <span class="comment">// db  ?   ; character cell width in pixels</span></span><br><span class="line">    UCHAR  YCharSize;        <span class="comment">// db  ?   ; character cell height in pixels</span></span><br><span class="line">    UCHAR  NumberOfPlanes;   <span class="comment">// db  ?   ; number of memory planes</span></span><br><span class="line">    UCHAR  BitsPerPixel;     <span class="comment">// db  ?   ; bits per pixel</span></span><br><span class="line">    UCHAR  NumberOfBanks;    <span class="comment">// db  ?   ; number of banks</span></span><br><span class="line">    UCHAR  MemoryModel;      <span class="comment">// db  ?   ; memory model type</span></span><br><span class="line">    UCHAR  BankSize;         <span class="comment">// db  ?   ; bank size in KB</span></span><br><span class="line">    UCHAR  NumberOfImagePages;<span class="comment">// db    ?   ; number of images</span></span><br><span class="line">    UCHAR  ReservedForPageFunction;<span class="comment">//db  1   ; reserved for page function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Direct Color fields(required for direct/6 and YUV/7 memory models)</span></span><br><span class="line">    UCHAR  RedMaskSize; <span class="comment">// db ? ; size of direct color red mask in bits</span></span><br><span class="line">    UCHAR  RedFieldPosition; <span class="comment">// db ? ; bit position of lsb of red mask</span></span><br><span class="line">    UCHAR  GreenMaskSize; <span class="comment">// db ? ; size of direct color green mask in bits</span></span><br><span class="line">    UCHAR  GreenFieldPosition; <span class="comment">// db  ? ; bit position of lsb of green mask</span></span><br><span class="line">    UCHAR  BlueMaskSize; <span class="comment">// db  ? ; size of direct color blue mask in bits</span></span><br><span class="line">    UCHAR  BlueFieldPosition; <span class="comment">// db  ? ; bit position of lsb of blue mask</span></span><br><span class="line">    UCHAR  RsvdMaskSize; <span class="comment">// db ? ; size of direct color reserved mask in bits</span></span><br><span class="line">    UCHAR  RsvdFieldPosition;  <span class="comment">// db ? ; bit position of lsb of reserved mask</span></span><br><span class="line">    UCHAR  DirectColorModeInfo;  <span class="comment">// db ? ; direct color mode attributes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 2.0 and above</span></span><br><span class="line">    ULONG  PhysBasePtr; <span class="comment">// dd ? ; physical address for flat memory frame buffer</span></span><br><span class="line">    ULONG  Reserved_1; <span class="comment">// dd 0 ; reserved - always set to 0</span></span><br><span class="line">    USHORT Reserved_2; <span class="comment">// dw 0 ; reserved - always set to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 3.0 and above</span></span><br><span class="line">    USHORT LinBytesPerScanLine;  <span class="comment">// dw ? ; bytes per scan line for linear modes</span></span><br><span class="line">    UCHAR  BnkNumberOfImagePages;<span class="comment">// db ? ; number of images for banked modes</span></span><br><span class="line">    UCHAR  LinNumberOfImagPages; <span class="comment">// db ? ; number of images for linear modes</span></span><br><span class="line">    UCHAR  LinRedMaskSize; <span class="comment">// db ? ; size of direct color red mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRedFieldPosition;  <span class="comment">// db ? ; bit position of lsb of red mask(linear modes)</span></span><br><span class="line">    UCHAR  LinGreenMaskSize;  <span class="comment">// db ? ; size of direct color green mask(linear modes)</span></span><br><span class="line">    UCHAR  LinGreenFieldPosition;<span class="comment">// db ? ; bit position of lsb of green mask(linear modes)</span></span><br><span class="line">    UCHAR  LinBlueMaskSize; <span class="comment">// db ? ; size of direct color blue mask(linear modes)</span></span><br><span class="line">    UCHAR  LinBlueFieldPosition; <span class="comment">// db ? ; bit position of lsb of blue mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRsvdMaskSize;  <span class="comment">// db ? ; size of direct color reserved mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRsvdFieldPosition; <span class="comment">// db  ?   ; bit position of lsb of reserved mask(linear modes)</span></span><br><span class="line">    ULONG  MaxPixelClock;   <span class="comment">// dd  ?   ; maximum pixel clock(in Hz) for graphics mode</span></span><br><span class="line">    UCHAR  Reserved;        <span class="comment">// db  190 dup (0)</span></span><br><span class="line">} VESA_MODE_INFO_BLOCK;</span><br></pre></td></tr></table></figure><p>至于每个属性啥意思，这就不列了，《最新VESA SVGA图形图像编程秘技》这本书上有..当然了《64位》这本书第7章也有说</p><p><strong>问题3：Label_DispAL作用</strong></p><p>这是放在后面的一段辅助函数，作用是将16进制数值显示在屏幕上，原理和Label_File_Loaded一样</p><p>输入：</p><p>AL=要显示的十六进制数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;=======    display num in al</span><br><span class="line">Label_DispAL:</span><br><span class="line">    push    ecx</span><br><span class="line">    push    edx</span><br><span class="line">    push    edi</span><br><span class="line"></span><br><span class="line">    mov edi, [DisplayPosition]  ; 字符的屏幕偏移量 初始值是0</span><br><span class="line">    mov ah, 0Fh  ; 字符属性 黑底白字</span><br><span class="line">    mov dl, al  ; 保存字符值到dl</span><br><span class="line">    shr al, 4  ; 右移4位 取字符高位</span><br><span class="line">    mov ecx, 2  ; 计算高位一次 计算低位一次 一共要loop两次</span><br><span class="line">.begin:</span><br><span class="line">    and al, 0Fh</span><br><span class="line">    cmp al, 9  ; 这里实际上比较的是高4位 右移了</span><br><span class="line">    ja  .1  ; 如果大于9直接跳到 .1</span><br><span class="line">    add al, '0'  ; 如果小于或等于9 与字符'0'相加</span><br><span class="line">    jmp .2</span><br><span class="line">.1:</span><br><span class="line">    sub al, 0Ah  ; 先减去 0AH</span><br><span class="line">    add al, 'A'  ; 再加上 字符'A'</span><br><span class="line">.2:</span><br><span class="line">    mov [gs:edi], ax  ; 将AX保存到gs为基址，DisplayPosition为偏移的显示字符内存空间中</span><br><span class="line">    add edi, 2  ; 下一个字符</span><br><span class="line"></span><br><span class="line">    mov al, dl</span><br><span class="line">    loop .begin</span><br><span class="line">    mov [DisplayPosition], edi  ; 保存字符偏移量到内存</span><br><span class="line"></span><br><span class="line">    pop edi</span><br><span class="line">    pop edx</span><br><span class="line">    pop ecx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="1-10-设置SVGA模式"><a href="#1-10-设置SVGA模式" class="headerlink" title="1.10 设置SVGA模式"></a>1.10 设置SVGA模式</h2><p>根据查询的信息配置芯片显示模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;=======    set the SVGA mode(VESA VBE)</span><br><span class="line">    mov ax, 4F02h</span><br><span class="line">    mov bx, 4180h ; mode: 0x180 or 0x143</span><br><span class="line">    int 10h</span><br><span class="line">    cmp ax, 004Fh</span><br><span class="line">    jnz Label_SET_SVGA_Mode_VESA_VBE_FAIL</span><br></pre></td></tr></table></figure><p>INT 10H AX=4F02H，设置VESA VBE模式</p><p>输入：</p><p>AX=4F02H</p><p>BX=模式号</p><p>输出：</p><p>AX=VBE返回值</p><p>其中模式号说明如下：</p><p>VESA 2.0版本以上增加了BX中D14、D15两个位定义</p><p>D0~D8：9位模式号</p><p>D9~D13：保留，必须为0</p><p>D14：置0，使用普通窗口页面缓存模式，使用VBE功能05H切换显示页面；置1，使用大的线性缓存区，其地址可从VBE功能01H的返回信息ModeInfo中获得</p><p>D15：置0，清除显示缓存；置1，不清除显示缓存</p><p>讲道理这个模式号，能百度到，但是资料好像不多..书上提供的两个0x180和0x143</p><table><thead><tr><th>模式</th><th>列</th><th>行</th><th>物理地址</th><th>像素点位宽</th></tr></thead><tbody><tr><td>0x180</td><td>1440</td><td>900</td><td>E0000000H</td><td>32 bit</td></tr><tr><td>0x143</td><td>800</td><td>600</td><td>E0000000H</td><td>32 bit</td></tr></tbody></table><p>这里D15 D14是01b</p><h2 id="1-11-切换模式"><a href="#1-11-切换模式" class="headerlink" title="1.11 切换模式"></a>1.11 切换模式</h2><h3 id="1-11-1-切换保护模式"><a href="#1-11-1-切换保护模式" class="headerlink" title="1.11.1 切换保护模式"></a>1.11.1 切换保护模式</h3><p>检测完硬件信息后，就该脱离实模式到保护模式了</p><p>在<strong>实模式</strong>下，程序可以操作任何地址空间，而且无法限制程序的执行权限。这种模式给设置硬件功能带来许多方便，但是给程序执行的安全性和稳定性带来了灾难性的后果。并且实模式寻址能力有限，所以需要切换到保护模式</p><p>在<strong>保护模式</strong>下，处理器按照程序执行级别分为0、1、2、3四个等级(由高到低)，目前Linux只使用了两个0内核级，3应用程序级。保护模式还引入了分页功能，有了分页，段机制就显得多余，然后又有了IA-32e模式(长模式)</p><p><strong>IA-32e模式</strong>简化段级保护措施的复杂性，升级内存寻址能力，同时还扩展页管理单元的组织结构和页面大小，推出新的系统调用方式和高级可编程中断控制器</p><p>在切换保护模式前，必须创建一段可在保护模式下执行的代码及必要的系统数据结构(IDT/GDT/LDT描述表可一个，任务状态段TSS结构，至少一个页目录和页表，至少一个异常/中断处理模块)，初始化GDTR寄存器、IDTR寄存器、控制寄存器CR1~4、MTTRs内存范围类型寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;=======    init IDT GDT goto protect mode </span><br><span class="line">    cli  ; 关中断</span><br><span class="line">    db  0x66</span><br><span class="line">    lgdt [GdtPtr]  ; 将GDT加载到GDTR中，这里的GDT就是初始化里面的</span><br><span class="line"></span><br><span class="line">    ; 已使用cli禁止外部中断，所以在切换到保护模式过程中不会产生中断和异常，不必完整初始化IDT，</span><br><span class="line">    ; 只要有相应的结构体即可。能够保证处理器在模式切换过程中不会产生一场，即使没有IDT也可以</span><br><span class="line">;   db  0x66</span><br><span class="line">;   lidt [IDT_POINTER]</span><br><span class="line"></span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or  eax, 1    ; CR0.PE，也可以同时开启CR0.PG，开启分页</span><br><span class="line">    mov cr0, eax  ; 执行后，就已经进入到保护模式</span><br><span class="line"></span><br><span class="line">    ; jmp 代码段选择子:偏移 = jmp 0x08:xxxx，目的是改变处理器的执行流水线，</span><br><span class="line">    ; 进而使处理器加载执行保护模式的代码段</span><br><span class="line">    jmp dword SelectorCode32:GO_TO_TMP_Protect</span><br></pre></td></tr></table></figure><p>详细解释一下，GDT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 32位段描述表</span><br><span class="line">[SECTION gdt]</span><br><span class="line">LABEL_GDT:      dd  0,0  ; 空描述符，offset +0H</span><br><span class="line">LABEL_DESC_CODE32:  dd  0x0000FFFF,0x00CF9A00  ; 代码段，offset +8H</span><br><span class="line">LABEL_DESC_DATA32:  dd  0x0000FFFF,0x00CF9200  ; 数据段，offset +10H</span><br><span class="line">GdtLen  equ $ - LABEL_GDT  ; GDT长度</span><br><span class="line">GdtPtr  dw  GdtLen - 1  ; 这个就是 limit</span><br><span class="line">        dd  LABEL_GDT  ; GDT基址</span><br><span class="line">SelectorCode32  equ LABEL_DESC_CODE32 - LABEL_GDT  ; 代码段选择子</span><br><span class="line">SelectorData32  equ LABEL_DESC_DATA32 - LABEL_GDT  ; 数据段选择子</span><br></pre></td></tr></table></figure><p>首先第一项LABEL_GDT必须是空描述符，dd两个，也就是占8字节</p><p>然后来看CODE32和DATA32，根据之前学习的段描述</p><p><img data-src="/assets/05_Make-MyOS-Find-kernel/202112072244745.png" alt="202112072244745"></p><p>其中CODE32：</p><p>0x00CF9A00，0000 0000 1100 1111 1001 1010 0000 0000</p><p>0x0000FFFF，0000 0000 0000 0000 1111 1111 1111 1111</p><p>得出Base=00000000H，Seg Limit=FFFFFH，G=1，D/B=1，P=1，S=1，Type=1010b</p><p>所以基址是0x00000000处；由于G=1，所以段限是0xffffffff，也就是4GB寻址能力；S=1且Type=1010b，表示代码段，可执行可读</p><p>其中DATA32：</p><p>0x00CF9200，0000 0000 1100 1111 1001 0010 0000 0000</p><p>0x0000FFFF，0000 0000 0000 0000 1111 1111 1111 1111</p><p>得出Base=00000000H，Seg Limit=FFFFFH，G=1，D/B=1，P=1，S=1，Type=0010b</p><p>所以基址是0x00000000处；由于G=1，所以段限是0xffffffff，也就是4GB寻址能力；S=1且Type=0010b，表示数据段，可读可写</p><p>GdtLen，每个表项占8字节，三个也就是24B</p><p>GdtPtr，前面是表界限，后面是表基地址</p><p>SelectorCode32，代码段选择子，这里具体数值就是0x8</p><p>SelectorData32，数据段选择子，这里具体数值就是0x10</p><p>完了再说IDT，虽然不需要IDT，但是还是要为IDT开辟存储空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;=======    tmp IDT</span><br><span class="line">IDT:</span><br><span class="line">    times   0x50    dq  0  ; Define Quadra Word，8B</span><br><span class="line">IDT_END:</span><br><span class="line">IDT_POINTER:</span><br><span class="line">        dw  IDT_END - IDT - 1</span><br><span class="line">        dd  IDT</span><br></pre></td></tr></table></figure><p>DB 定义的变量为字节型 Define Byte</p><p>DW 定义的变量为字类型（双字节）Define Word</p><p>DD 定义的变量为双字型（4字节）Define Double Word</p><p>DQ 定义的变量为4字型（8字节）Define Quadra Word</p><p>DT 定义的变量为10字节型 Define Ten Byte</p><p>书上总结的模式切换步骤，参考Intel卷3第9.9.1节Switching to Protected Mode</p><ol><li>执行CLI禁止可屏蔽硬件中断，对于不可屏蔽中断NMI只能借助外部电路才能禁止(模式切换过程中必须保证不能产生异常或中断)</li><li>执行LGDT将GDT的基地址和长度加载到GDTR寄存器</li><li>执行MOV CR0置CR0.PE标志位(可同时置位CR0.PG)</li><li>一旦MOV CR0执行结束，紧随其后必须执行一条跳转指令(JMP)或调用(CALL)指令，以切换到保护模式的代码段去执行</li><li>通过执行JMP或CALL指令，可以改变处理器执行流水线，进而使处理器加载执行保护模式的代码段</li><li>如果开启分页机制，那么MOV CR0指令和JMP/CALL指令必须位于identity mapped页面内，至于JMP/CALL指令的目标地址则无需是identity mapped</li><li>如需使用LDT，则必须借助LLDT指令将GDT内的LDT段选择子加载到LDTR寄存器中</li><li>执行LTR将一个TSS段描述符的选择子加载到TR任务寄存器</li><li>进入保护模式后，数据段寄存器仍旧保留着实模式的段数据，必须重新加载数据段选择子或使用JMP/CALL指令执行新任务，便可将其更新位保护模式</li><li>执行LIDT，将保护模式下的IDT表的基地址和长度加载到IDTR</li><li>执行STI指令是能可屏蔽硬件中断，并执行必要的硬件操作使能NMI不可屏蔽中断</li></ol><blockquote><ol><li>Disable interrupts. A CLI instruction disables maskable hardware interrupts. NMI interrupts can be disabled with external circuitry. (Software must guarantee that no exceptions or interrupts are generated during the mode switching operation.)</li><li>Execute the LGDT instruction to load the GDTR register with the base address of the GDT.</li><li>Execute a MOV CR0 instruction that sets the PE flag (and optionally the PG flag) in control register CR0.</li><li>Immediately following the MOV CR0 instruction, execute a far JMP or far CALL instruction. (This operation is typically a far jump or call to the next instruction in the instruction stream.)</li><li>The JMP or CALL instruction immediately after the MOV CR0 instruction changes the flow of execution and serializes the processor.</li><li>If paging is enabled, the code for the MOV CR0 instruction and the JMP or CALL instruction must come from a page that is identity mapped (that is, the linear address before the jump is the same as the physical address after paging and protected mode is enabled). The target instruction for the JMP or CALL instruction does not need to be identity mapped.</li><li>If a local descriptor table is going to be used, execute the LLDT instruction to load the segment selector for the LDT in the LDTR register.</li><li>Execute the LTR instruction to load the task register with a segment selector to the initial protected-mode task or to a writable area of memory that can be used to store TSS information on a task switch.</li><li>After entering protected mode, the segment registers continue to hold the contents they had in real-address mode. The JMP or CALL instruction in step 4 resets the CS register. Perform one of the following operations to update the contents of the remaining segment registers.<br>— Reload segment registers DS, SS, ES, FS, and GS. If the ES, FS, and/or GS registers are not going to be used, load them with a null selector.<br>— Perform a JMP or CALL instruction to a new task, which automatically resets the values of the segment registers and branches to a new code segment.</li><li>Execute the LIDT instruction to load the IDTR register with the address and limit of the protected-mode IDT.</li><li>Execute the STI instruction to enable maskable hardware interrupts and perform the necessary hardware operation to enable NMI interrupts.</li></ol></blockquote><h3 id="1-11-2-切换IA-32e模式"><a href="#1-11-2-切换IA-32e模式" class="headerlink" title="1.11.2 切换IA-32e模式"></a>1.11.2 切换IA-32e模式</h3><p>和进入保护模式差不多，只不过还要开启分页机制，参考Intel卷3第9.8.5 Initializing IA-32e Mode：</p><blockquote><ol><li>Starting from protected mode, disable paging by setting CR0.PG = 0. Use the MOV CR0 instruction to disable paging (the instruction must be located in an identity-mapped page).</li><li>Enable physical-address extensions (PAE) by setting CR4.PAE = 1. Failure to enable PAE will result in a #GP fault when an attempt is made to initialize IA-32e mode.</li><li>Load CR3 with the physical base address of the Level 4 page map table (PML4) or Level 5 page map table(PML5).</li><li>Enable IA-32e mode by setting IA32_EFER.LME = 1.</li><li>Enable paging by setting CR0.PG = 1. This causes the processor to set the IA32_EFER.LMA bit to 1. The MOV CR0 instruction that enables paging and the following instructions must be located in an identity-mapped page (until such time that a branch to non-identity mapped pages can be effected).</li></ol></blockquote><ol><li>在保护模式下，使用MOV CR0.PG指令关闭分页机制</li><li>置位CR4.PAE，开启物理地址扩展功能。若失败则产生#GP</li><li>PML4或PML5的物理基地址加载到CR3寄存器中</li><li>置位IA32_EFER.LME，打开IA-32e模式</li><li>置位CR0.PG开启分页机制，此时处理器会自动置位IA32_EFER.LMA。当执行MOV CR0指令开启分页时，其后续指令必须位于identity-mapped page(直到处理器进入IA-32e模式后，才能使用非identity-mapped page)</li></ol><p>在切到IA-32e模式之前应当先检查支不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s32]</span><br><span class="line">[BITS 32]</span><br><span class="line">GO_TO_TMP_Protect:</span><br><span class="line">;=======    go to tmp long mode</span><br><span class="line">    mov ax, 0x10</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov esp, 7E00h</span><br><span class="line">    call support_long_mode</span><br><span class="line">    test eax, eax  ; 目的操作数和源操作数按位与，与and不同的是test不改变目的操作数</span><br><span class="line">    jz no_support  ; 等于0时跳转 jmp $</span><br><span class="line"></span><br><span class="line">;=======    test support long mode or not</span><br><span class="line">support_long_mode:</span><br><span class="line">    mov eax, 0x80000000</span><br><span class="line">    cpuid</span><br><span class="line">    cmp eax, 0x80000001</span><br><span class="line">    setnb al  </span><br><span class="line">    jb support_long_mode_done</span><br><span class="line">    mov eax, 0x80000001</span><br><span class="line">    cpuid</span><br><span class="line">    bt edx, 29  ; bit test，将edx bit 29拷贝至CF</span><br><span class="line">    setc al  ; Set byte if carry，若CF=1，则al=1；否则al=0</span><br><span class="line">support_long_mode_done:</span><br><span class="line">    movzx eax, al  ; 将al全0扩展到eax，高位补0</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>进入保护模式首要任务是初始化各个寄存器以及栈指针，然后检测处理器是否支持IA-32e模式，这里是根据cpuid来判断的</p><p>CPUID指令分为两组，一组返回基本信息，一组返回扩展信息，Intel手册里面描述这个指令很复杂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 0</span><br><span class="line">cpuid</span><br></pre></td></tr></table></figure><p>执行完CPUID指令后，EAX中返回的值就是返回基本信息时，功能代码的最大值，在执行CPUID指令要求返回基本信息时，EAX中的值必须小于或等于该值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 80000000h</span><br><span class="line">cpuid</span><br></pre></td></tr></table></figure><p>执行完CPUID指令后，EAX中返回的值就是返回扩展信息时，功能代码的最大值，在执行CPUID指令要求返回扩展信息时，EAX中的值必须小于或等于该值。</p><p>如果这个号码大于等于0x80000001就说明可以支持long_mode，那么我们就直接跳转到support_long_mode_done，如果不行的话，需要检查这个号码的第29位，如果29位符合预期，那么说明也是可以支持的，否则就不行。</p><p>如果支持IA-32e模式，接下来就将为IA-32e模式配置临时页目录项和页表项。页目录首地址设置在0x90000地址处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;=======    init temporary page table 0x90000</span><br><span class="line">    mov dword   [0x90000],  0x91007</span><br><span class="line">    mov dword   [0x90004],  0x00000</span><br><span class="line">    mov dword   [0x90800],  0x91007</span><br><span class="line">    mov dword   [0x90804],  0x00000</span><br><span class="line"></span><br><span class="line">    mov dword   [0x91000],  0x92007</span><br><span class="line">    mov dword   [0x91004],  0x00000</span><br><span class="line"></span><br><span class="line">    mov dword   [0x92000],  0x000083</span><br><span class="line">    mov dword   [0x92004],  0x000000</span><br><span class="line">    mov dword   [0x92008],  0x200083</span><br><span class="line">    mov dword   [0x9200c],  0x000000</span><br><span class="line">    mov dword   [0x92010],  0x400083</span><br><span class="line">    mov dword   [0x92014],  0x000000</span><br><span class="line">    mov dword   [0x92018],  0x600083</span><br><span class="line">    mov dword   [0x9201c],  0x000000</span><br><span class="line">    mov dword   [0x92020],  0x800083</span><br><span class="line">    mov dword   [0x92024],  0x000000</span><br><span class="line">    mov dword   [0x92028],  0xa00083</span><br><span class="line">    mov dword   [0x9202c],  0x000000</span><br></pre></td></tr></table></figure><p>然后就是开启IA-32e模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">;=======    load GDTR</span><br><span class="line">    db  0x66</span><br><span class="line">    lgdt [GdtPtr64]  ; 加载64位的GDT到GDTR</span><br><span class="line">    mov ax, 0x10</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov esp,    7E00h</span><br><span class="line"></span><br><span class="line">;=======    open PAE</span><br><span class="line">    mov eax, cr4</span><br><span class="line">    bts eax, 5  ; Bit Test and Set，先将指定位的值存储到CF标志中然后设置该位 CR4.PAE</span><br><span class="line">    mov cr4, eax</span><br><span class="line">;=======    load    cr3</span><br><span class="line">    mov eax,    0x90000  ; 1001 0000...0000</span><br><span class="line">    mov cr3,    eax  ; 位12~位63，page directory base</span><br><span class="line">;=======    enable long-mode</span><br><span class="line">    mov ecx, 0C0000080h  ; IA32_EFER</span><br><span class="line">    rdmsr  ; 将MSR寄存器组中IA32_EFER值读到edx:eax</span><br><span class="line">    bts eax, 8  ; IA32_EFER.LME=1</span><br><span class="line">    wrmsr  ; 写回</span><br><span class="line">;=======    open PE and paging</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    bts eax, 0  ; CR0.PE=1</span><br><span class="line">    bts eax, 31 ; CR0.PG=1</span><br><span class="line">    mov cr0, eax</span><br><span class="line"></span><br><span class="line">    ; 使用JMP/CALL将CS段寄存器的更新为IA-32e模式的代码段描述符</span><br><span class="line">    jmp SelectorCode64:OffsetOfKernelFile</span><br></pre></td></tr></table></figure><p>IA32_EFER寄存器位于MSR寄存器组内，它的第8位是LME标志位，为了操作IA32_EFER寄存器必须借助特殊汇编指令RDMSR/WRMSR</p><p>在访问MSR寄存器前，必须向ECX寄存器(在64位模式下RCX寄存器高32位被忽略)传入寄存器地址。而目标寄存器则是由EDX:EAX组成的64位寄存器代表，其中EDX寄存器保存MSR寄存器高32位，EAX寄存器保存低32位</p><p>RDMSR/WRMSR必须在0特权级或实模式下执行。在使用这两条指令前，应该使用CPUID指令(CPUID.01H:EDX[5]=1)来检测处理器是否支持MSR寄存器组</p><p>这里的0C0000080h在Intel卷4有提到 Table 2-3. MSRs in Processors Based on Intel® Core™ Microarchitecture (Contd.)</p><p>C000_0080H IA32_EFER Unique Extended Feature Enables</p><p>IA32_EFER寄存器布局</p><table><thead><tr><th>63:12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7:1</th><th>0</th></tr></thead><tbody><tr><td>Reserved</td><td>Execute-disable bit enable (NXE)</td><td>IA-32e mode active (LMA)</td><td>Reserved</td><td>IA-32e mode enable (LME)</td><td>Reserved</td><td>SysCall enable (SCE)</td></tr></tbody></table><p>伴随着loader最后一条指令，处理器控制权已经交给了kernel.bin了，等着下一节的探索..</p><h1 id="2-实践"><a href="#2-实践" class="headerlink" title="2 实践"></a>2 实践</h1><p>代码看完了当然要动手了，这下文件比较多，主要是4个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fat12.inc   <span class="comment"># fat12格式文件</span></span><br><span class="line">boot.asm    <span class="comment"># 之前的boot.asm文件，主要功能是找loader.bin</span></span><br><span class="line">loader.asm  <span class="comment"># 这次的源码，主要功能是找kernel.bin，并开启临时IA-32e模式，进入kernel</span></span><br><span class="line">Makefile    <span class="comment"># 后面源文件越来越多，不能一个个敲 nasm boot.asm -o boot.bin</span></span><br></pre></td></tr></table></figure><p>简单看下Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: boot.bin loader.bin</span></span><br><span class="line"><span class="section">loader.bin:</span></span><br><span class="line">	nasm loader.asm -o loader.bin</span><br><span class="line"><span class="section">boot.bin:</span></span><br><span class="line">	nasm boot.asm -o boot.bin</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.bin *.asm~ Makefile~ loader.bin boot.bin</span><br></pre></td></tr></table></figure><p>执行make的时候会生成boot.bin和loader.bin，执行make clean的时候会删除bin文件和临时文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成bin文件</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个1.44MB的img软盘镜像</span></span><br><span class="line">sidney@ubuntu:~/Work/MyOS/day04$ bximage </span><br><span class="line">========================================================================</span><br><span class="line">                                bximage</span><br><span class="line">                  Disk Image Creation Tool <span class="keyword">for</span> Bochs</span><br><span class="line">          <span class="variable">$Id</span>: bximage.c 11315 2012-08-05 18:13:38Z vruppert $</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">Do you want to create a floppy disk image or a hard disk image?</span><br><span class="line">Please <span class="built_in">type</span> hd or fd. [hd] fd</span><br><span class="line"></span><br><span class="line">Choose the size of floppy disk image to create, <span class="keyword">in</span> megabytes.</span><br><span class="line">Please <span class="built_in">type</span> 0.16, 0.18, 0.32, 0.36, 0.72, 1.2, 1.44, 1.68, 1.72, or 2.88.</span><br><span class="line"> [1.44] 1.44</span><br><span class="line">I will create a floppy image with</span><br><span class="line">  cyl=80</span><br><span class="line">  heads=2</span><br><span class="line">  sectors per track=18</span><br><span class="line">  total sectors=2880</span><br><span class="line">  total bytes=1474560</span><br><span class="line"></span><br><span class="line">What should I name the image?</span><br><span class="line">[a.img] boot.img</span><br><span class="line"></span><br><span class="line">Writing: [] Done.</span><br><span class="line"></span><br><span class="line">I wrote 1474560 bytes to boot.img.</span><br><span class="line"></span><br><span class="line">The following line should appear <span class="keyword">in</span> your bochsrc:</span><br><span class="line">  floppya: image=<span class="string">"boot.img"</span>, status=inserted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建boot.img，dd 命令的 conv=notrunc 字段很重要，保证软盘文件不截断</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将boot.img挂载到/media，这个/media可以随便创建一个目录</span></span><br><span class="line">sudo mount boot.img /media/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于boot.img已经拥有了FAT12文件系统（说白了，就是可以解析FAT表项的能力，代码实现于Func_GetFATEntry部分），</span></span><br><span class="line"><span class="comment"># 并且mount命令可以实现FAT数据区与根目录区的联系，从而达到只需要操作media文件夹实质就是操作boot.img的效果</span></span><br><span class="line"><span class="comment">#（说白了，如果我们往挂载好之后的media分区复制数据，其实就是把数据复制到boot.img）</span></span><br><span class="line">sudo <span class="built_in">cp</span> loader.bin /media/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还没有写kernel，先弄个假的进去</span></span><br><span class="line"><span class="built_in">cp</span> loader.bin kernel.bin</span><br><span class="line">sudo <span class="built_in">cp</span> kernel.bin /media/</span><br><span class="line"><span class="comment"># 数据都写进boot.img就不需要挂载了</span></span><br><span class="line">sudo umount /media</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里不是用qemu-system-i386了，执行完一直在闪烁？</span></span><br><span class="line">qemu-system-x86_64 -drive file=boot.img,format=raw,<span class="keyword">if</span>=floppy</span><br></pre></td></tr></table></figure><p>讲道理，应该算成功了..</p><h2 id="2-1-安装bochs"><a href="#2-1-安装bochs" class="headerlink" title="2.1 安装bochs"></a>2.1 安装bochs</h2><p>在<strong>1.3 打开A20功能</strong>那段代码sti后面加一个<code>jmp $</code>看段寄存器状态，百度了下，qemu好像没招，乖乖安装bochs..</p><p>下载：<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/bochs/files/bochs/2.7/bochs-2.7.tar.gz/download">bochs-2.7.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf bochs-2.7.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bochs-2.7</span><br><span class="line"></span><br><span class="line">./confugure --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">./configure --with-x11 --with-wx --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-smp --enable-long-phy-address --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls --enable-handlers-chaining --enable-trace-linking --enable-configurable-msrs --enable-show-ips --enable-cpp --enable-debugger --enable-debugger-gui --enable-iodebug --enable-all-optimizations --enable-readline --enable-logging --enable-stats --enable-assert-checks --enable-fpu --enable-vmx --enable-svm --enable-protection-keys --enable-cet --enable-3dnow --enable-alignment-check --enable-monitor-mwait --enable-perfmon --enable-memtype --enable-avx --enable-evex --enable-x86-debugger --enable-pci --enable-pcidev --enable-usb --enable-usb-ohci --enable-usb-ehci --enable-usb-xhci --enable-ne2000 --enable-pnic --enable-e1000 --enable-raw-serial --enable-clgd54xx --enable-voodoo --enable-cdrom --enable-sb16 --enable-es1370 --enable-gameport --enable-busmouse --enable-xpm</span><br><span class="line"></span><br><span class="line">make -j8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时会报一些错 简单改改就好了</span></span><br><span class="line"><span class="built_in">cp</span> ./bx_debug/parser.cpp ./bx_debug/parser.cc</span><br><span class="line"><span class="built_in">cp</span> misc/bximage.cpp misc/bximage.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/hdimage.cpp iodev/hdimage/hdimage.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/vmware3.cpp iodev/hdimage/vmware3.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/vmware4.cpp iodev/hdimage/vmware4.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/vpc.cpp iodev/hdimage/vpc.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/hdimage/vbox.cpp iodev/hdimage/vbox.cc</span><br><span class="line"><span class="built_in">cp</span> misc/bxhub.cpp misc/bxhub.cc</span><br><span class="line"><span class="built_in">cp</span> iodev/network/netutil.cpp iodev/network/netutil.cc</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line">bochs -<span class="built_in">help</span> cpu</span><br></pre></td></tr></table></figure><p>然后根据书上在用户家目录创建bochs的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bochsrc</span><br><span class="line"></span><br><span class="line">plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1</span><br><span class="line">config_interface: textconfig</span><br><span class="line">display_library: x</span><br><span class="line">cpu: model=corei7_haswell_4770,count=1:1:1,ips=4000000,quantum=16,reset_on_triple_fault=1</span><br><span class="line">cpu: cpuid_limit_winnt=0,ignore_bad_msrs=1,mwait_is_nop=0,msrs=<span class="string">"msrs.def"</span></span><br><span class="line">cpuid: x86_64=1,level=6,mmx=1,sep=1,simd=avx512,apic=x2apic,aes=1,movbe=1,xsave=1,sha=1,adx=1,xsaveopt=1,</span><br><span class="line">cpuid: avx_f16c=1,avx_fma=1,bmi=bmi2,1g_pages=1,pcid=1,fsgsbase=1,smep=1,smap=1,mwait=1,vmx=1,family=6</span><br><span class="line">cpuid: model=0x1a, stepping=5, vendor_string=<span class="string">"GenuineIntel"</span>,brand_string=<span class="string">"Intel(R) Core(TM) i7-4770 CPU (Haswell)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#memory: guest=2048, host=2048</span></span><br><span class="line"></span><br><span class="line">romimage: file=/usr/local/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">vga: extension=vbe, update_freq=5</span><br><span class="line"><span class="comment">#voodoo: enabled=1, model=voodoo1</span></span><br><span class="line"></span><br><span class="line">keyboard: <span class="built_in">type</span>=mf, serial_delay=250, paste_delay=100000, user_shortcut=none</span><br><span class="line">mouse: <span class="built_in">type</span>=ps2,enabled=0,toggle=ctrl+mbutton</span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line">clock: <span class="built_in">sync</span>=none, time0=<span class="built_in">local</span>, rtc_sync=0</span><br><span class="line"><span class="comment">#cmosimage: file=cmos.img, rtc_init=time0</span></span><br><span class="line">private_colormap: enabled=0</span><br><span class="line"></span><br><span class="line">floppya: <span class="built_in">type</span>=1_44, 1_44=<span class="string">"boot.img"</span>, status=inserted, write_protected=0</span><br><span class="line"><span class="comment"># no floppyb</span></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: <span class="built_in">type</span>=none</span><br><span class="line">ata0-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata1-master: <span class="built_in">type</span>=none</span><br><span class="line">ata1-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line">boot: floppy</span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>: bochsout.log</span><br><span class="line">logprefix: %t-%e-@%i-%d</span><br><span class="line">panic: action=ask</span><br><span class="line">error: action=report</span><br><span class="line">info: action=report</span><br><span class="line">debug: action=ignore, pci=report</span><br><span class="line">debugger_log: -</span><br><span class="line"></span><br><span class="line">com1: enabled=1, mode=null</span><br><span class="line">com2: enabled=0</span><br><span class="line">com3: enabled=0</span><br><span class="line">com4: enabled=0</span><br><span class="line"></span><br><span class="line">parport1: enabled=1, file=none</span><br><span class="line">parport2: enabled=0</span><br><span class="line"></span><br><span class="line">sound: waveoutdrv=sdl, waveindrv=alsa, midioutdrv=dummy</span><br><span class="line">speaker: enabled=1, mode=system, volume=15</span><br><span class="line">sb16: enabled=0</span><br><span class="line">es1370: enabled=0</span><br><span class="line"></span><br><span class="line">usb_ehci: enabled=1</span><br><span class="line">usb_xhci: enabled=1</span><br><span class="line"></span><br><span class="line">magic_break: enabled=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug_symbols: file="kernel.sym"</span></span><br><span class="line">print_timestamps: enabled=0</span><br><span class="line">port_e9_hack: enabled=0</span><br><span class="line">fullscreen: enabled=0</span><br><span class="line"></span><br><span class="line">megs: 2048</span><br></pre></td></tr></table></figure><p>bochs的调试命令</p><table><thead><tr><th>命令</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>b address</td><td>在某物理地址上设置断点</td><td>b 0x7c00</td></tr><tr><td>c</td><td>继续执行，直到遇到断点</td><td>c</td></tr><tr><td>s</td><td>单步执行</td><td>s</td></tr><tr><td>info cpu</td><td>查看寄存器信息</td><td>info cpu</td></tr><tr><td>r</td><td>查看<strong>通用</strong>寄存器信息</td><td></td></tr><tr><td>sreg</td><td>查看<strong>段</strong>寄存器信息</td><td></td></tr><tr><td>creg</td><td>查看<strong>控制</strong>寄存器信息</td><td></td></tr><tr><td>xp /nuf addr</td><td>查看内存物理地址内容</td><td>xp /10bx 0x100000</td></tr><tr><td>x /nuf addr</td><td>查看线性地址内容</td><td>x /40wd 0x9000</td></tr><tr><td>u start end</td><td>反汇编一段内存</td><td>u 0x100000 0x100010</td></tr></tbody></table><h2 id="2-2-第一条指令"><a href="#2-2-第一条指令" class="headerlink" title="2.2 第一条指令"></a>2.2 第一条指令</h2><p>还是按照qemu的一套动作来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make  <span class="comment"># 编译</span></span><br><span class="line"><span class="built_in">cp</span> loader.bin kernel.bin  <span class="comment"># 没有kernel.bin，随便拷贝一个</span></span><br><span class="line">bximage  <span class="comment"># 创建floppy disk</span></span><br><span class="line"><span class="comment"># 将boot.bin写到floppy disk中</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br><span class="line"><span class="comment"># 将boot.img挂载到/media</span></span><br><span class="line">sudo mount boot.img /media/ -t vfat -o loop</span><br><span class="line">sudo <span class="built_in">cp</span> loader.bin /media/</span><br><span class="line">sudo <span class="built_in">cp</span> kernel.bin /media/</span><br><span class="line"><span class="built_in">sync</span>  <span class="comment"># 将loader.bin和kernel.bin写到floppy disk中</span></span><br><span class="line">sudo umount /media</span><br><span class="line"></span><br><span class="line">bochs  <span class="comment"># 启动bochs</span></span><br></pre></td></tr></table></figure><p>这个时候先不要急着执行c或s，想想第0天的内容，Intel卷3第9.1.1 Processor State After Reset，寄存器初始化的状态全在那张表了 Table 9-1. IA-32 and Intel 64 Processor States Following Power-up, Reset, or INIT</p><p>执行几条命令看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是bochs刚开始的时候，下一条指令是 jmpf 0xf000:e05b</span></span><br><span class="line"><span class="comment"># Next at t=0中t是执行的指令个数，也叫做内部时钟</span></span><br><span class="line"><span class="comment"># 0x0000fffffff0  物理地址</span></span><br><span class="line"><span class="comment"># f000:fff0 逻辑地址，好像算不出来上面的物理地址？</span></span><br><span class="line"><span class="comment"># jmpf 0xf000:e05b  汇编指令</span></span><br><span class="line"><span class="comment"># ea5be000f0  机器码</span></span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看控制寄存器 CR0=0x60000010 没毛病</span></span><br><span class="line">&lt;bochs:2&gt; creg</span><br><span class="line"><span class="comment"># 小写的表示标志位是0，大写的表示标志位是1</span></span><br><span class="line">CR0=0x60000010: pg CD NW ac wp ne ET ts em mp pe</span><br><span class="line">CR2=page fault laddr=0x0000000000000000</span><br><span class="line">CR3=0x000000000000</span><br><span class="line">    PCD=page-level cache <span class="built_in">disable</span>=0</span><br><span class="line">    PWT=page-level write-through=0</span><br><span class="line">CR4=0x00000000: pks cet pke smap smep keylock osxsave pcid fsgsbase smx vmx la57 umip osxmmexcpt osfxsr pce pge mce pae pse de tsd pvi vme</span><br><span class="line">CR8: 0x0</span><br><span class="line">EFER=0x00000000: ffxsr nxe lma lme sce</span><br><span class="line">XCR0=0x00000001: cet_s cet_u pkru hi_zmm zmm_hi256 opmask bndcfg bndregs ymm sse FPU</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看段寄存器 cs:0xf000，base=0xffff0000，limit=0x0000ffff和书上说的一样</span></span><br><span class="line">&lt;bochs:1&gt; sreg</span><br><span class="line">es:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">	Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">cs:0xf000, dh=0xff0093ff, dl=0x0000ffff, valid=7</span><br><span class="line">	Data segment, base=0xffff0000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">	Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ds:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">	Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">	Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">	Data segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1</span><br><span class="line"><span class="built_in">tr</span>:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1</span><br><span class="line">gdtr:base=0x0000000000000000, <span class="built_in">limit</span>=0xffff</span><br><span class="line">idtr:base=0x0000000000000000, <span class="built_in">limit</span>=0xffff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看通用寄存器 rip: 00000000_0000fff0，eflags 0x00000002</span></span><br><span class="line">&lt;bochs:3&gt; r</span><br><span class="line">CPU0:</span><br><span class="line">rax: 00000000_00000000</span><br><span class="line">rbx: 00000000_00000000</span><br><span class="line">rcx: 00000000_00000000</span><br><span class="line">rdx: 00000000_00000000</span><br><span class="line">rsp: 00000000_00000000</span><br><span class="line">rbp: 00000000_00000000</span><br><span class="line">rsi: 00000000_00000000</span><br><span class="line">rdi: 00000000_00000000</span><br><span class="line">r8 : 00000000_00000000</span><br><span class="line">r9 : 00000000_00000000</span><br><span class="line">r10: 00000000_00000000</span><br><span class="line">r11: 00000000_00000000</span><br><span class="line">r12: 00000000_00000000</span><br><span class="line">r13: 00000000_00000000</span><br><span class="line">r14: 00000000_00000000</span><br><span class="line">r15: 00000000_00000000</span><br><span class="line">rip: 00000000_0000fff0</span><br><span class="line">eflags 0x00000002: <span class="built_in">id</span> vip vif ac vm rf nt IOPL=0 of <span class="built_in">df</span> <span class="keyword">if</span> tf sf zf af pf cf</span><br></pre></td></tr></table></figure><p>从这些寄存器的值来看，和Intel手册上的东西是一一对应了，那么问题来了</p><p><strong>1 为啥逻辑地址是<code>f000:fff0</code>，物理地址是<code>fffffff0</code>？</strong></p><p>实际上这个问题在第0天说过了，也就是Intel手册卷3第9.1.4 First Instruction Executed</p><p><img data-src="/assets/05_Make-MyOS-Find-kernel/202201182351351.png" alt="202201182351351"></p><p>大致意思就是上电后第一条指令，因为CS段寄存器基址是FFFF0000H，段选择子是F000H，在实模式下，一般来说基址是段选择子左移4位得来的，但这里显然不是，而是按照初始的基址。</p><p>硬件复位后第一次向CS寄存器加载新值时，处理器将遵循实地址模式下的正常地址转换规则(即[CS基地址=CS段选择器*16])，也就是到CS=0x7c00那个时候</p><p><strong>2 第一条指令到底是啥呢？为什么是<code>jmpf 0xf000:e05b</code>？</strong></p><p>回答这个问题之前，先看看实模式下1M内存的布局，截取自《操作系统真象还原》</p><p><img data-src="/./assets/05_Make-MyOS-Find-kernel/202201192313827.png"></p><p>第一条指令是<code>jmpf 0xf000:e05b</code>，在的地方刚好占了16B，也就是说第一条指令基本就是跳转，干不了别的事，跳转到哪？各家的BIOS程序开始，bochs是<code>0xf000:e05b</code>，别家的可不一样。至于BIOS做了什么，在第0天已经说过了，这里看个下面几条指令就过了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:1&gt; s</span><br><span class="line">Next at t=1</span><br><span class="line">(0) [0x0000000fe05b] f000:e05b (unk. ctxt): xor ax, ax                ; 31c0</span><br><span class="line">&lt;bochs:2&gt; s       </span><br><span class="line">Next at t=2</span><br><span class="line">(0) [0x0000000fe05d] f000:e05d (unk. ctxt): out 0x0d, al              ; e60d</span><br><span class="line">&lt;bochs:3&gt; s</span><br><span class="line">Next at t=3</span><br><span class="line">(0) [0x0000000fe05f] f000:e05f (unk. ctxt): out 0xda, al              ; e6da</span><br><span class="line">&lt;bochs:4&gt; s</span><br><span class="line">Next at t=4</span><br><span class="line">(0) [0x0000000fe061] f000:e061 (unk. ctxt): mov al, 0xc0              ; b0c0</span><br><span class="line">&lt;bochs:5&gt; s</span><br><span class="line">Next at t=5</span><br><span class="line">(0) [0x0000000fe063] f000:e063 (unk. ctxt): out 0xd6, al              ; e6d6</span><br></pre></td></tr></table></figure><p>S是单步调试，这里out命令实际上是给各个硬件端口设值，不关注</p><p>什么？你说BIOS程序是怎么加载到内存的？这个在第0天也提到过，硬件完成的，写在ROM中由硬件映射到低端1M内存中</p><p>然后BIOS会识别512B MBR(就是我们写的boot.asm)，并加载到7C00H~7DFF中，不再赘述</p><h2 id="2-3-执行MBR"><a href="#2-3-执行MBR" class="headerlink" title="2.3 执行MBR"></a>2.3 执行MBR</h2><p>跳过BIOS的操作，直接在0x7c00处打个断点，并单步调试看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:55&gt; b 0x7c00  <span class="comment"># 设断点</span></span><br><span class="line">&lt;bochs:56&gt; c         <span class="comment"># 执行到断点处</span></span><br><span class="line">(0) Breakpoint 1, 0x0000000000007c00 <span class="keyword">in</span> ?? ()</span><br><span class="line">Next at t=14034563</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): jmp .+60  (0x00007c3e)    ; eb3c</span><br><span class="line">&lt;bochs:57&gt; s</span><br><span class="line">Next at t=14034564</span><br><span class="line">(0) [0x000000007c3e] 0000:7c3e (unk. ctxt): mov ax, cs                ; 8cc8</span><br><span class="line">&lt;bochs:58&gt; s</span><br><span class="line">Next at t=14034565</span><br><span class="line">(0) [0x000000007c40] 0000:7c40 (unk. ctxt): mov ds, ax                ; 8ed8</span><br><span class="line">&lt;bochs:59&gt; s</span><br><span class="line">Next at t=14034566</span><br><span class="line">(0) [0x000000007c42] 0000:7c42 (unk. ctxt): mov es, ax                ; 8ec0</span><br><span class="line">&lt;bochs:60&gt; s</span><br><span class="line">Next at t=14034567</span><br><span class="line">(0) [0x000000007c44] 0000:7c44 (unk. ctxt): mov ss, ax                ; 8ed0</span><br><span class="line">&lt;bochs:61&gt; s</span><br><span class="line">Next at t=14034568</span><br><span class="line">(0) [0x000000007c46] 0000:7c46 (unk. ctxt): mov sp, 0x7c00            ; bc007c</span><br></pre></td></tr></table></figure><p>这里和boot.asm开头那段是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Label_Start:</span><br><span class="line">    mov ax, cs  ; 最开始cs是等于0的</span><br><span class="line">    mov ds, ax  ; ds es ss不能通过立即数赋值 需要ax中转</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, BaseOfStack  ; 栈指针设到0x7c00</span><br></pre></td></tr></table></figure><p>然后在boot.asm中是将loader.bin加载到0x10000地址处，从上面的表中可以看到从0x7E00到0x9FBFF都是保留区域，中间留的一些空后面用作临时转存kernel的东西了，当加载loader.bin之后，直接跳转过去<code>jmp	BaseOfLoader:OffsetOfLoader</code>，所以下一个断点就是0x10000咯，和boot.asm是一样的东西，不看了</p><h2 id="2-4-loader-bin"><a href="#2-4-loader-bin" class="headerlink" title="2.4 loader.bin"></a>2.4 loader.bin</h2><p>书上loader.bin上的一些小测试，第一个在开启A20 pin之后，查看fs段的limit，需要在开启A20 pin那节sti命令后面加个<code>jmp $</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:2&gt; sreg</span><br><span class="line">es:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">	Data segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">cs:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">	Data segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ds:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">	Data segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">fs:0x0010, dh=0x00cf9300, dl=0x0000ffff, valid=1</span><br><span class="line">	Data segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed</span><br><span class="line">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1</span><br><span class="line">	Data segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1</span><br><span class="line">tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1</span><br><span class="line">gdtr:base=0x0000000000010040, limit=0x17</span><br><span class="line">idtr:base=0x0000000000000000, limit=0x3ff</span><br></pre></td></tr></table></figure><p>可以看到开启A20 pin后，fs的limit变了，寻址能力变成4G了</p><p>打印SVGA相关信息，这个必须要在设置VGA模式(set the SVGA mode(VESA VBE))之前加个<code>jmp $</code>，因为设置完貌似就清屏了，啥信息也没有了，实际测试如下..</p><p><img data-src="/./assets/05_Make-MyOS-Find-kernel/202201231548556.png"></p><p>当按书上的源码执行完后，bochs的界面应当发生改变，并且bochs的log中有**CPU is in long mode (active)**以表示我们真的进入了64位模式</p><h1 id="3-阶段小结"><a href="#3-阶段小结" class="headerlink" title="3 阶段小结"></a>3 阶段小结</h1><p>一张图算是对前面几节的总结了，刚开机干的事还是比较简单的</p><p><img data-src="/./assets/05_Make-MyOS-Find-kernel/202201231746653.svg"></p></div><footer class="post-footer"><div class="readEnd">------- This article is over <i class="fa fa-leaf" aria-hidden="true"></i> Thank you for your reading -------</div><div class="reward-container"><div>All I need is you needing me.</div><button>Donate</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Sidney Ding WeChat Pay"> <span>WeChat Pay</span></div><div><img src="/images/alipay.jpg" alt="Sidney Ding Alipay"> <span>Alipay</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>Post author: </strong>Sidney Ding</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://sidneygod.gitlab.io/posts/ffccb7c5/" title="[Make MyOS] Find kernel">https://sidneygod.gitlab.io/posts/ffccb7c5/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/a4707db6/" rel="prev" title="[Make MyOS] Basic execution env & Interrupt"><i class="fa fa-chevron-left"></i> [Make MyOS] Basic execution env & Interrupt</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="SOHUCS" sid="e698f94222e8890b1f35fd855238c8a2"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Sidney Ding</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>Symbols count total: </span><span title="Symbols count total">273k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>Reading time total &asymp;</span> <span title="Reading time total">4:08</span></span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a></div><div><span><i class="fa-solid fa-bomb"></i> </span><span id="showDays"></span></div><script>let seconds=1e3,minutes=60*seconds,hours=60*minutes,days=24*hours,years=365*days,birthDay=Date.UTC(2019,10,1,0,0,0);setInterval((function(){let e=new Date,s=e.getFullYear(),t=e.getMonth()+1,o=e.getDate(),a=e.getHours(),n=e.getMinutes(),r=e.getSeconds(),h=Date.UTC(s,t,o,a,n,r)-birthDay,u=Math.floor(h/years),d=Math.floor(h/days-365*u),y=Math.floor((h-(365*u+d)*days)/hours),i=Math.floor((h-(365*u+d)*days-y*hours)/minutes),l=Math.floor((h-(365*u+d)*days-y*hours-i*minutes)/seconds);document.getElementById("showDays").innerHTML="This website has been running for "+u+" years, "+d+" days, "+y+" hours, "+i+" minutes, "+l+" seconds"}),1e3)</script></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.2.0/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://sidneygod.gitlab.io/posts/ffccb7c5/"}</script><script src="/js/third-party/quicklink.js"></script><script src="/js/love.js"></script><script src="/js/show-text.js"></script><script src="/js/snowflakes.min.js"></script><script src="/js/activate-power-mode.min.js"></script><script>new Snowflakes({color:"rgba(129, 161, 193, 0.87)"}),POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cyw6GhFAo","appkey":"39c16599e32c872d8661763f6b93d932"}</script><script src="/js/third-party/comments/changyan.js"></script></body></html>