<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=7.4.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.4.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.4.1"><link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222"><link rel="alternate" href="/atom.xml" title="Sidney God" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=7.4.1"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.4.1",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!0,lazyload:!0,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"},sidebarPadding:40}</script><meta name="description" content="《64位》比《32位》多了一步loader.bin似乎，《32位》的下一步直接就是导入C语言，开始搞系统了，《64位》还得再来个loader，接着干吧..这一节很重要，承上启下，甚至于内容也是这次把书上的源码上传的gitee了:00_一个64位操作系统的设计与实现&#x2F;一个64位操作系统的设计与实现-源代码&#x2F;第二部分 初级篇&#x2F;第3章&#x2F;程序&#x2F;程序3-4 · Sidney&#x2F;MakeOS - 码云 - 开源"><meta property="og:type" content="article"><meta property="og:title" content="[Make MyOS] Find kernel"><meta property="og:url" content="https://sidneygod.github.io/posts/ffccb7c5/index.html"><meta property="og:site_name" content="Sidney God"><meta property="og:description" content="《64位》比《32位》多了一步loader.bin似乎，《32位》的下一步直接就是导入C语言，开始搞系统了，《64位》还得再来个loader，接着干吧..这一节很重要，承上启下，甚至于内容也是这次把书上的源码上传的gitee了:00_一个64位操作系统的设计与实现&#x2F;一个64位操作系统的设计与实现-源代码&#x2F;第二部分 初级篇&#x2F;第3章&#x2F;程序&#x2F;程序3-4 · Sidney&#x2F;MakeOS - 码云 - 开源"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://sidneygod.github.io/posts/ffccb7c5/assets/05_Make-MyOS-Find-kernel/202112072244745.png"><meta property="og:image" content="https://sidneygod.github.io/posts/ffccb7c5/assets/05_Make-MyOS-Find-kernel/202201182351351.png"><meta property="og:image" content="https://sidneygod.github.io/posts/ffccb7c5/assets/05_Make-MyOS-Find-kernel/202201192313827.png"><meta property="og:image" content="https://sidneygod.github.io/posts/ffccb7c5/assets/05_Make-MyOS-Find-kernel/202201231548556.png"><meta property="og:image" content="https://sidneygod.github.io/posts/ffccb7c5/assets/05_Make-MyOS-Find-kernel/202201231746653.svg"><meta property="article:published_time" content="2022-01-16T13:54:41.000Z"><meta property="article:modified_time" content="2022-06-05T12:25:06.985Z"><meta property="article:author" content="Sidney Ding"><meta property="article:tag" content="Sidney"><meta property="article:tag" content=" Ding"><meta property="article:tag" content=" Sidney Ding"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://sidneygod.github.io/posts/ffccb7c5/assets/05_Make-MyOS-Find-kernel/202112072244745.png"><link rel="canonical" href="https://sidneygod.github.io/posts/ffccb7c5/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>[Make MyOS] Find kernel | Sidney God</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Sidney God</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Keep quiet time for time</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">18</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">23</span></a></li><li class="menu-item menu-item-resources"><a href="/resources/" rel="section"><i class="fa fa-fw fa-book"></i>Resources</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="reading-progress-bar"></div><a class="book-mark-link book-mark-link-fixed" href="#"></a> <a href="https://github.com/SidneyGod" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article itemscope itemtype="http://schema.org/Article"><div class="post-block post"><link itemprop="mainEntityOfPage" href="https://sidneygod.github.io/posts/ffccb7c5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Sidney Ding"><meta itemprop="description" content="You laugh at me for being different, but I laugh at you for being the same."><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sidney God"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">[Make MyOS] Find kernel</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2022-01-16 21:54:41" itemprop="dateCreated datePublished" datetime="2022-01-16T21:54:41+08:00">2022-01-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-06-05 20:25:06" itemprop="dateModified" datetime="2022-06-05T20:25:06+08:00">2022-06-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/Make-OS/" itemprop="url" rel="index"><span itemprop="name">Make OS</span></a></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine: </span><a title="valine" href="/posts/ffccb7c5/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/ffccb7c5/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>45k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>1:15</span></span></div></header><div class="post-body" itemprop="articleBody"><html><head></head><body><p>《64位》比《32位》多了一步loader.bin似乎，《32位》的下一步直接就是导入C语言，开始搞系统了，《64位》还得再来个loader，接着干吧..这一节很重要，承上启下，甚至于内容也是</p><p>这次把书上的源码上传的gitee了:<a href="https://gitee.com/SidneyGod/make-os/tree/master/00_一个64位操作系统的设计与实现/一个64位操作系统的设计与实现-源代码/第二部分 初级篇/第3章/程序/程序3-4" target="_blank" rel="noopener">00_一个64位操作系统的设计与实现/一个64位操作系统的设计与实现-源代码/第二部分 初级篇/第3章/程序/程序3-4 · Sidney/MakeOS - 码云 - 开源中国 (gitee.com)</a></p><p>书上说，Loader的作用很大，大概包括：</p><ul><li><p>检测硬件信息</p><p>主要是通过BIOS中断服务程序来获取和检测硬件信息。BIOS上电自检的大部分信息只能在实模式下获取，内核运行在非实模式下，所以需要在进入内核前将信息检测出来，再作为参数提供给内核程序使用。比如获取ROM，RAM，设备寄存器和内存空洞等资源的物理地址范围交给内存管理单元模块维护；通过VBE功能检测出显示器支持的分辨率，显示模式，刷新率以及显存物理地址以配置合理的显示模式</p></li><li><p>处理器模式切换</p><p>BIOS运行的实模式到32位操作系统用的保护模式，再到64位操作系统用的IA-32e模式(长模式)</p></li><li><p>向内核传递数据</p><p>向内核传递两种数据，控制信息：控制内核执行流程或限制内核某些功能；硬件数据信息：检测出来的硬件数据信息，保存在固定的内存地址中，并将数据其实内存地址和数据长度作为参数传递给内核。</p></li></ul><a id="more"></a><h1 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1 源码分析"></a>1 源码分析</h1><p>然后就是分析loader源码了，六百多行吧..但是其实和boot差不多，又是一个找kernel的过程，这下没画图了，感觉还好..</p><h2 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">; 程序从物理地址0x10000(1M)处 也就是boot加载loader的地址</span><br><span class="line">org 10000h</span><br><span class="line">jmp Label_Start</span><br><span class="line">; 相当于C语言中的include 也就是FAT12文件的系统结构</span><br><span class="line">%include    "fat12.inc"</span><br><span class="line"></span><br><span class="line">BaseOfKernelFile    equ 0x00</span><br><span class="line">OffsetOfKernelFile  equ 0x100000  ; kernel真正加载的位置</span><br><span class="line"></span><br><span class="line">BaseTmpOfKernelAddr equ 0x00</span><br><span class="line">; 内核程序临时转存空间 因为内核程序读取操作是通过BIOS中断服务int 13h实现的</span><br><span class="line">; BIOS在实模式下只支持上限为1MB的物理地址空间寻址，所以需要先搬到临时转存空间</span><br><span class="line">; 再通过特殊方式搬运到1MB以上的内存空间</span><br><span class="line">OffsetTmpOfKernelFile   equ 0x7E00</span><br><span class="line"></span><br><span class="line">; 真正用途 存储物理内存结构</span><br><span class="line">MemoryStructBufferAddr  equ 0x7E00</span><br><span class="line"></span><br><span class="line">; 32位段描述表</span><br><span class="line">[SECTION gdt]</span><br><span class="line">LABEL_GDT:      dd  0,0  ; 空描述符</span><br><span class="line">LABEL_DESC_CODE32:  dd  0x0000FFFF,0x00CF9A00  ; 代码段</span><br><span class="line">LABEL_DESC_DATA32:  dd  0x0000FFFF,0x00CF9200  ; 数据段</span><br><span class="line">GdtLen  equ $ - LABEL_GDT  ; GDT长度</span><br><span class="line">GdtPtr  dw  GdtLen - 1  ; 这个就是 limit</span><br><span class="line">        dd  LABEL_GDT  ; GDT基址</span><br><span class="line">SelectorCode32  equ LABEL_DESC_CODE32 - LABEL_GDT  ; 代码段选择子</span><br><span class="line">SelectorData32  equ LABEL_DESC_DATA32 - LABEL_GDT  ; 数据段选择子</span><br><span class="line"></span><br><span class="line">; 64位段描述表</span><br><span class="line">[SECTION gdt64]</span><br><span class="line">LABEL_GDT64:        dq  0x0000000000000000</span><br><span class="line">LABEL_DESC_CODE64:  dq  0x0020980000000000</span><br><span class="line">LABEL_DESC_DATA64:  dq  0x0000920000000000</span><br><span class="line">GdtLen64    equ $ - LABEL_GDT64</span><br><span class="line">GdtPtr64    dw  GdtLen64 - 1</span><br><span class="line">            dd  LABEL_GDT64</span><br><span class="line">SelectorCode64  equ LABEL_DESC_CODE64 - LABEL_GDT64</span><br><span class="line">SelectorData64  equ LABEL_DESC_DATA64 - LABEL_GDT64</span><br></pre></td></tr></tbody></table></figure><p>这里的转存空间只是临时用，用完可以另作他用了</p><h2 id="1-2-BITS伪指令"><a href="#1-2-BITS伪指令" class="headerlink" title="1.2 BITS伪指令"></a>1.2 BITS伪指令</h2><p>此处追加定义了一个名为<code>.s16</code>的段，BITS伪指令可以通知NASM编译器生成的代码，将运行在16位或32位的处理器上，语法是<code>BITS 16</code>或<code>BITS 32</code></p><p>当NASM编译器处于16位下，使用32位数据指令需要在指令前加前缀<code>0x66</code>，使用32位地址指令时需要在指令前加入前缀<code>0x67</code>。而在32位下，使用16位指令也需要加指令前缀</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s16]  ; 定义一个名为 .s16 的段</span><br><span class="line">[BITS 16]  ; 通知NASM编译器生成的代码将运行在16位宽的处理器上</span><br><span class="line">Label_Start:</span><br><span class="line">    mov ax, cs</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, 0x7c00</span><br><span class="line"></span><br><span class="line">;=======    display on screen : Start Loader......</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000fh</span><br><span class="line">    mov dx, 0200h       ;row 2</span><br><span class="line">    mov cx, 12</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartLoaderMessage</span><br><span class="line">    int 10h  ; 屏幕上输出"Start Loader"</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3-打开A20功能"><a href="#1-3-打开A20功能" class="headerlink" title="1.3 打开A20功能"></a>1.3 打开A20功能</h2><p>这个在第0天提到了，就是A20M# pin，参考Intel manual volume 3 chapter 8.7.13.4。</p><blockquote><p><strong>A20M# pin</strong> — On an IA-32 processor, the A20M# pin is typically provided for compatibility with the Intel 286 processor. Asserting this pin causes bit 20 of the physical address to be masked (forced to zero) for all external bus memory accesses. Processors supporting Intel Hyper-Threading Technology provide one A20M# pin, which affects the operation of both logical processors within the physical processor.<br>The functionality of A20M# is used primarily by older operating systems and not used by modern operating systems. On newer Intel 64 processors, A20M# may be absent.</p></blockquote><p>意思就是历史原因，最初处理器只有20根地址线，使得处理器只能寻址1MB以内物理地址空间，但是现在的处理器已经远超20位地址线了，但是为了兼容，出现了开启或禁止1MB以上地址空间开关(也就是只用20根地址线，还是用更多)。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;=======    open address A20</span><br><span class="line">    push ax</span><br><span class="line">    in  al, 92h  ; 从92端口读入A20地址线的状态</span><br><span class="line">    or  al, 00000010b  ; 将第2位置1</span><br><span class="line">    out 92h, al  ; 写回92号端口 打开A20</span><br><span class="line">    pop ax</span><br><span class="line">    cli  ; 关中断 因为保护模式下中断处理的机制不同，不关中断会出现错误</span><br><span class="line">    db  0x66  ; 声明在16位情况下使用32位宽数据指令</span><br><span class="line">    ; 加载到gdtr，因为现在段描述符表在内存中，我们必须要让CPU知道段描述符表在哪个位置</span><br><span class="line">    ; 通过使用lgdt就可以将源加载到gdtr寄存器中</span><br><span class="line">    lgdt [GdtPtr]</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or  eax, 1</span><br><span class="line">    mov cr0, eax  ; 这3句将寄存器CR0的第0位置1开启保护模式</span><br><span class="line">    mov ax, SelectorData32</span><br><span class="line">    mov fs, ax  ; 这2句 将数据段的选择子加载到FS段寄存器</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    and al, 11111110b</span><br><span class="line">    mov cr0, eax  ; 这3句 将cr0的bit0置0，也就是关掉保护模式，重新进入实模式</span><br><span class="line">    sti  ; 与cli对应，恢复外部中断</span><br><span class="line">;=======    reset floppy</span><br><span class="line">    xor ah, ah</span><br><span class="line">    xor dl, dl</span><br><span class="line">    int 13h  ; 重置软盘</span><br></pre></td></tr></tbody></table></figure><p>开启A20功能可以通过键盘(8042键盘控制器上恰好有空闲的端口引脚，输出端口P2，引脚P21)，但是键盘是低速设备，开启较慢。所以<strong>可以使用A20快速门，使用IO端口0x92处理A20信号线(注意0x92的0位用于向机器发送复位信号，置位会导致重启)</strong>。还可以通过BIOS中断程序INT 15h主功能号AX=2401可开启A20地址线，功能号AX=2400可禁用A20地址线，功能号AX=2403可查询A20地址线当前状态。还有一种方法是通过读0xee端口来开启A20信号线，写该端口则会禁止。</p><p>当进入保护模式后，为FS段加载新的数据段值，一旦完成数据段加载就从保护模式退出，并开启外部中断，目的是为了让FS段寄存器可以在实模式下寻址能力超过1MB(扩展到32位4GB)，可以借助FS段寄存器的特殊寻址能力将内核程序转移到1MB以上的内存地址空间中。注意，在物理平台下，当段寄存器拥有这种特殊能力之后，如果对其重新赋值就会失去特殊能力，转变成原始的实模式段寄存器</p><h2 id="1-4-寻找kernel-bin"><a href="#1-4-寻找kernel-bin" class="headerlink" title="1.4 寻找kernel.bin"></a>1.4 寻找kernel.bin</h2><p>这段内容与<code>boot.asm</code>中找<code>loader.bin</code>类似</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">;=======    search kernel.bin</span><br><span class="line">    mov word [SectorNo], SectorNumOfRootDirStart  ; 依旧是从第19个扇区开始</span><br><span class="line">Lable_Search_In_Root_Dir_Begin:</span><br><span class="line">    cmp word [RootDirSizeForLoop], 0  ; RootDirSizeForLoop初始值为根目录扇区数 每找完一个扇区就-- 若等于0表示没找到</span><br><span class="line">    jz  Label_No_LoaderBin  ; 找不到就跳到Label_No_LoaderBin</span><br><span class="line">    dec word [RootDirSizeForLoop]  ; RootDirSizeForLoop--</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov es, ax  ; 不能通过立即数给es赋值，需要通过ax中转一下 es=00H</span><br><span class="line">    mov bx, 8000h  ; bx=8000H</span><br><span class="line">    mov ax, [SectorNo]  ; ax=19</span><br><span class="line">    mov cl, 1  ; cl=1</span><br><span class="line">    call Func_ReadOneSector  ; 调用Func_ReadOneSector 读取一个扇区的内容到bx开始的内存地址</span><br><span class="line">    mov si, KernelFileName  ; 将文件名"kernel.bin"加载到ds:si中</span><br><span class="line">    mov di, 8000h  ; 将es:di指向扇区内容起始地址</span><br><span class="line">    cld  ; 清除EFLAGS.DF置0，这样通过LODSB从ds:si加载内容到al后，si就会递增1</span><br><span class="line">    mov dx, 10h  ; dx记录一个扇区可容纳的目录项个数。一个扇区最多有512B/32B=16=0x10个目录项</span><br><span class="line"></span><br><span class="line">Label_Search_For_LoaderBin:</span><br><span class="line">    cmp dx, 0</span><br><span class="line">    jz  Label_Goto_Next_Sector_In_Root_Dir</span><br><span class="line">    dec dx  ; 上面三句就是一个扇区所有目录项都找完了 可以去下一个扇区找了</span><br><span class="line">    mov cx, 11  ; 文件名的长度11B 包括文件名和扩展名 但不包括分隔符"."</span><br><span class="line"></span><br><span class="line">Label_Cmp_FileName:</span><br><span class="line">    cmp cx, 0  ; 文件名都比较完了 都相等 那当然就是找到了 跳到Label_FileName_Found</span><br><span class="line">    jz  Label_FileName_Found</span><br><span class="line">    dec cx</span><br><span class="line">    lodsb  ; 从ds:si读取一个字节到寄存器AL 然后si+=1(取决于EFLAGS.DF)</span><br><span class="line">    cmp al, byte [es:di]  ; 一个字符一个字符去比较</span><br><span class="line">    jz  Label_Go_On  ; 如果相等 继续</span><br><span class="line">    jmp Label_Different  ; 如果不相等</span><br><span class="line"></span><br><span class="line">Label_Go_On:</span><br><span class="line">    inc di  ; di++</span><br><span class="line">    jmp Label_Cmp_FileName</span><br><span class="line"></span><br><span class="line">Label_Different:</span><br><span class="line">    and di, 0FFE0h</span><br><span class="line">    add di, 20h</span><br><span class="line">    mov si, KernelFileName</span><br><span class="line">    jmp Label_Search_For_LoaderBin</span><br><span class="line"></span><br><span class="line">Label_Goto_Next_Sector_In_Root_Dir:</span><br><span class="line">    add word    [SectorNo], 1</span><br><span class="line">    jmp Lable_Search_In_Root_Dir_Begin</span><br><span class="line">    </span><br><span class="line">;=======    display on screen : ERROR:No KERNEL Found</span><br><span class="line">Label_No_LoaderBin:  ; 没找到kernel.bin就会跳到这，结束</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0300h       ; row 3</span><br><span class="line">    mov cx, 21</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, NoLoaderMessage  ; 屏幕上输出"ERROR:No KERNEL Found"</span><br><span class="line">    int 10h</span><br><span class="line">    jmp $</span><br></pre></td></tr></tbody></table></figure><h2 id="1-5-加载kernel-bin"><a href="#1-5-加载kernel-bin" class="headerlink" title="1.5 加载kernel.bin"></a>1.5 加载kernel.bin</h2><p>找到<code>kernel.bin</code>，就将其读到内存中，与<code>boot.asm</code>找到<code>loader.bin</code>后的操作差不多，只是这里更加曲折一点，是先读取到0x7e00~0x7fff这段中，再通过FS段寄存器挪到0x100000之上的物理内存空间。但是这里段寄存器被重新赋值了，导致在实际物理平台上会出问题，书上说第7章再解决这个问题..</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">;=======    found kernel.bin name in root director struct</span><br><span class="line">Label_FileName_Found:  ; 找到了kernel.bin就到这..</span><br><span class="line">    mov ax, RootDirSectors</span><br><span class="line">    and di, 0FFE0h</span><br><span class="line">    add di, 01Ah</span><br><span class="line">    mov cx, word [es:di]</span><br><span class="line">    push cx</span><br><span class="line">    add cx, ax</span><br><span class="line">    add cx, SectorBalance  ; 得到实际起始扇区号</span><br><span class="line">    mov eax, BaseTmpOfKernelAddr ; eax=00H</span><br><span class="line">    mov es, eax</span><br><span class="line">    mov bx, OffsetTmpOfKernelFile   ; bx=7E00H</span><br><span class="line">    mov ax, cx  ; 将存储文件实际扇区号放到ax中</span><br><span class="line"></span><br><span class="line">Label_Go_On_Loading_File:</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    mov ah, 0Eh</span><br><span class="line">    mov al, '.'</span><br><span class="line">    mov bl, 0Fh</span><br><span class="line">    int 10h  ; 每读一个扇区就在屏幕上打印一个 .</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    mov cl, 1</span><br><span class="line">    call Func_ReadOneSector  ; 将一个扇区的内容读到0x7E00~0x7FF这段内存中</span><br><span class="line">    pop ax</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">    push cx</span><br><span class="line">    push eax</span><br><span class="line">    push fs</span><br><span class="line">    push edi</span><br><span class="line">    push ds</span><br><span class="line">    push esi</span><br><span class="line"></span><br><span class="line">    mov cx, 200h  ; 200h = 512</span><br><span class="line">    mov ax, BaseOfKernelFile  ; 00H</span><br><span class="line">    mov fs, ax</span><br><span class="line">    ; 目的地址 fs:edi = 0x00:0x100000，此处使用了FS段寄存器的超能力，它可以寻址到4G</span><br><span class="line">    mov edi, dword [OffsetOfKernelFileCount]  ; OffsetOfKernelFile 0x100000</span><br><span class="line">    mov ax, BaseTmpOfKernelAddr  ; 00H</span><br><span class="line">    mov ds, ax</span><br><span class="line">    ; 源地址 ds:esi = 0x00:0x7e00</span><br><span class="line">    mov esi, OffsetTmpOfKernelFile  ; 7E00H</span><br><span class="line"></span><br><span class="line">Label_Mov_Kernel:</span><br><span class="line">    ; 一个字节一个字节将0x7e00之后的512字节东西挪到0x100000</span><br><span class="line">    mov al, byte [ds:esi]</span><br><span class="line">    mov byte [fs:edi], al</span><br><span class="line">    inc esi</span><br><span class="line">    inc edi</span><br><span class="line">    loop Label_Mov_Kernel  ; 执行loop指令前，先要将cx--，若cx不为0则跳到Label_Mov_Kernel</span><br><span class="line"></span><br><span class="line">    mov eax, 0x1000  ; loader.bin起始于内存地址0x1000:0x00</span><br><span class="line">    mov ds, eax</span><br><span class="line">    ; 每移动512字节内容后，保存新的内存地址到内存OffsetOfKernelFileCount字段处</span><br><span class="line">    mov dword [OffsetOfKernelFileCount],  edi</span><br><span class="line"></span><br><span class="line">    pop esi</span><br><span class="line">    pop ds</span><br><span class="line">    pop edi</span><br><span class="line">    pop fs</span><br><span class="line">    pop eax</span><br><span class="line">    pop cx</span><br><span class="line">;;;;;;;;;;;;;;;;;;;;;;;</span><br><span class="line">    call    Func_GetFATEntry</span><br><span class="line">    cmp ax, 0FFFh  ; 直到读到文件尾</span><br><span class="line">    jz  Label_File_Loaded  ; 文件已加载..</span><br><span class="line">    push ax</span><br><span class="line">    mov dx, RootDirSectors</span><br><span class="line">    add ax, dx</span><br><span class="line">    add ax, SectorBalance</span><br><span class="line">    jmp Label_Go_On_Loading_File  ; 继续下一个扇区</span><br></pre></td></tr></tbody></table></figure><h2 id="1-6-加载完毕"><a href="#1-6-加载完毕" class="headerlink" title="1.6 加载完毕"></a>1.6 加载完毕</h2><p>加载完毕后会在屏幕上打印一个字符<code>G</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Label_File_Loaded:</span><br><span class="line">    mov ax, 0B800h</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ah, 0Fh             ; 0000: 黑底    1111: 白字</span><br><span class="line">    ; 将’G’这个字符放到了内存中gs:((80 * 0 + 39) * 2)的这个地方，这个gs在这里是0B800h以这里为起点，向后偏移一段区域的内存专门用于存储在屏幕上显示的字，每个字占位两个字节，每行最多显示80个字符，所以就有上面的公式：((80 * 0 + 39) * 2)这表示第0行的39列显示该字符</span><br><span class="line">    mov al, 'G'</span><br><span class="line">    mov [gs:((80 * 0 + 39) * 2)], ax    ; 屏幕第 0 行, 第 39 列。</span><br><span class="line"></span><br><span class="line">; 当Loader引导加载程序完成内核程序的加载工作后，软盘驱动器将不再使用</span><br><span class="line">KillMotor:  ; 关闭全部软盘驱动器</span><br><span class="line">    push dx</span><br><span class="line">    mov dx, 03F2h</span><br><span class="line">    mov al, 0</span><br><span class="line">    out dx, al</span><br><span class="line">    pop dx</span><br></pre></td></tr></tbody></table></figure><p>这段代码首先将GS段寄存器的基地址设置在0B800H地址处；并将AH寄存器赋值为0FH，表示黑底白字；将AL寄存器赋值为字母’G’，要打印的字符；然后将AX寄存器的值填充到0B800H向后偏移$(80\times 0+39)\times2$处，每个字符占2个字节，每行最多显示80个字符，所以就是0行39列显示’G’。<strong>从内存地址0B800H开始，是一段专门用于显示字符的内存空间，其中每个字符占用两个字节的内存空间，低字节保存显示的字符，高字节保存字符的颜色属性</strong>。该方法相比于INT 10H中断相比更符合操作显卡内存的习惯，后面会通过像素内存在屏幕上作画或播放视频。</p><p>I/O端口3F2H控制着软盘驱动器不少硬件功能</p><div class="table-container"><table><thead><tr><th>位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>7</td><td>MOT_EN3</td><td>控制软驱D马达，1：启动；0：关闭</td></tr><tr><td>6</td><td>MOT_EN2</td><td>控制软驱C</td></tr><tr><td>5</td><td>MOT_EN1</td><td>控制软驱B</td></tr><tr><td>4</td><td>MOT_EN0</td><td>控制软驱A</td></tr><tr><td>3</td><td>DMA_INT</td><td>1：允许DMA和中断请求；0：禁止DMA和中断请求</td></tr><tr><td>2</td><td>RESET</td><td>1：允许软盘控制器发送控制信息；0：复位软盘驱动器</td></tr><tr><td>1</td><td>DRV_SEL1</td><td>00~11用于选择软盘驱动器A~D</td></tr><tr><td>0</td><td>DRV_SEL0</td><td>同上</td></tr></tbody></table></div><h2 id="1-7-获取内存信息"><a href="#1-7-获取内存信息" class="headerlink" title="1.7 获取内存信息"></a>1.7 获取内存信息</h2><p>当内核程序不再借助临时转存空间后，这块临时转存空间将用于保存物理内存地址空间信息</p><p>物理地址空间信息由一个结构体数组构成，计算机平台地址划分情况都能从这个结构体数组成反映出来，它记录的地址空间类型包括可用物理内存地址空间、设备寄存器地址空间、内存空洞等。系统会在初始化内存管理单元时解析该结构数组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">;=======    get memory address size type</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0400h       ;row 4</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetMemStructMessage</span><br><span class="line">    int 10h  ; 打印 "Start Get Memory Struct."</span><br><span class="line"></span><br><span class="line">    ; 当内核程序不再借助临时转存空间后，这块临时转存空间 0x7E00~0x7FFF将用于保存物理地址空间信息</span><br><span class="line">    mov ebx, 0  ; 指向内存区域，第一次调用时ebx=0，被称为continuation value</span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov di, MemoryStructBufferAddr  ; 设置填充地址es:di=0x00:0x7e00</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_Struct:</span><br><span class="line">    mov eax, 0x0E820  ; 功能号</span><br><span class="line">    mov ecx, 20       ; 固定读取20字节</span><br><span class="line">    mov edx, 0x534D4150  ; 固定值SMAP</span><br><span class="line">    int 15h  ; 使用INT 15H来获取物理地址空间信息</span><br><span class="line">    jc  Label_Get_Mem_Fail  ; 没有进位表示读取成功</span><br><span class="line"></span><br><span class="line">    add di, 20  ; 推进填充地址</span><br><span class="line">    cmp ebx, 0  ; 输出时，ebx表示下一个内存区域，当ebx=0 &amp;&amp; CF=0时，表示当前是内存最后一个区域</span><br><span class="line">    jne Label_Get_Mem_Struct  ; 循环读取</span><br><span class="line">    jmp Label_Get_Mem_OK</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_Fail:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0500h       ;row 5</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetMemStructErrMessage</span><br><span class="line">    int 10h  ; 输出 Get Memory Struct ERROR</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">Label_Get_Mem_OK:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0600h       ;row 6</span><br><span class="line">    mov cx, 29</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetMemStructOKMessage</span><br><span class="line">    int 10h ; 输出 Get Memory Struct SUCCESSFUL!</span><br></pre></td></tr></tbody></table></figure><p>INT 15H：每执行一次这个指令将会将一个描述内存区域的数据结构保存到<code>ES:DI</code>，然后返回一个ebx，用于确定下一个能够探测的内存区域，当ebx=0时，表示当前已经时最后一个内存区域了。那么ebx的初始值呢，就是设置成ebx=0。其中可能遇到检查发生错误的情况，这个指令就会直接将CF设置为1。</p><p>输入时各个寄存器作用：</p><div class="table-container"><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td>eax</td><td>功能码，当输入e820h时能够探测内存</td></tr><tr><td>ebx</td><td>主要用于指向内存区域，第一次调用时ebx=0，被称为continuation value</td></tr><tr><td>es:di</td><td>用于指令执行后，在指向的内存写入描述内存区域的数据结构ARDS(Address Range Descriptor Structure)</td></tr><tr><td>ecx</td><td>用于限制指令填充的ARDS的大小，实际上大多数情况这个是无效的，无论ecx设置为多少，BIOS始终会填充20字节的ARDS</td></tr><tr><td>edx</td><td>0534D4150h，表示4个ASCII字符(‘SMAP’)，只是个签名，输入时在edx，输出时将会在eax中</td></tr></tbody></table></div><p>输出时各个寄存器结果:</p><div class="table-container"><table><thead><tr><th>寄存器</th><th>结果</th></tr></thead><tbody><tr><td>CF</td><td>当没有发生错误时，CF=0，否则CF=1</td></tr><tr><td>eax</td><td>0534D4150h</td></tr><tr><td>ebx</td><td>指向下一个内存区域，而不是调用之前的内存区域，当ebx=0且CF=0时，表示当前是最后一个内存区域。</td></tr><tr><td>es:di</td><td>和调用之前一样，如果要保存多个ARDS，需要手动修改es:di</td></tr><tr><td>ecx</td><td>返回写入的ARDS的大小</td></tr></tbody></table></div><p>看一下Linux对E820H的定义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bionic/libc/kernel/uapi/asm-x86/asm/e820.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820entry</span> {</span></span><br><span class="line">    __u64 addr; <span class="comment">/* start of memory segment */</span></span><br><span class="line">    __u64 size; <span class="comment">/* size of memory segment */</span></span><br><span class="line">    __u32 type; <span class="comment">/* type of memory segment 能被OS使用的；保留的(不能被OS使用的)*/</span></span><br><span class="line">} __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> {</span></span><br><span class="line">    __u32 nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820entry</span> <span class="title">map</span>[<span class="title">E820_X_MAX</span>];</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>BIOS查找出一个一个的内存布局entry，并放入到一个保存地址范围描述符结构的缓冲区中</p><h2 id="1-8-获取SVGA信息"><a href="#1-8-获取SVGA信息" class="headerlink" title="1.8 获取SVGA信息"></a>1.8 获取SVGA信息</h2><p>这一段并不重要..</p><p>获取SVGA(Super Video Graphics Array) VBE相关信息，这玩意不百度不知道，一百度，tmd又是一门难搞的技术..参考《最新VESA SVGA图形图像编程秘技》</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">;=======    get SVGA information</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0800h       ;row 8</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetSVGAVBEInfoMessage</span><br><span class="line">    int 10h</span><br><span class="line"></span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov di, 0x8000  ; 指向存放VbeInfoBlock结构体的缓冲区指针</span><br><span class="line">    mov ax, 4F00h  ; 返回VBE控制器信息</span><br><span class="line">    int 10h</span><br><span class="line">    cmp ax, 004Fh  ; VBE返回状态</span><br><span class="line">    jz  .KO</span><br><span class="line"></span><br><span class="line">;=======    Fail</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0900h       ;row 9</span><br><span class="line">    mov cx, 23</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAVBEInfoErrMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA VBE Info ERROR"</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">.KO:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0A00h       ;row 10</span><br><span class="line">    mov cx, 29</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAVBEInfoOKMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA VBE Info SUCCESSFUL!"</span><br></pre></td></tr></tbody></table></figure><p>VBE功能调用的共同点：</p><p>AH必须等于4F，表示是VBE标准；</p><p>AL是VBE功能号，其中$0\le AL \le 0BH$；</p><p>BL等于子功能号，可以没有子功能；</p><p>调用INT 10H；</p><p>返回值。</p><p>VBE功能调用返回值一般均在AX中：</p><p>$AL = 4FH$：支持该功能；</p><p>$AL \ne 4FH$：不支持该功能；</p><p>$AH = 00H$：功能调用成功；</p><p>$AH=01H$：功能调用失败；</p><p>$AH=02H$：当前硬件配置不支持该功能；</p><p>$AH=03H$：当前显示模式不支持该功能</p><p>这里使用的就是INT 10H AH=00H：返回VBE信息</p><p>输入：</p><p>AX=4F00H</p><p>ES:DI=指向VBE信息块的指针</p><p>输出：</p><p>AX=VBE返回值</p><p>其中VbeInfoBlock的定义参考Linux，<strong>VBE 1.x版本的信息块大小为256B；VBE 2.0+及后续版本VbeInfoBlock大小为512B</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/drivers/gpu/drm/radeon/atombios.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_INFO_BLOCK</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VBE_VERSION_UNION           UpdatableVBE_Info;</span><br><span class="line">    UCHAR                       Reserved[<span class="number">222</span>];  <span class="comment">// 保留</span></span><br><span class="line">    UCHAR                       OemData[<span class="number">256</span>];   <span class="comment">// VESA2.0版以上定义</span></span><br><span class="line">} VBE_INFO_BLOCK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _VBE_VERSION_UNION</span><br><span class="line">{</span><br><span class="line">    VBE_2_0_INFO_BLOCK_UPDATABLE    VBE_2_0_InfoBlock;</span><br><span class="line">    VBE_1_2_INFO_BLOCK_UPDATABLE    VBE_1_2_InfoBlock;</span><br><span class="line">} VBE_VERSION_UNION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_2_0_INFO_BLOCK_UPDATABLE</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VBE_1_2_INFO_BLOCK_UPDATABLE CommonBlock;</span><br><span class="line">    USHORT                       OemSoftRev;  <span class="comment">// VBE软件的OEM修订版本号，BCD码</span></span><br><span class="line">    PTR_32_BIT_UNION             OemVendorNamePtr;  <span class="comment">// 指向显示卡制造厂商的字符串指针</span></span><br><span class="line">    PTR_32_BIT_UNION             OemProductNamePtr;  <span class="comment">// 指向显示卡制造商的字符串的指针</span></span><br><span class="line">    PTR_32_BIT_UNION   OemProductRevPtr;  <span class="comment">// 指向显示卡修订版本号或唱片等级的字符串的指针</span></span><br><span class="line">} VBE_2_0_INFO_BLOCK_UPDATABLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VBE_1_2_INFO_BLOCK_UPDATABLE</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    UCHAR               VbeSignature[<span class="number">4</span>];  <span class="comment">// 字符串"VESA"  offset:0</span></span><br><span class="line">    USHORT              VbeVersion;       <span class="comment">// VBE版本号，BCD码  offset:4</span></span><br><span class="line">    PTR_32_BIT_UNION    OemStringPtr;     <span class="comment">// 指向OEM厂商的标志串的指针  offset:6</span></span><br><span class="line">    UCHAR               Capabilities[<span class="number">4</span>];  <span class="comment">// 显示卡特性  offset:10</span></span><br><span class="line">    PTR_32_BIT_UNION    VideoModePtr;     <span class="comment">// 指向所支持显示模式列表的指针  offset:14</span></span><br><span class="line">    USHORT              TotalMemory;      <span class="comment">// 显示内存大小，单位为64KB</span></span><br><span class="line">} VBE_1_2_INFO_BLOCK_UPDATABLE;</span><br></pre></td></tr></tbody></table></figure><h2 id="1-9-输出SVGA信息"><a href="#1-9-输出SVGA信息" class="headerlink" title="1.9 输出SVGA信息"></a>1.9 输出SVGA信息</h2><p>上面只是获取到了VBE信息，完了还得打印出来了呢</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">;=======    Get SVGA Mode Info</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0C00h       ;row 12</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartGetSVGAModeInfoMessage</span><br><span class="line">    int 10h  ; 输出 "Start Get SVGA Mode Info"</span><br><span class="line"></span><br><span class="line">    mov ax, 0x00</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov si, 0x800e  ; es:si=0x0000:0x800e</span><br><span class="line">    mov esi, dword [es:si]  ; 取出指针存入esi</span><br><span class="line">    mov edi, 0x8200  ; es:di=0x0000:0x8200</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_Get:  ; 循环获取所有的svga_mode_info</span><br><span class="line">    mov cx, word [es:esi]</span><br><span class="line">;=======    display SVGA mode information</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov al, ch</span><br><span class="line">    call Label_DispAL  ; 显示16进制数值在屏幕上 后面再看</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov al, cl</span><br><span class="line">    call Label_DispAL</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    cmp cx, 0FFFFh  ; 如果是最后要给word则跳到Finish</span><br><span class="line">    jz  Label_SVGA_Mode_Info_Finish</span><br><span class="line"></span><br><span class="line">    mov ax, 4F01h</span><br><span class="line">    int 10h  ; 4F01H显示特定模式信息，获取成功则向ES:DI填充256字节</span><br><span class="line"></span><br><span class="line">    cmp ax, 004Fh</span><br><span class="line">    jnz Label_SVGA_Mode_Info_FAIL   </span><br><span class="line">    add esi, 2  ; 获取list中下一个word</span><br><span class="line">    add edi, 0x100  ; 刚填充了256字节，继续前进256字节</span><br><span class="line">    jmp Label_SVGA_Mode_Info_Get</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_FAIL:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008Ch</span><br><span class="line">    mov dx, 0D00h       ;row 13</span><br><span class="line">    mov cx, 24</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAModeInfoErrMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA Mode Info ERROR"</span><br><span class="line"></span><br><span class="line">Label_SET_SVGA_Mode_VESA_VBE_FAIL:</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">Label_SVGA_Mode_Info_Finish:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000Fh</span><br><span class="line">    mov dx, 0E00h       ;row 14</span><br><span class="line">    mov cx, 30</span><br><span class="line">    push ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, GetSVGAModeInfoOKMessage</span><br><span class="line">    int 10h  ; 输出 "Get SVGA Mode Info SUCCESSFUL!"</span><br></pre></td></tr></tbody></table></figure><p><strong>问题1：为什么是0x800e？为什么是dword？为什么从0x8200开始？</strong></p><p>因为VideoModePtr在VBE_INFO_BLOCK的偏移就是14，就是e；VideoModePtr大小是4B；因为VBE 2.0+版本之后的VbeInfoBlock大小是512B，所以还是往后挪256B稳妥点</p><p><strong>问题2：INT 10H AX=4F10H</strong></p><p>这个功能号的作用是返回VBE特定模式信息</p><p>输入：</p><p>AX=4F01H</p><p>CX=模式号</p><p>ES:DI=指向VBE特定模式信息块的指针</p><p>输出：</p><p>AX=VBE返回值</p><p>其中特定模式信息块数据结构如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common/drivers/gpu/drm/radeon/atombios.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">VESA_MODE_INFO_BLOCK</span></span></span><br><span class="line"><span class="class">{</span>  <span class="comment">// 共256B</span></span><br><span class="line"><span class="comment">// Mandatory information for all VBE revisions</span></span><br><span class="line">    USHORT ModeAttributes;  <span class="comment">// dw  ?   ; mode attributes</span></span><br><span class="line">    UCHAR  WinAAttributes;  <span class="comment">// db  ?   ; window A attributes</span></span><br><span class="line">    UCHAR  WinBAttributes;  <span class="comment">// db  ?   ; window B attributes</span></span><br><span class="line">    USHORT WinGranularity;  <span class="comment">// dw  ?   ; window granularity</span></span><br><span class="line">    USHORT WinSize;         <span class="comment">// dw  ?   ; window size</span></span><br><span class="line">    USHORT WinASegment;     <span class="comment">// dw  ?   ; window A start segment</span></span><br><span class="line">    USHORT WinBSegment;     <span class="comment">// dw  ?   ; window B start segment</span></span><br><span class="line">    ULONG  WinFuncPtr;      <span class="comment">// dd  ?   ; real mode pointer to window function</span></span><br><span class="line">    USHORT BytesPerScanLine;<span class="comment">// dw  ?   ; bytes per scan line</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 1.2 and above</span></span><br><span class="line">    USHORT XResolution;      <span class="comment">// dw  ?   ; horizontal resolution in pixels or characters</span></span><br><span class="line">    USHORT YResolution;      <span class="comment">// dw  ?   ; vertical resolution in pixels or characters</span></span><br><span class="line">    UCHAR  XCharSize;        <span class="comment">// db  ?   ; character cell width in pixels</span></span><br><span class="line">    UCHAR  YCharSize;        <span class="comment">// db  ?   ; character cell height in pixels</span></span><br><span class="line">    UCHAR  NumberOfPlanes;   <span class="comment">// db  ?   ; number of memory planes</span></span><br><span class="line">    UCHAR  BitsPerPixel;     <span class="comment">// db  ?   ; bits per pixel</span></span><br><span class="line">    UCHAR  NumberOfBanks;    <span class="comment">// db  ?   ; number of banks</span></span><br><span class="line">    UCHAR  MemoryModel;      <span class="comment">// db  ?   ; memory model type</span></span><br><span class="line">    UCHAR  BankSize;         <span class="comment">// db  ?   ; bank size in KB</span></span><br><span class="line">    UCHAR  NumberOfImagePages;<span class="comment">// db    ?   ; number of images</span></span><br><span class="line">    UCHAR  ReservedForPageFunction;<span class="comment">//db  1   ; reserved for page function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Direct Color fields(required for direct/6 and YUV/7 memory models)</span></span><br><span class="line">    UCHAR  RedMaskSize; <span class="comment">// db ? ; size of direct color red mask in bits</span></span><br><span class="line">    UCHAR  RedFieldPosition; <span class="comment">// db ? ; bit position of lsb of red mask</span></span><br><span class="line">    UCHAR  GreenMaskSize; <span class="comment">// db ? ; size of direct color green mask in bits</span></span><br><span class="line">    UCHAR  GreenFieldPosition; <span class="comment">// db  ? ; bit position of lsb of green mask</span></span><br><span class="line">    UCHAR  BlueMaskSize; <span class="comment">// db  ? ; size of direct color blue mask in bits</span></span><br><span class="line">    UCHAR  BlueFieldPosition; <span class="comment">// db  ? ; bit position of lsb of blue mask</span></span><br><span class="line">    UCHAR  RsvdMaskSize; <span class="comment">// db ? ; size of direct color reserved mask in bits</span></span><br><span class="line">    UCHAR  RsvdFieldPosition;  <span class="comment">// db ? ; bit position of lsb of reserved mask</span></span><br><span class="line">    UCHAR  DirectColorModeInfo;  <span class="comment">// db ? ; direct color mode attributes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 2.0 and above</span></span><br><span class="line">    ULONG  PhysBasePtr; <span class="comment">// dd ? ; physical address for flat memory frame buffer</span></span><br><span class="line">    ULONG  Reserved_1; <span class="comment">// dd 0 ; reserved - always set to 0</span></span><br><span class="line">    USHORT Reserved_2; <span class="comment">// dw 0 ; reserved - always set to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//; Mandatory information for VBE 3.0 and above</span></span><br><span class="line">    USHORT LinBytesPerScanLine;  <span class="comment">// dw ? ; bytes per scan line for linear modes</span></span><br><span class="line">    UCHAR  BnkNumberOfImagePages;<span class="comment">// db ? ; number of images for banked modes</span></span><br><span class="line">    UCHAR  LinNumberOfImagPages; <span class="comment">// db ? ; number of images for linear modes</span></span><br><span class="line">    UCHAR  LinRedMaskSize; <span class="comment">// db ? ; size of direct color red mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRedFieldPosition;  <span class="comment">// db ? ; bit position of lsb of red mask(linear modes)</span></span><br><span class="line">    UCHAR  LinGreenMaskSize;  <span class="comment">// db ? ; size of direct color green mask(linear modes)</span></span><br><span class="line">    UCHAR  LinGreenFieldPosition;<span class="comment">// db ? ; bit position of lsb of green mask(linear modes)</span></span><br><span class="line">    UCHAR  LinBlueMaskSize; <span class="comment">// db ? ; size of direct color blue mask(linear modes)</span></span><br><span class="line">    UCHAR  LinBlueFieldPosition; <span class="comment">// db ? ; bit position of lsb of blue mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRsvdMaskSize;  <span class="comment">// db ? ; size of direct color reserved mask(linear modes)</span></span><br><span class="line">    UCHAR  LinRsvdFieldPosition; <span class="comment">// db  ?   ; bit position of lsb of reserved mask(linear modes)</span></span><br><span class="line">    ULONG  MaxPixelClock;   <span class="comment">// dd  ?   ; maximum pixel clock(in Hz) for graphics mode</span></span><br><span class="line">    UCHAR  Reserved;        <span class="comment">// db  190 dup (0)</span></span><br><span class="line">} VESA_MODE_INFO_BLOCK;</span><br></pre></td></tr></tbody></table></figure><p>至于每个属性啥意思，这就不列了，《最新VESA SVGA图形图像编程秘技》这本书上有..当然了《64位》这本书第7章也有说</p><p><strong>问题3：Label_DispAL作用</strong></p><p>这是放在后面的一段辅助函数，作用是将16进制数值显示在屏幕上，原理和Label_File_Loaded一样</p><p>输入：</p><p>AL=要显示的十六进制数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;=======    display num in al</span><br><span class="line">Label_DispAL:</span><br><span class="line">    push    ecx</span><br><span class="line">    push    edx</span><br><span class="line">    push    edi</span><br><span class="line"></span><br><span class="line">    mov edi, [DisplayPosition]  ; 字符的屏幕偏移量 初始值是0</span><br><span class="line">    mov ah, 0Fh  ; 字符属性 黑底白字</span><br><span class="line">    mov dl, al  ; 保存字符值到dl</span><br><span class="line">    shr al, 4  ; 右移4位 取字符高位</span><br><span class="line">    mov ecx, 2  ; 计算高位一次 计算低位一次 一共要loop两次</span><br><span class="line">.begin:</span><br><span class="line">    and al, 0Fh</span><br><span class="line">    cmp al, 9  ; 这里实际上比较的是高4位 右移了</span><br><span class="line">    ja  .1  ; 如果大于9直接跳到 .1</span><br><span class="line">    add al, '0'  ; 如果小于或等于9 与字符'0'相加</span><br><span class="line">    jmp .2</span><br><span class="line">.1:</span><br><span class="line">    sub al, 0Ah  ; 先减去 0AH</span><br><span class="line">    add al, 'A'  ; 再加上 字符'A'</span><br><span class="line">.2:</span><br><span class="line">    mov [gs:edi], ax  ; 将AX保存到gs为基址，DisplayPosition为偏移的显示字符内存空间中</span><br><span class="line">    add edi, 2  ; 下一个字符</span><br><span class="line"></span><br><span class="line">    mov al, dl</span><br><span class="line">    loop .begin</span><br><span class="line">    mov [DisplayPosition], edi  ; 保存字符偏移量到内存</span><br><span class="line"></span><br><span class="line">    pop edi</span><br><span class="line">    pop edx</span><br><span class="line">    pop ecx</span><br><span class="line">    ret</span><br></pre></td></tr></tbody></table></figure><h2 id="1-10-设置SVGA模式"><a href="#1-10-设置SVGA模式" class="headerlink" title="1.10 设置SVGA模式"></a>1.10 设置SVGA模式</h2><p>根据查询的信息配置芯片显示模式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;=======    set the SVGA mode(VESA VBE)</span><br><span class="line">    mov ax, 4F02h</span><br><span class="line">    mov bx, 4180h ; mode: 0x180 or 0x143</span><br><span class="line">    int 10h</span><br><span class="line">    cmp ax, 004Fh</span><br><span class="line">    jnz Label_SET_SVGA_Mode_VESA_VBE_FAIL</span><br></pre></td></tr></tbody></table></figure><p>INT 10H AX=4F02H，设置VESA VBE模式</p><p>输入：</p><p>AX=4F02H</p><p>BX=模式号</p><p>输出：</p><p>AX=VBE返回值</p><p>其中模式号说明如下：</p><p>VESA 2.0版本以上增加了BX中D14、D15两个位定义</p><p>D0~D8：9位模式号</p><p>D9~D13：保留，必须为0</p><p>D14：置0，使用普通窗口页面缓存模式，使用VBE功能05H切换显示页面；置1，使用大的线性缓存区，其地址可从VBE功能01H的返回信息ModeInfo中获得</p><p>D15：置0，清除显示缓存；置1，不清除显示缓存</p><p>讲道理这个模式号，能百度到，但是资料好像不多..书上提供的两个0x180和0x143</p><div class="table-container"><table><thead><tr><th>模式</th><th>列</th><th>行</th><th>物理地址</th><th>像素点位宽</th></tr></thead><tbody><tr><td>0x180</td><td>1440</td><td>900</td><td>E0000000H</td><td>32 bit</td></tr><tr><td>0x143</td><td>800</td><td>600</td><td>E0000000H</td><td>32 bit</td></tr></tbody></table></div><p>这里D15 D14是01b</p><h2 id="1-11-切换模式"><a href="#1-11-切换模式" class="headerlink" title="1.11 切换模式"></a>1.11 切换模式</h2><h3 id="1-11-1-切换保护模式"><a href="#1-11-1-切换保护模式" class="headerlink" title="1.11.1 切换保护模式"></a>1.11.1 切换保护模式</h3><p>检测完硬件信息后，就该脱离实模式到保护模式了</p><p>在<strong>实模式</strong>下，程序可以操作任何地址空间，而且无法限制程序的执行权限。这种模式给设置硬件功能带来许多方便，但是给程序执行的安全性和稳定性带来了灾难性的后果。并且实模式寻址能力有限，所以需要切换到保护模式</p><p>在<strong>保护模式</strong>下，处理器按照程序执行级别分为0、1、2、3四个等级(由高到低)，目前Linux只使用了两个0内核级，3应用程序级。保护模式还引入了分页功能，有了分页，段机制就显得多余，然后又有了IA-32e模式(长模式)</p><p><strong>IA-32e模式</strong>简化段级保护措施的复杂性，升级内存寻址能力，同时还扩展页管理单元的组织结构和页面大小，推出新的系统调用方式和高级可编程中断控制器</p><p>在切换保护模式前，必须创建一段可在保护模式下执行的代码及必要的系统数据结构(IDT/GDT/LDT描述表可一个，任务状态段TSS结构，至少一个页目录和页表，至少一个异常/中断处理模块)，初始化GDTR寄存器、IDTR寄存器、控制寄存器CR1~4、MTTRs内存范围类型寄存器</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;=======    init IDT GDT goto protect mode </span><br><span class="line">    cli  ; 关中断</span><br><span class="line">    db  0x66</span><br><span class="line">    lgdt [GdtPtr]  ; 将GDT加载到GDTR中，这里的GDT就是初始化里面的</span><br><span class="line"></span><br><span class="line">    ; 已使用cli禁止外部中断，所以在切换到保护模式过程中不会产生中断和异常，不必完整初始化IDT，</span><br><span class="line">    ; 只要有相应的结构体即可。能够保证处理器在模式切换过程中不会产生一场，即使没有IDT也可以</span><br><span class="line">;   db  0x66</span><br><span class="line">;   lidt [IDT_POINTER]</span><br><span class="line"></span><br><span class="line">    mov eax, cr0</span><br><span class="line">    or  eax, 1    ; CR0.PE，也可以同时开启CR0.PG，开启分页</span><br><span class="line">    mov cr0, eax  ; 执行后，就已经进入到保护模式</span><br><span class="line"></span><br><span class="line">    ; jmp 代码段选择子:偏移 = jmp 0x08:xxxx，目的是改变处理器的执行流水线，</span><br><span class="line">    ; 进而使处理器加载执行保护模式的代码段</span><br><span class="line">    jmp dword SelectorCode32:GO_TO_TMP_Protect</span><br></pre></td></tr></tbody></table></figure><p>详细解释一下，GDT</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 32位段描述表</span><br><span class="line">[SECTION gdt]</span><br><span class="line">LABEL_GDT:      dd  0,0  ; 空描述符，offset +0H</span><br><span class="line">LABEL_DESC_CODE32:  dd  0x0000FFFF,0x00CF9A00  ; 代码段，offset +8H</span><br><span class="line">LABEL_DESC_DATA32:  dd  0x0000FFFF,0x00CF9200  ; 数据段，offset +10H</span><br><span class="line">GdtLen  equ $ - LABEL_GDT  ; GDT长度</span><br><span class="line">GdtPtr  dw  GdtLen - 1  ; 这个就是 limit</span><br><span class="line">        dd  LABEL_GDT  ; GDT基址</span><br><span class="line">SelectorCode32  equ LABEL_DESC_CODE32 - LABEL_GDT  ; 代码段选择子</span><br><span class="line">SelectorData32  equ LABEL_DESC_DATA32 - LABEL_GDT  ; 数据段选择子</span><br></pre></td></tr></tbody></table></figure><p>首先第一项LABEL_GDT必须是空描述符，dd两个，也就是占8字节</p><p>然后来看CODE32和DATA32，根据之前学习的段描述</p><p><img alt="202112072244745" data-src="assets/05_Make-MyOS-Find-kernel/202112072244745.png"></p><p>其中CODE32：</p><p>0x00CF9A00，0000 0000 1100 1111 1001 1010 0000 0000</p><p>0x0000FFFF，0000 0000 0000 0000 1111 1111 1111 1111</p><p>得出Base=00000000H，Seg Limit=FFFFFH，G=1，D/B=1，P=1，S=1，Type=1010b</p><p>所以基址是0x00000000处；由于G=1，所以段限是0xffffffff，也就是4GB寻址能力；S=1且Type=1010b，表示代码段，可执行可读</p><p>其中DATA32：</p><p>0x00CF9200，0000 0000 1100 1111 1001 0010 0000 0000</p><p>0x0000FFFF，0000 0000 0000 0000 1111 1111 1111 1111</p><p>得出Base=00000000H，Seg Limit=FFFFFH，G=1，D/B=1，P=1，S=1，Type=0010b</p><p>所以基址是0x00000000处；由于G=1，所以段限是0xffffffff，也就是4GB寻址能力；S=1且Type=0010b，表示数据段，可读可写</p><p>GdtLen，每个表项占8字节，三个也就是24B</p><p>GdtPtr，前面是表界限，后面是表基地址</p><p>SelectorCode32，代码段选择子，这里具体数值就是0x8</p><p>SelectorData32，数据段选择子，这里具体数值就是0x10</p><p>完了再说IDT，虽然不需要IDT，但是还是要为IDT开辟存储空间</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;=======    tmp IDT</span><br><span class="line">IDT:</span><br><span class="line">    times   0x50    dq  0  ; Define Quadra Word，8B</span><br><span class="line">IDT_END:</span><br><span class="line">IDT_POINTER:</span><br><span class="line">        dw  IDT_END - IDT - 1</span><br><span class="line">        dd  IDT</span><br></pre></td></tr></tbody></table></figure><p>DB 定义的变量为字节型 Define Byte</p><p>DW 定义的变量为字类型（双字节）Define Word</p><p>DD 定义的变量为双字型（4字节）Define Double Word</p><p>DQ 定义的变量为4字型（8字节）Define Quadra Word</p><p>DT 定义的变量为10字节型 Define Ten Byte</p><p>书上总结的模式切换步骤，参考Intel卷3第9.9.1节Switching to Protected Mode</p><ol><li>执行CLI禁止可屏蔽硬件中断，对于不可屏蔽中断NMI只能借助外部电路才能禁止(模式切换过程中必须保证不能产生异常或中断)</li><li>执行LGDT将GDT的基地址和长度加载到GDTR寄存器</li><li>执行MOV CR0置CR0.PE标志位(可同时置位CR0.PG)</li><li>一旦MOV CR0执行结束，紧随其后必须执行一条跳转指令(JMP)或调用(CALL)指令，以切换到保护模式的代码段去执行</li><li>通过执行JMP或CALL指令，可以改变处理器执行流水线，进而使处理器加载执行保护模式的代码段</li><li>如果开启分页机制，那么MOV CR0指令和JMP/CALL指令必须位于identity mapped页面内，至于JMP/CALL指令的目标地址则无需是identity mapped</li><li>如需使用LDT，则必须借助LLDT指令将GDT内的LDT段选择子加载到LDTR寄存器中</li><li>执行LTR将一个TSS段描述符的选择子加载到TR任务寄存器</li><li>进入保护模式后，数据段寄存器仍旧保留着实模式的段数据，必须重新加载数据段选择子或使用JMP/CALL指令执行新任务，便可将其更新位保护模式</li><li>执行LIDT，将保护模式下的IDT表的基地址和长度加载到IDTR</li><li>执行STI指令是能可屏蔽硬件中断，并执行必要的硬件操作使能NMI不可屏蔽中断</li></ol><blockquote><ol><li>Disable interrupts. A CLI instruction disables maskable hardware interrupts. NMI interrupts can be disabled with external circuitry. (Software must guarantee that no exceptions or interrupts are generated during the mode switching operation.)</li><li>Execute the LGDT instruction to load the GDTR register with the base address of the GDT.</li><li>Execute a MOV CR0 instruction that sets the PE flag (and optionally the PG flag) in control register CR0.</li><li>Immediately following the MOV CR0 instruction, execute a far JMP or far CALL instruction. (This operation is typically a far jump or call to the next instruction in the instruction stream.)</li><li>The JMP or CALL instruction immediately after the MOV CR0 instruction changes the flow of execution and serializes the processor.</li><li>If paging is enabled, the code for the MOV CR0 instruction and the JMP or CALL instruction must come from a page that is identity mapped (that is, the linear address before the jump is the same as the physical address after paging and protected mode is enabled). The target instruction for the JMP or CALL instruction does not need to be identity mapped.</li><li>If a local descriptor table is going to be used, execute the LLDT instruction to load the segment selector for the LDT in the LDTR register.</li><li>Execute the LTR instruction to load the task register with a segment selector to the initial protected-mode task or to a writable area of memory that can be used to store TSS information on a task switch.</li><li>After entering protected mode, the segment registers continue to hold the contents they had in real-address mode. The JMP or CALL instruction in step 4 resets the CS register. Perform one of the following operations to update the contents of the remaining segment registers.<br>— Reload segment registers DS, SS, ES, FS, and GS. If the ES, FS, and/or GS registers are not going to be used, load them with a null selector.<br>— Perform a JMP or CALL instruction to a new task, which automatically resets the values of the segment registers and branches to a new code segment.</li><li>Execute the LIDT instruction to load the IDTR register with the address and limit of the protected-mode IDT.</li><li>Execute the STI instruction to enable maskable hardware interrupts and perform the necessary hardware operation to enable NMI interrupts.</li></ol></blockquote><h3 id="1-11-2-切换IA-32e模式"><a href="#1-11-2-切换IA-32e模式" class="headerlink" title="1.11.2 切换IA-32e模式"></a>1.11.2 切换IA-32e模式</h3><p>和进入保护模式差不多，只不过还要开启分页机制，参考Intel卷3第9.8.5 Initializing IA-32e Mode：</p><blockquote><ol><li>Starting from protected mode, disable paging by setting CR0.PG = 0. Use the MOV CR0 instruction to disable paging (the instruction must be located in an identity-mapped page).</li><li>Enable physical-address extensions (PAE) by setting CR4.PAE = 1. Failure to enable PAE will result in a #GP fault when an attempt is made to initialize IA-32e mode.</li><li>Load CR3 with the physical base address of the Level 4 page map table (PML4) or Level 5 page map table(PML5).</li><li>Enable IA-32e mode by setting IA32_EFER.LME = 1.</li><li>Enable paging by setting CR0.PG = 1. This causes the processor to set the IA32_EFER.LMA bit to 1. The MOV CR0 instruction that enables paging and the following instructions must be located in an identity-mapped page (until such time that a branch to non-identity mapped pages can be effected).</li></ol></blockquote><ol><li>在保护模式下，使用MOV CR0.PG指令关闭分页机制</li><li>置位CR4.PAE，开启物理地址扩展功能。若失败则产生#GP</li><li>PML4或PML5的物理基地址加载到CR3寄存器中</li><li>置位IA32_EFER.LME，打开IA-32e模式</li><li>置位CR0.PG开启分页机制，此时处理器会自动置位IA32_EFER.LMA。当执行MOV CR0指令开启分页时，其后续指令必须位于identity-mapped page(直到处理器进入IA-32e模式后，才能使用非identity-mapped page)</li></ol><p>在切到IA-32e模式之前应当先检查支不支持</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[SECTION .s32]</span><br><span class="line">[BITS 32]</span><br><span class="line">GO_TO_TMP_Protect:</span><br><span class="line">;=======    go to tmp long mode</span><br><span class="line">    mov ax, 0x10</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov esp, 7E00h</span><br><span class="line">    call support_long_mode</span><br><span class="line">    test eax, eax  ; 目的操作数和源操作数按位与，与and不同的是test不改变目的操作数</span><br><span class="line">    jz no_support  ; 等于0时跳转 jmp $</span><br><span class="line"></span><br><span class="line">;=======    test support long mode or not</span><br><span class="line">support_long_mode:</span><br><span class="line">    mov eax, 0x80000000</span><br><span class="line">    cpuid</span><br><span class="line">    cmp eax, 0x80000001</span><br><span class="line">    setnb al  </span><br><span class="line">    jb support_long_mode_done</span><br><span class="line">    mov eax, 0x80000001</span><br><span class="line">    cpuid</span><br><span class="line">    bt edx, 29  ; bit test，将edx bit 29拷贝至CF</span><br><span class="line">    setc al  ; Set byte if carry，若CF=1，则al=1；否则al=0</span><br><span class="line">support_long_mode_done:</span><br><span class="line">    movzx eax, al  ; 将al全0扩展到eax，高位补0</span><br><span class="line">    ret</span><br></pre></td></tr></tbody></table></figure><p>进入保护模式首要任务是初始化各个寄存器以及栈指针，然后检测处理器是否支持IA-32e模式，这里是根据cpuid来判断的</p><p>CPUID指令分为两组，一组返回基本信息，一组返回扩展信息，Intel手册里面描述这个指令很复杂</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 0</span><br><span class="line">cpuid</span><br></pre></td></tr></tbody></table></figure><p>执行完CPUID指令后，EAX中返回的值就是返回基本信息时，功能代码的最大值，在执行CPUID指令要求返回基本信息时，EAX中的值必须小于或等于该值。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 80000000h</span><br><span class="line">cpuid</span><br></pre></td></tr></tbody></table></figure><p>执行完CPUID指令后，EAX中返回的值就是返回扩展信息时，功能代码的最大值，在执行CPUID指令要求返回扩展信息时，EAX中的值必须小于或等于该值。</p><p>如果这个号码大于等于0x80000001就说明可以支持long_mode，那么我们就直接跳转到support_long_mode_done，如果不行的话，需要检查这个号码的第29位，如果29位符合预期，那么说明也是可以支持的，否则就不行。</p><p>如果支持IA-32e模式，接下来就将为IA-32e模式配置临时页目录项和页表项。页目录首地址设置在0x90000地址处</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;=======    init temporary page table 0x90000</span><br><span class="line">    mov dword   [0x90000],  0x91007</span><br><span class="line">    mov dword   [0x90004],  0x00000</span><br><span class="line">    mov dword   [0x90800],  0x91007</span><br><span class="line">    mov dword   [0x90804],  0x00000</span><br><span class="line"></span><br><span class="line">    mov dword   [0x91000],  0x92007</span><br><span class="line">    mov dword   [0x91004],  0x00000</span><br><span class="line"></span><br><span class="line">    mov dword   [0x92000],  0x000083</span><br><span class="line">    mov dword   [0x92004],  0x000000</span><br><span class="line">    mov dword   [0x92008],  0x200083</span><br><span class="line">    mov dword   [0x9200c],  0x000000</span><br><span class="line">    mov dword   [0x92010],  0x400083</span><br><span class="line">    mov dword   [0x92014],  0x000000</span><br><span class="line">    mov dword   [0x92018],  0x600083</span><br><span class="line">    mov dword   [0x9201c],  0x000000</span><br><span class="line">    mov dword   [0x92020],  0x800083</span><br><span class="line">    mov dword   [0x92024],  0x000000</span><br><span class="line">    mov dword   [0x92028],  0xa00083</span><br><span class="line">    mov dword   [0x9202c],  0x000000</span><br></pre></td></tr></tbody></table></figure><p>然后就是开启IA-32e模式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">;=======    load GDTR</span><br><span class="line">    db  0x66</span><br><span class="line">    lgdt [GdtPtr64]  ; 加载64位的GDT到GDTR</span><br><span class="line">    mov ax, 0x10</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov esp,    7E00h</span><br><span class="line"></span><br><span class="line">;=======    open PAE</span><br><span class="line">    mov eax, cr4</span><br><span class="line">    bts eax, 5  ; Bit Test and Set，先将指定位的值存储到CF标志中然后设置该位 CR4.PAE</span><br><span class="line">    mov cr4, eax</span><br><span class="line">;=======    load    cr3</span><br><span class="line">    mov eax,    0x90000  ; 1001 0000...0000</span><br><span class="line">    mov cr3,    eax  ; 位12~位63，page directory base</span><br><span class="line">;=======    enable long-mode</span><br><span class="line">    mov ecx, 0C0000080h  ; IA32_EFER</span><br><span class="line">    rdmsr  ; 将MSR寄存器组中IA32_EFER值读到edx:eax</span><br><span class="line">    bts eax, 8  ; IA32_EFER.LME=1</span><br><span class="line">    wrmsr  ; 写回</span><br><span class="line">;=======    open PE and paging</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    bts eax, 0  ; CR0.PE=1</span><br><span class="line">    bts eax, 31 ; CR0.PG=1</span><br><span class="line">    mov cr0, eax</span><br><span class="line"></span><br><span class="line">    ; 使用JMP/CALL将CS段寄存器的更新为IA-32e模式的代码段描述符</span><br><span class="line">    jmp SelectorCode64:OffsetOfKernelFile</span><br></pre></td></tr></tbody></table></figure><p>IA32_EFER寄存器位于MSR寄存器组内，它的第8位是LME标志位，为了操作IA32_EFER寄存器必须借助特殊汇编指令RDMSR/WRMSR</p><p>在访问MSR寄存器前，必须向ECX寄存器(在64位模式下RCX寄存器高32位被忽略)传入寄存器地址。而目标寄存器则是由EDX:EAX组成的64位寄存器代表，其中EDX寄存器保存MSR寄存器高32位，EAX寄存器保存低32位</p><p>RDMSR/WRMSR必须在0特权级或实模式下执行。在使用这两条指令前，应该使用CPUID指令(CPUID.01H:EDX[5]=1)来检测处理器是否支持MSR寄存器组</p><p>这里的0C0000080h在Intel卷4有提到 Table 2-3. MSRs in Processors Based on Intel® Core™ Microarchitecture (Contd.)</p><p>C000_0080H IA32_EFER Unique Extended Feature Enables</p><p>IA32_EFER寄存器布局</p><div class="table-container"><table><thead><tr><th>63:12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7:1</th><th>0</th></tr></thead><tbody><tr><td>Reserved</td><td>Execute-disable bit enable (NXE)</td><td>IA-32e mode active (LMA)</td><td>Reserved</td><td>IA-32e mode enable (LME)</td><td>Reserved</td><td>SysCall enable (SCE)</td></tr></tbody></table></div><p>伴随着loader最后一条指令，处理器控制权已经交给了kernel.bin了，等着下一节的探索..</p><h1 id="2-实践"><a href="#2-实践" class="headerlink" title="2 实践"></a>2 实践</h1><p>代码看完了当然要动手了，这下文件比较多，主要是4个</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fat12.inc   <span class="comment"># fat12格式文件</span></span><br><span class="line">boot.asm    <span class="comment"># 之前的boot.asm文件，主要功能是找loader.bin</span></span><br><span class="line">loader.asm  <span class="comment"># 这次的源码，主要功能是找kernel.bin，并开启临时IA-32e模式，进入kernel</span></span><br><span class="line">Makefile    <span class="comment"># 后面源文件越来越多，不能一个个敲 nasm boot.asm -o boot.bin</span></span><br></pre></td></tr></tbody></table></figure><p>简单看下Makefile</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: boot.bin loader.bin</span></span><br><span class="line"><span class="section">loader.bin:</span></span><br><span class="line">truenasm loader.asm -o loader.bin</span><br><span class="line"><span class="section">boot.bin:</span></span><br><span class="line">truenasm boot.asm -o boot.bin</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">truerm -rf *.bin *.asm~ Makefile~ loader.bin boot.bin</span><br></pre></td></tr></tbody></table></figure><p>执行make的时候会生成boot.bin和loader.bin，执行make clean的时候会删除bin文件和临时文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成bin文件</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个1.44MB的img软盘镜像</span></span><br><span class="line">sidney@ubuntu:~/Work/MyOS/day04$ bximage </span><br><span class="line">========================================================================</span><br><span class="line">                                bximage</span><br><span class="line">                  Disk Image Creation Tool <span class="keyword">for</span> Bochs</span><br><span class="line">          <span class="variable">$Id</span>: bximage.c 11315 2012-08-05 18:13:38Z vruppert $</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line">Do you want to create a floppy disk image or a hard disk image?</span><br><span class="line">Please <span class="built_in">type</span> hd or fd. [hd] fd</span><br><span class="line"></span><br><span class="line">Choose the size of floppy disk image to create, <span class="keyword">in</span> megabytes.</span><br><span class="line">Please <span class="built_in">type</span> 0.16, 0.18, 0.32, 0.36, 0.72, 1.2, 1.44, 1.68, 1.72, or 2.88.</span><br><span class="line"> [1.44] 1.44</span><br><span class="line">I will create a floppy image with</span><br><span class="line">  cyl=80</span><br><span class="line">  heads=2</span><br><span class="line">  sectors per track=18</span><br><span class="line">  total sectors=2880</span><br><span class="line">  total bytes=1474560</span><br><span class="line"></span><br><span class="line">What should I name the image?</span><br><span class="line">[a.img] boot.img</span><br><span class="line"></span><br><span class="line">Writing: [] Done.</span><br><span class="line"></span><br><span class="line">I wrote 1474560 bytes to boot.img.</span><br><span class="line"></span><br><span class="line">The following line should appear <span class="keyword">in</span> your bochsrc:</span><br><span class="line">  floppya: image=<span class="string">"boot.img"</span>, status=inserted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建boot.img，dd 命令的 conv=notrunc 字段很重要，保证软盘文件不截断</span></span><br><span class="line">dd <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将boot.img挂载到/media，这个/media可以随便创建一个目录</span></span><br><span class="line">sudo mount boot.img /media/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于boot.img已经拥有了FAT12文件系统（说白了，就是可以解析FAT表项的能力，代码实现于Func_GetFATEntry部分），</span></span><br><span class="line"><span class="comment"># 并且mount命令可以实现FAT数据区与根目录区的联系，从而达到只需要操作media文件夹实质就是操作boot.img的效果</span></span><br><span class="line"><span class="comment">#（说白了，如果我们往挂载好之后的media分区复制数据，其实就是把数据复制到boot.img）</span></span><br><span class="line">sudo cp loader.bin /media/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还没有写kernel，先弄个假的进去</span></span><br><span class="line">cp loader.bin kernel.bin</span><br><span class="line">sudo cp kernel.bin /media/</span><br><span class="line"><span class="comment"># 数据都写进boot.img就不需要挂载了</span></span><br><span class="line">sudo umount /media</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里不是用qemu-system-i386了，执行完一直在闪烁？</span></span><br><span class="line">qemu-system-x86_64 -drive file=boot.img,format=raw,<span class="keyword">if</span>=floppy</span><br></pre></td></tr></tbody></table></figure><p>讲道理，应该算成功了..</p><h2 id="2-1-安装bochs"><a href="#2-1-安装bochs" class="headerlink" title="2.1 安装bochs"></a>2.1 安装bochs</h2><p>在<strong>1.3 打开A20功能</strong>那段代码sti后面加一个<code>jmp $</code>看段寄存器状态，百度了下，qemu好像没招，乖乖安装bochs..</p><p>下载：<a href="https://sourceforge.net/projects/bochs/files/bochs/2.7/bochs-2.7.tar.gz/download" target="_blank" rel="noopener">bochs-2.7.tar.gz</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf bochs-2.7.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bochs-2.7</span><br><span class="line"></span><br><span class="line">./confugure --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">./configure --with-x11 --with-wx --<span class="built_in">enable</span>-ltdl-install --<span class="built_in">enable</span>-idle-hack --<span class="built_in">enable</span>-plugins --<span class="built_in">enable</span>-a20-pin --<span class="built_in">enable</span>-x86-64 --<span class="built_in">enable</span>-smp --<span class="built_in">enable</span>-long-phy-address --<span class="built_in">enable</span>-large-ramfile --<span class="built_in">enable</span>-repeat-speedups --<span class="built_in">enable</span>-fast-function-calls --<span class="built_in">enable</span>-handlers-chaining --<span class="built_in">enable</span>-trace-linking --<span class="built_in">enable</span>-configurable-msrs --<span class="built_in">enable</span>-show-ips --<span class="built_in">enable</span>-cpp --<span class="built_in">enable</span>-debugger --<span class="built_in">enable</span>-debugger-gui --<span class="built_in">enable</span>-iodebug --<span class="built_in">enable</span>-all-optimizations --<span class="built_in">enable</span>-readline --<span class="built_in">enable</span>-logging --<span class="built_in">enable</span>-stats --<span class="built_in">enable</span>-assert-checks --<span class="built_in">enable</span>-fpu --<span class="built_in">enable</span>-vmx --<span class="built_in">enable</span>-svm --<span class="built_in">enable</span>-protection-keys --<span class="built_in">enable</span>-cet --<span class="built_in">enable</span>-3dnow --<span class="built_in">enable</span>-alignment-check --<span class="built_in">enable</span>-monitor-mwait --<span class="built_in">enable</span>-perfmon --<span class="built_in">enable</span>-memtype --<span class="built_in">enable</span>-avx --<span class="built_in">enable</span>-evex --<span class="built_in">enable</span>-x86-debugger --<span class="built_in">enable</span>-pci --<span class="built_in">enable</span>-pcidev --<span class="built_in">enable</span>-usb --<span class="built_in">enable</span>-usb-ohci --<span class="built_in">enable</span>-usb-ehci --<span class="built_in">enable</span>-usb-xhci --<span class="built_in">enable</span>-ne2000 --<span class="built_in">enable</span>-pnic --<span class="built_in">enable</span>-e1000 --<span class="built_in">enable</span>-raw-serial --<span class="built_in">enable</span>-clgd54xx --<span class="built_in">enable</span>-voodoo --<span class="built_in">enable</span>-cdrom --<span class="built_in">enable</span>-sb16 --<span class="built_in">enable</span>-es1370 --<span class="built_in">enable</span>-gameport --<span class="built_in">enable</span>-busmouse --<span class="built_in">enable</span>-xpm</span><br><span class="line"></span><br><span class="line">make -j8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时会报一些错 简单改改就好了</span></span><br><span class="line">cp ./bx_debug/parser.cpp ./bx_debug/parser.cc</span><br><span class="line">cp misc/bximage.cpp misc/bximage.cc</span><br><span class="line">cp iodev/hdimage/hdimage.cpp iodev/hdimage/hdimage.cc</span><br><span class="line">cp iodev/hdimage/vmware3.cpp iodev/hdimage/vmware3.cc</span><br><span class="line">cp iodev/hdimage/vmware4.cpp iodev/hdimage/vmware4.cc</span><br><span class="line">cp iodev/hdimage/vpc.cpp iodev/hdimage/vpc.cc</span><br><span class="line">cp iodev/hdimage/vbox.cpp iodev/hdimage/vbox.cc</span><br><span class="line">cp misc/bxhub.cpp misc/bxhub.cc</span><br><span class="line">cp iodev/network/netutil.cpp iodev/network/netutil.cc</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line">bochs -<span class="built_in">help</span> cpu</span><br></pre></td></tr></tbody></table></figure><p>然后根据书上在用户家目录创建bochs的配置文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bochsrc</span><br><span class="line"></span><br><span class="line">plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1</span><br><span class="line">config_interface: textconfig</span><br><span class="line">display_library: x</span><br><span class="line">cpu: model=corei7_haswell_4770,count=1:1:1,ips=4000000,quantum=16,reset_on_triple_fault=1</span><br><span class="line">cpu: cpuid_limit_winnt=0,ignore_bad_msrs=1,mwait_is_nop=0,msrs=<span class="string">"msrs.def"</span></span><br><span class="line">cpuid: x86_64=1,level=6,mmx=1,sep=1,simd=avx512,apic=x2apic,aes=1,movbe=1,xsave=1,sha=1,adx=1,xsaveopt=1,</span><br><span class="line">cpuid: avx_f16c=1,avx_fma=1,bmi=bmi2,1g_pages=1,pcid=1,fsgsbase=1,smep=1,smap=1,mwait=1,vmx=1,family=6</span><br><span class="line">cpuid: model=0x1a, stepping=5, vendor_string=<span class="string">"GenuineIntel"</span>,brand_string=<span class="string">"Intel(R) Core(TM) i7-4770 CPU (Haswell)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#memory: guest=2048, host=2048</span></span><br><span class="line"></span><br><span class="line">romimage: file=/usr/<span class="built_in">local</span>/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/usr/<span class="built_in">local</span>/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">vga: extension=vbe, update_freq=5</span><br><span class="line"><span class="comment">#voodoo: enabled=1, model=voodoo1</span></span><br><span class="line"></span><br><span class="line">keyboard: <span class="built_in">type</span>=mf, serial_delay=250, paste_delay=100000, user_shortcut=none</span><br><span class="line">mouse: <span class="built_in">type</span>=ps2,enabled=0,toggle=ctrl+mbutton</span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line">clock: sync=none, time0=<span class="built_in">local</span>, rtc_sync=0</span><br><span class="line"><span class="comment">#cmosimage: file=cmos.img, rtc_init=time0</span></span><br><span class="line">private_colormap: enabled=0</span><br><span class="line"></span><br><span class="line">floppya: <span class="built_in">type</span>=1_44, 1_44=<span class="string">"boot.img"</span>, status=inserted, write_protected=0</span><br><span class="line"><span class="comment"># no floppyb</span></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata0-master: <span class="built_in">type</span>=none</span><br><span class="line">ata0-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata1-master: <span class="built_in">type</span>=none</span><br><span class="line">ata1-slave: <span class="built_in">type</span>=none</span><br><span class="line">ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line">boot: floppy</span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>: bochsout.log</span><br><span class="line">logprefix: %t-%e-@%i-%d</span><br><span class="line">panic: action=ask</span><br><span class="line">error: action=report</span><br><span class="line">info: action=report</span><br><span class="line">debug: action=ignore, pci=report</span><br><span class="line">debugger_log: -</span><br><span class="line"></span><br><span class="line">com1: enabled=1, mode=null</span><br><span class="line">com2: enabled=0</span><br><span class="line">com3: enabled=0</span><br><span class="line">com4: enabled=0</span><br><span class="line"></span><br><span class="line">parport1: enabled=1, file=none</span><br><span class="line">parport2: enabled=0</span><br><span class="line"></span><br><span class="line">sound: waveoutdrv=sdl, waveindrv=alsa, midioutdrv=dummy</span><br><span class="line">speaker: enabled=1, mode=system, volume=15</span><br><span class="line">sb16: enabled=0</span><br><span class="line">es1370: enabled=0</span><br><span class="line"></span><br><span class="line">usb_ehci: enabled=1</span><br><span class="line">usb_xhci: enabled=1</span><br><span class="line"></span><br><span class="line">magic_break: enabled=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug_symbols: file="kernel.sym"</span></span><br><span class="line">print_timestamps: enabled=0</span><br><span class="line">port_e9_hack: enabled=0</span><br><span class="line">fullscreen: enabled=0</span><br><span class="line"></span><br><span class="line">megs: 2048</span><br></pre></td></tr></tbody></table></figure><p>bochs的调试命令</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>b address</td><td>在某物理地址上设置断点</td><td>b 0x7c00</td></tr><tr><td>c</td><td>继续执行，直到遇到断点</td><td>c</td></tr><tr><td>s</td><td>单步执行</td><td>s</td></tr><tr><td>info cpu</td><td>查看寄存器信息</td><td>info cpu</td></tr><tr><td>r</td><td>查看<strong>通用</strong>寄存器信息</td><td></td></tr><tr><td>sreg</td><td>查看<strong>段</strong>寄存器信息</td><td></td></tr><tr><td>creg</td><td>查看<strong>控制</strong>寄存器信息</td><td></td></tr><tr><td>xp /nuf addr</td><td>查看内存物理地址内容</td><td>xp /10bx 0x100000</td></tr><tr><td>x /nuf addr</td><td>查看线性地址内容</td><td>x /40wd 0x9000</td></tr><tr><td>u start end</td><td>反汇编一段内存</td><td>u 0x100000 0x100010</td></tr></tbody></table></div><h2 id="2-2-第一条指令"><a href="#2-2-第一条指令" class="headerlink" title="2.2 第一条指令"></a>2.2 第一条指令</h2><p>还是按照qemu的一套动作来</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make  <span class="comment"># 编译</span></span><br><span class="line">cp loader.bin kernel.bin  <span class="comment"># 没有kernel.bin，随便拷贝一个</span></span><br><span class="line">bximage  <span class="comment"># 创建floppy disk</span></span><br><span class="line"><span class="comment"># 将boot.bin写到floppy disk中</span></span><br><span class="line">dd <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br><span class="line"><span class="comment"># 将boot.img挂载到/media</span></span><br><span class="line">sudo mount boot.img /media/ -t vfat -o loop</span><br><span class="line">sudo cp loader.bin /media/</span><br><span class="line">sudo cp kernel.bin /media/</span><br><span class="line">sync  <span class="comment"># 将loader.bin和kernel.bin写到floppy disk中</span></span><br><span class="line">sudo umount /media</span><br><span class="line"></span><br><span class="line">bochs  <span class="comment"># 启动bochs</span></span><br></pre></td></tr></tbody></table></figure><p>这个时候先不要急着执行c或s，想想第0天的内容，Intel卷3第9.1.1 Processor State After Reset，寄存器初始化的状态全在那张表了 Table 9-1. IA-32 and Intel 64 Processor States Following Power-up, Reset, or INIT</p><p>执行几条命令看看</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是bochs刚开始的时候，下一条指令是 jmpf 0xf000:e05b</span></span><br><span class="line"><span class="comment"># Next at t=0中t是执行的指令个数，也叫做内部时钟</span></span><br><span class="line"><span class="comment"># 0x0000fffffff0  物理地址</span></span><br><span class="line"><span class="comment"># f000:fff0 逻辑地址，好像算不出来上面的物理地址？</span></span><br><span class="line"><span class="comment"># jmpf 0xf000:e05b  汇编指令</span></span><br><span class="line"><span class="comment"># ea5be000f0  机器码</span></span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看控制寄存器 CR0=0x60000010 没毛病</span></span><br><span class="line">&lt;bochs:2&gt; creg</span><br><span class="line"><span class="comment"># 小写的表示标志位是0，大写的表示标志位是1</span></span><br><span class="line">CR0=0x60000010: pg CD NW ac wp ne ET ts em mp pe</span><br><span class="line">CR2=page fault laddr=0x0000000000000000</span><br><span class="line">CR3=0x000000000000</span><br><span class="line">    PCD=page-level cache <span class="built_in">disable</span>=0</span><br><span class="line">    PWT=page-level write-through=0</span><br><span class="line">CR4=0x00000000: pks cet pke smap smep keylock osxsave pcid fsgsbase smx vmx la57 umip osxmmexcpt osfxsr pce pge mce pae pse de tsd pvi vme</span><br><span class="line">CR8: 0x0</span><br><span class="line">EFER=0x00000000: ffxsr nxe lma lme sce</span><br><span class="line">XCR0=0x00000001: cet_s cet_u pkru hi_zmm zmm_hi256 opmask bndcfg bndregs ymm sse FPU</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看段寄存器 cs:0xf000，base=0xffff0000，limit=0x0000ffff和书上说的一样</span></span><br><span class="line">&lt;bochs:1&gt; sreg</span><br><span class="line">es:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">trueData segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">cs:0xf000, dh=0xff0093ff, dl=0x0000ffff, valid=7</span><br><span class="line">trueData segment, base=0xffff0000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">trueData segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ds:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">trueData segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">fs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">trueData segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">trueData segment, base=0x00000000, <span class="built_in">limit</span>=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1</span><br><span class="line">tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1</span><br><span class="line">gdtr:base=0x0000000000000000, <span class="built_in">limit</span>=0xffff</span><br><span class="line">idtr:base=0x0000000000000000, <span class="built_in">limit</span>=0xffff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看通用寄存器 rip: 00000000_0000fff0，eflags 0x00000002</span></span><br><span class="line">&lt;bochs:3&gt; r</span><br><span class="line">CPU0:</span><br><span class="line">rax: 00000000_00000000</span><br><span class="line">rbx: 00000000_00000000</span><br><span class="line">rcx: 00000000_00000000</span><br><span class="line">rdx: 00000000_00000000</span><br><span class="line">rsp: 00000000_00000000</span><br><span class="line">rbp: 00000000_00000000</span><br><span class="line">rsi: 00000000_00000000</span><br><span class="line">rdi: 00000000_00000000</span><br><span class="line">r8 : 00000000_00000000</span><br><span class="line">r9 : 00000000_00000000</span><br><span class="line">r10: 00000000_00000000</span><br><span class="line">r11: 00000000_00000000</span><br><span class="line">r12: 00000000_00000000</span><br><span class="line">r13: 00000000_00000000</span><br><span class="line">r14: 00000000_00000000</span><br><span class="line">r15: 00000000_00000000</span><br><span class="line">rip: 00000000_0000fff0</span><br><span class="line">eflags 0x00000002: id vip vif ac vm rf nt IOPL=0 of df <span class="keyword">if</span> tf sf zf af pf cf</span><br></pre></td></tr></tbody></table></figure><p>从这些寄存器的值来看，和Intel手册上的东西是一一对应了，那么问题来了</p><p><strong>1 为啥逻辑地址是<code>f000:fff0</code>，物理地址是<code>fffffff0</code>？</strong></p><p>实际上这个问题在第0天说过了，也就是Intel手册卷3第9.1.4 First Instruction Executed</p><p><img alt="202201182351351" data-src="assets/05_Make-MyOS-Find-kernel/202201182351351.png"></p><p>大致意思就是上电后第一条指令，因为CS段寄存器基址是FFFF0000H，段选择子是F000H，在实模式下，一般来说基址是段选择子左移4位得来的，但这里显然不是，而是按照初始的基址。</p><p>硬件复位后第一次向CS寄存器加载新值时，处理器将遵循实地址模式下的正常地址转换规则(即[CS基地址=CS段选择器*16])，也就是到CS=0x7c00那个时候</p><p><strong>2 第一条指令到底是啥呢？为什么是<code>jmpf 0xf000:e05b</code>？</strong></p><p>回答这个问题之前，先看看实模式下1M内存的布局，截取自《操作系统真象还原》</p><p><img alt="" data-src="./assets/05_Make-MyOS-Find-kernel/202201192313827.png"></p><p>第一条指令是<code>jmpf 0xf000:e05b</code>，在的地方刚好占了16B，也就是说第一条指令基本就是跳转，干不了别的事，跳转到哪？各家的BIOS程序开始，bochs是<code>0xf000:e05b</code>，别家的可不一样。至于BIOS做了什么，在第0天已经说过了，这里看个下面几条指令就过了</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:1&gt; s</span><br><span class="line">Next at t=1</span><br><span class="line">(0) [0x0000000fe05b] f000:e05b (unk. ctxt): xor ax, ax                ; 31c0</span><br><span class="line">&lt;bochs:2&gt; s       </span><br><span class="line">Next at t=2</span><br><span class="line">(0) [0x0000000fe05d] f000:e05d (unk. ctxt): out 0x0d, al              ; e60d</span><br><span class="line">&lt;bochs:3&gt; s</span><br><span class="line">Next at t=3</span><br><span class="line">(0) [0x0000000fe05f] f000:e05f (unk. ctxt): out 0xda, al              ; e6da</span><br><span class="line">&lt;bochs:4&gt; s</span><br><span class="line">Next at t=4</span><br><span class="line">(0) [0x0000000fe061] f000:e061 (unk. ctxt): mov al, 0xc0              ; b0c0</span><br><span class="line">&lt;bochs:5&gt; s</span><br><span class="line">Next at t=5</span><br><span class="line">(0) [0x0000000fe063] f000:e063 (unk. ctxt): out 0xd6, al              ; e6d6</span><br></pre></td></tr></tbody></table></figure><p>S是单步调试，这里out命令实际上是给各个硬件端口设值，不关注</p><p>什么？你说BIOS程序是怎么加载到内存的？这个在第0天也提到过，硬件完成的，写在ROM中由硬件映射到低端1M内存中</p><p>然后BIOS会识别512B MBR(就是我们写的boot.asm)，并加载到7C00H~7DFF中，不再赘述</p><h2 id="2-3-执行MBR"><a href="#2-3-执行MBR" class="headerlink" title="2.3 执行MBR"></a>2.3 执行MBR</h2><p>跳过BIOS的操作，直接在0x7c00处打个断点，并单步调试看看</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:55&gt; b 0x7c00  <span class="comment"># 设断点</span></span><br><span class="line">&lt;bochs:56&gt; c         <span class="comment"># 执行到断点处</span></span><br><span class="line">(0) Breakpoint 1, 0x0000000000007c00 <span class="keyword">in</span> ?? ()</span><br><span class="line">Next at t=14034563</span><br><span class="line">(0) [0x000000007c00] 0000:7c00 (unk. ctxt): jmp .+60  (0x00007c3e)    ; eb3c</span><br><span class="line">&lt;bochs:57&gt; s</span><br><span class="line">Next at t=14034564</span><br><span class="line">(0) [0x000000007c3e] 0000:7c3e (unk. ctxt): mov ax, cs                ; 8cc8</span><br><span class="line">&lt;bochs:58&gt; s</span><br><span class="line">Next at t=14034565</span><br><span class="line">(0) [0x000000007c40] 0000:7c40 (unk. ctxt): mov ds, ax                ; 8ed8</span><br><span class="line">&lt;bochs:59&gt; s</span><br><span class="line">Next at t=14034566</span><br><span class="line">(0) [0x000000007c42] 0000:7c42 (unk. ctxt): mov es, ax                ; 8ec0</span><br><span class="line">&lt;bochs:60&gt; s</span><br><span class="line">Next at t=14034567</span><br><span class="line">(0) [0x000000007c44] 0000:7c44 (unk. ctxt): mov ss, ax                ; 8ed0</span><br><span class="line">&lt;bochs:61&gt; s</span><br><span class="line">Next at t=14034568</span><br><span class="line">(0) [0x000000007c46] 0000:7c46 (unk. ctxt): mov sp, 0x7c00            ; bc007c</span><br></pre></td></tr></tbody></table></figure><p>这里和boot.asm开头那段是一样的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Label_Start:</span><br><span class="line">    mov ax, cs  ; 最开始cs是等于0的</span><br><span class="line">    mov ds, ax  ; ds es ss不能通过立即数赋值 需要ax中转</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, BaseOfStack  ; 栈指针设到0x7c00</span><br></pre></td></tr></tbody></table></figure><p>然后在boot.asm中是将loader.bin加载到0x10000地址处，从上面的表中可以看到从0x7E00到0x9FBFF都是保留区域，中间留的一些空后面用作临时转存kernel的东西了，当加载loader.bin之后，直接跳转过去<code>jmp BaseOfLoader:OffsetOfLoader</code>，所以下一个断点就是0x10000咯，和boot.asm是一样的东西，不看了</p><h2 id="2-4-loader-bin"><a href="#2-4-loader-bin" class="headerlink" title="2.4 loader.bin"></a>2.4 loader.bin</h2><p>书上loader.bin上的一些小测试，第一个在开启A20 pin之后，查看fs段的limit，需要在开启A20 pin那节sti命令后面加个<code>jmp $</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:2&gt; sreg</span><br><span class="line">es:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">trueData segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">cs:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">trueData segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ss:0x0000, dh=0x00009300, dl=0x0000ffff, valid=7</span><br><span class="line">trueData segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ds:0x1000, dh=0x00009301, dl=0x0000ffff, valid=1</span><br><span class="line">trueData segment, base=0x00010000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">fs:0x0010, dh=0x00cf9300, dl=0x0000ffff, valid=1</span><br><span class="line">trueData segment, base=0x00000000, limit=0xffffffff, Read/Write, Accessed</span><br><span class="line">gs:0x0000, dh=0x00009300, dl=0x0000ffff, valid=1</span><br><span class="line">trueData segment, base=0x00000000, limit=0x0000ffff, Read/Write, Accessed</span><br><span class="line">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1</span><br><span class="line">tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1</span><br><span class="line">gdtr:base=0x0000000000010040, limit=0x17</span><br><span class="line">idtr:base=0x0000000000000000, limit=0x3ff</span><br></pre></td></tr></tbody></table></figure><p>可以看到开启A20 pin后，fs的limit变了，寻址能力变成4G了</p><p>打印SVGA相关信息，这个必须要在设置VGA模式(set the SVGA mode(VESA VBE))之前加个<code>jmp $</code>，因为设置完貌似就清屏了，啥信息也没有了，实际测试如下..</p><p><img alt="" data-src="./assets/05_Make-MyOS-Find-kernel/202201231548556.png"></p><p>当按书上的源码执行完后，bochs的界面应当发生改变，并且bochs的log中有<strong>CPU is in long mode (active)</strong>以表示我们真的进入了64位模式</p><h1 id="3-阶段小结"><a href="#3-阶段小结" class="headerlink" title="3 阶段小结"></a>3 阶段小结</h1><p>一张图算是对前面几节的总结了，刚开机干的事还是比较简单的</p><p><img alt="" data-src="./assets/05_Make-MyOS-Find-kernel/202201231746653.svg"></p></body></html></div><div style="text-align:center;color:#636363;font-size:14px">------- This article is over <i class="fa fa-leaf" aria-hidden="true"></i> Thank you for your reading -------</div><div id="reward-container"><div>All I need is you needing me.</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">Donate</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Sidney Ding WeChat Pay"><p>WeChat Pay</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Sidney Ding Alipay"><p>Alipay</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Sidney Ding</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://sidneygod.github.io/posts/ffccb7c5/" title="[Make MyOS] Find kernel">https://sidneygod.github.io/posts/ffccb7c5/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/a4707db6/" rel="next" title="[Make MyOS] Basic execution env & Interrupt"><i class="fa fa-chevron-left"></i> [Make MyOS] Basic execution env & Interrupt</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Catalogue</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-源码分析"><span class="nav-text">1 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-初始化"><span class="nav-text">1.1 初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-BITS伪指令"><span class="nav-text">1.2 BITS伪指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-打开A20功能"><span class="nav-text">1.3 打开A20功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-寻找kernel-bin"><span class="nav-text">1.4 寻找kernel.bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-加载kernel-bin"><span class="nav-text">1.5 加载kernel.bin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-加载完毕"><span class="nav-text">1.6 加载完毕</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-获取内存信息"><span class="nav-text">1.7 获取内存信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-获取SVGA信息"><span class="nav-text">1.8 获取SVGA信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-输出SVGA信息"><span class="nav-text">1.9 输出SVGA信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-设置SVGA模式"><span class="nav-text">1.10 设置SVGA模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-切换模式"><span class="nav-text">1.11 切换模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-1-切换保护模式"><span class="nav-text">1.11.1 切换保护模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-2-切换IA-32e模式"><span class="nav-text">1.11.2 切换IA-32e模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-实践"><span class="nav-text">2 实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-安装bochs"><span class="nav-text">2.1 安装bochs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-第一条指令"><span class="nav-text">2.2 第一条指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-执行MBR"><span class="nav-text">2.3 执行MBR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-loader-bin"><span class="nav-text">2.4 loader.bin</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-阶段小结"><span class="nav-text">3 阶段小结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="#"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Sidney Ding"></a><p class="site-author-name" itemprop="name">Sidney Ding</p><div class="site-description" itemprop="description">You laugh at me for being different, but I laugh at you for being the same.</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">23</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/SidneyGod" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SidneyGod" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:sidneyding183@gmail.com" title="E-Mail &amp;rarr; mailto:sidneyding183@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://google.com/" title="https:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">Google</a></li><li class="links-of-blogroll-item"><a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Sidney Ding</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Symbols count total: </span><span title="Symbols count total">304k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">Reading time total &asymp;</span> <span title="Reading time total">8:26</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div><div><span><i class="fa fa-bomb"></i> </span><span id="showDays"></span></div><script>var seconds=1e3,minutes=60*seconds,hours=60*minutes,days=24*hours,years=365*days,birthDay=Date.UTC(2019,10,1,0,0,0);setInterval(function(){var e=(n=new Date).getFullYear(),s=n.getMonth()+1,t=n.getDate(),a=n.getHours(),o=n.getMinutes(),n=n.getSeconds(),s=Date.UTC(e,s,t,a,o,n)-birthDay,t=Math.floor(s/years),a=Math.floor(s/days-365*t),o=Math.floor((s-(365*t+a)*days)/hours),n=Math.floor((s-(365*t+a)*days-o*hours)/minutes),s=Math.floor((s-(365*t+a)*days-o*hours-n*minutes)/seconds);document.getElementById("showDays").innerHTML="This website has been running for "+t+" years, "+a+" days, "+o+" hours, "+n+" minutes, "+s+" seconds"},1e3)</script></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.4.1.js"></script><script src="/js/motion.js?v=7.4.1.js"></script><script src="/js/schemes/pisces.js?v=7.4.1.js"></script><script src="/js/next-boot.js?v=7.4.1.js"></script><script src="/js/bookmark.js?v=7.4.1.js"></script><script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js"></script><script src="/js/local-search.js?v=7.4.1.js"></script><script>document.querySelectorAll("div.pdf").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js",()=>{document.querySelectorAll("div.pdf").forEach(e=>{PDFObject.embed(e.getAttribute("target"),e,{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:e.getAttribute("height")||"500px"})})},window.PDFObject)</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });</script><script>NexT.utils.getScript("//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML",()=>{MathJax.Hub.Typeset()},window.MathJax)</script><script>NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],i="nick,mail,link".split(",").filter(i=>e.includes(i));new Valine({el:"#comments",verify:!0,notify:!1,appId:"IJiDbg4VAiIeDsIj4MBo39Hq-gzGzoHsz",appKey:"0osu23DWjzCzrIVH4Ybe3ihh",placeholder:"Just go go",avatar:"monsterid",meta:i,pageSize:"10",visitor:!1,lang:"en",path:location.pathname,recordIP:!0,serverURLs:""})},window.Valine)</script><script src="/js/snowflakes.min.js"></script><script>new Snowflakes({color:"rgba(129, 161, 193, 0.87)"})</script><script async src="/js/love.js"></script><script async src="/js/fireworks.js"></script><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~"+OriginTitile,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script></body></html>