<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/pink/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"sidneygod.gitlab.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><link rel="canonical" href="https://sidneygod.gitlab.io/posts/e4de57a8/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://sidneygod.gitlab.io/posts/e4de57a8/","path":"posts/e4de57a8/","title":"[Relearning C/Cpp] Initialization and Functions"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>[Relearning C/Cpp] Initialization and Functions | Sidney God</title><script src="/lib/fireworks.js"></script><script>let titleTime,originTitile=document.title;document.addEventListener("visibilitychange",(function(){let i=document.querySelector('link[rel="icon"]');document.hidden?(i.setAttribute("href","/images/favicon.ico"),document.title="(つェ⊂) 我藏好了哦~"+originTitile,clearTimeout(titleTime)):(i.setAttribute("href","/images/favicon.ico"),document.title="(*´∇｀*) 被你发现啦~"+originTitile,titleTime=setTimeout((function(){document.title=originTitile}),2e3))}))</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Sidney God" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Sidney God</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Keep quiet time for time</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">18</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">23</span></a></li><li class="menu-item menu-item-resources"><a href="/resources/" rel="section"><i class="fa fa-book fa-fw"></i>Resources</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">Catalogue</li><li class="sidebar-nav-overview">Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">1 初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0"><span class="nav-text">2 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">2.1 参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-text">2.2 函数重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="nav-text">2.3 指针函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">2.4 函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E5%AE%8F%E5%87%BD%E6%95%B0"><span class="nav-text">2.5 宏函数</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Sidney Ding" src="/images/avatar.png"><p class="site-author-name" itemprop="name">Sidney Ding</p><div class="site-description" itemprop="description">You laugh at me for being different, but I laugh at you for being the same.</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/SidneyGod" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SidneyGod" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:sidneyding183@gmail.com" title="E-Mail → mailto:sidneyding183@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://google.com/" title="https:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">Google</a></li><li class="links-of-blogroll-item"><a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a></li></ul></div></div></div><div class="back-to-top animated" role="button" aria-label="Back to top"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class="sidebar-dimmer"></div></header><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/SidneyGod" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en"><link itemprop="mainEntityOfPage" href="https://sidneygod.gitlab.io/posts/e4de57a8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Sidney Ding"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sidney God"><meta itemprop="description" content="You laugh at me for being different, but I laugh at you for being the same."></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="[Relearning C/Cpp] Initialization and Functions | Sidney God"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">[Relearning C/Cpp] Initialization and Functions</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-04-17 16:53:30" itemprop="dateCreated datePublished" datetime="2021-04-17T16:53:30+08:00">2021-04-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-05-24 22:58:49" itemprop="dateModified" datetime="2022-05-24T22:58:49+08:00">2022-05-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a> </span>, <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Language/C-Cpp/" itemprop="url" rel="index"><span itemprop="name">C/Cpp</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Changyan: </span><a title="[Relearning C/Cpp] Initialization and Functions" href="/posts/e4de57a8/#SOHUCS" itemprop="discussionUrl"><span id="sourceId::90950ddd0e98b5b9058d67f0593e70e8" class="cy_cmt_count" itemprop="commentCount"></span> </a></span><span class="post-meta-break"></span> <span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>16k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>15 mins.</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h1><p>对象的声明可以通过初始化的过程获得初始值。主要就是见识一下C&#x2F;Cpp里面几种初始化的形式，免得大惊小怪</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言的初始化还好，怎么着都得有个 =</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> c = &#123;<span class="number">1</span>&#125;;  <span class="comment">// scalar initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="type">int</span> a[<span class="number">3</span>], b;&#125; MyType;</span><br><span class="line">MyType mm = &#123;&#123;<span class="number">1</span>&#125;, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* ptr = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cpp多了一个花样</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="type">int</span> a[<span class="number">3</span>], b;&#125; MyType;</span><br><span class="line">MyType mm &#123;&#123;<span class="number">1</span>&#125;, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> *m = <span class="keyword">new</span> MyType;</span><br><span class="line"><span class="keyword">auto</span> *m1 &#123;<span class="keyword">new</span> <span class="built_in">MyType</span>()&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>对于C来说，有显示初始化(Explicit initialization)，隐式初始化(Implicit initialization)，零初始化(Zero initialization)</p><p>显示的比较好理解，<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/scalar_initialization">scalar initialization</a>，<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/array_initialization">array initialization</a>，<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/struct_initialization">struct initialization</a>，基本都没啥好说的，经常用</p><p>隐式初始化就是你没给它显示初始化，这个时候有两种现象，一种是静态的和thread local <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/storage_duration">storage duration</a>(这四个单词我的理解是整个线程生命周期都存在的对象，全局变量？)一般会置为零初始化；还有一种automatic <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/storage_duration">storage duration</a>(auto和register修饰的，局部变量？)一般是个不确定值(野指针)</p><p>零初始化(在内存的表现形式是0？)</p><ul><li>pointers are initialized to null pointer values of their types</li><li>objects of integral types are initialized to unsigned zero</li><li>objects of floating types are initialized to positive zero</li><li>all elements of arrays, all members of structs, and the first members of unions are zero-initialized, recursively, plus all padding bits are initialized to zero</li></ul><p>对于Cpp来说呢，有静态初始化和动态初始化一说</p><p>Depending on context, the initializer may invoke:</p><ul><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_initialization">Value initialization</a>, e.g. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s{};</li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/direct_initialization">Direct initialization</a>, e.g. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s(“hello”);</li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_initialization">Copy initialization</a>, e.g. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s &#x3D; “hello”;</li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/list_initialization">List initialization</a>, e.g. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/string/basic_string">std::string</a> s{‘a’, ‘b’, ‘c’};</li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate initialization</a>, e.g. char a[3] &#x3D; {‘a’, ‘b’};</li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/reference_initialization">Reference initialization</a>, e.g. char&amp; c &#x3D; a[0];</li></ul><p>If no initializer is provided, the rules of <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/default_initialization">default initialization</a> apply.</p><p>这里有个<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/default_initialization">default initialization</a>，还有个<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/zero_initialization">zero-initialized</a>和<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constant_initialization">constant initialization</a></p><p>默认初始化呢，就当时默认构造函数好了。常量初始化呢，编译时期的。</p><h1 id="2-函数"><a href="#2-函数" class="headerlink" title="2 函数"></a>2 函数</h1><p>了解函数之前，得先了解语句，毕竟函数不就是把语句打包一下吗？这也是所有编程语言核心之处啊，这里不说编程语言，就说计算机语言，还是蛮简单的。赋值，选择，循环，跳转。</p><p>简单不代表容易呀</p><p>C&#x2F;Cpp中选择if和switch，循环for，while和do-while，跳转goto，还有continue，break，空语句，几乎每种编程语言都有，感觉也没啥要注意的，main函数不就是个函数，和<code>y=f(x)</code>很像啊</p><p>函数定义形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名() &#123;</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言比较奔放 下面那就叫一个函数 CPP需要返回值类型</span></span><br><span class="line">tmp()&#123;&#125;  <span class="comment">// 适合C89，不适合C99</span></span><br></pre></td></tr></table></figure><p>Cpp的函数比较复杂一点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    [[noreturn]] <span class="function"><span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> * <span class="type">const</span>)</span> -&gt; <span class="type">void</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了，一个破函数能有这么多修饰..</p><p><strong>返回值</strong></p><p>返回值这东西我们知道，一般写在函数名前面，然而Cpp总能给你来点不一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">int</span> a)</span></span>;   <span class="comment">// 前置返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">to_string</span><span class="params">(<span class="type">int</span> a)</span> -&gt; string</span>;  <span class="comment">// 后置返回类型</span></span><br></pre></td></tr></table></figure><p>其中auto关键字就表示后置返回类型，后置返回类型的必要性来自于模板函数，因为返回类型依赖于参数</p><p><strong>inline和constexpr</strong></p><p>在函数声明或定义中函数返回类型前加上关键字inline即把函数指定为内联，函数固定为一个地址</p><p>关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用</p><p>定义在类声明之中的成员函数将自动地成为内联函数</p><p>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高</p><p>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大</p><p>面对constexpr，胆子大一点，直接当成常量就ok了</p><p><strong>[[noreturn]]</strong></p><p>形如<code>[[...]]</code>被称为属性，属性可以置于Cpp语法的任何位置。<code>[[noreturn]]</code>放在函数声明语句开始位置，表示我们不希望函数返回任何结果</p><h2 id="2-1-参数传递"><a href="#2-1-参数传递" class="headerlink" title="2.1 参数传递"></a>2.1 参数传递</h2><p>当程序调用一个函数时，我们为该函数的形参申请内存空间，并用实参初始化形参。参数传递的语义与初始化的语义一致(严格来说是拷贝初始化)。**C中，所有函数参数都是”值传递”；Cpp中，除非形参是引用，其他情况函数参数也都是”值传递”**。所谓值传递，就是传入函数的是实参的副本，传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中，被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本值。</p><p><strong>引用参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span>&amp; ref)</span> </span>&#123;</span><br><span class="line">    ++val;</span><br><span class="line">    ++ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用函数f时，<code>++val</code>递增的是实参的副本，<code>++ref</code>递增的是实参本身</p><p>单从拷贝的角度来考虑，如果遇到大对象时，引用传递比值传递更有效。但是此时最好将引用类型的参数声明成const的，表明只是为了效率，而非想修改对象的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Large&amp; arg)</span></span>;</span><br></pre></td></tr></table></figure><p>对于小对象使用值传递方式；</p><p>对于无需修改的大对象使用const引用传递；</p><p>如需要返回计算结果，最好使用return而非通过参数修改对象；</p><p>使用右值实现移动和转发；</p><p>如果找不到合适的对象则传递指针(用nullptr表示没有对象)；</p><p>除非万不得已，否则不要使用引用传递，传递指针它不香吗？</p><p><strong>数组参数</strong></p><p>当数组作为参数时，实际传入的是指向该数组首元素的指针。也就是说，当数组作为参数传入函数时，<code>T[]</code>会转换成<code>T*</code>，所以也就没有长度一说，如果此时对数组元素赋值，则会改变该数组元素实际值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这叫复合字面量</span></span><br><span class="line">fun((<span class="type">int</span>[]) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">fun(arr);</span><br></pre></td></tr></table></figure><p><strong>列表参数</strong></p><p>一个由{}限定的列表可以作为下述形参的实参</p><p>1 类型<code>std::initializer_list&lt;T&gt;</code>，其中列表的值能隐式地转换成T</p><p>2 能用列表中的值初始化的类型</p><p>3 T类型数组的引用，其中列表值能隐式地转换成T</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(std::initializer_list&lt;T&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    std::string str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T (&amp;&amp;r)[N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f1</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);  <span class="comment">// T是int，initializer_list大小是4</span></span><br><span class="line">    <span class="built_in">f2</span>(&#123;<span class="number">1</span>, <span class="string">&quot;cpp&quot;</span>&#125;);</span><br><span class="line">    <span class="built_in">f3</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);  <span class="comment">// T是int，N是4</span></span><br><span class="line">    <span class="built_in">f4</span>(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在二义性，则initializer_list参数的函数被优先考虑</p><p><strong>数量未定参数</strong></p><p>对于某些函数，很难明确指出调用时期望的参数数量和类型，要实现这样的接口：</p><p>1 使用可变模板，安全</p><p>2 使用initializer_list作为参数类型，安全</p><p>3 使用省略号(…)结束参数列表，不安全</p><p><strong>默认参数</strong></p><p>只能给参数列表中位置靠后的参数提供默认值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tp1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// int tp2(int a = 1, int b);  // Missing default argument on parameter &#x27;b&#x27;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tp3</span><span class="params">(<span class="type">char</span>* = <span class="literal">nullptr</span>)</span></span>;  <span class="comment">// * 和 = 之间必须有空格，否则就是 *= 了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tp4</span><span class="params">(<span class="type">int</span> = <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="comment">// int tp4(int x = 8);  // Redefinition of default argument</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tp4</span><span class="params">(<span class="type">long</span> x = <span class="number">8</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-2-函数重载"><a href="#2-2-函数重载" class="headerlink" title="2.2 函数重载"></a>2.2 函数重载</h2><p>为不同数据类型的同一种操作起同一种名字称为重载。这个概念是Cpp的，C没有。重载发生在一组重载函数集的成员内部，也就是说重载函数应该位于同一个作用域。</p><p><strong>自动重载</strong></p><p>由编译器决定使用一组函数中的某一个，主要依据实参和哪个函数形参类型最匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">long</span> l)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1L</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// print(1);  // Call to &#x27;print&#x27; is ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 精确匹配，无须类型转换或者仅需简单类型转换即可实现匹配</p><p>2 执行提升后匹配，执行了整数提升(bool转int，char转int..)</p><p>3 执行标准类型转换后实现匹配，比如int转double，double转int，<code>T*</code>转<code>void*</code></p><p>4 执行用户自定义类型的转换后实现匹配</p><p>5 使用函数声明中的省略号进行匹配</p><p><strong>手动重载</strong></p><p>为了解决自动重载的二义性，方案一，增加一个函数版本；方案二，static_cast</p><p><strong>C的重载</strong></p><p>C语言真的没法重载了？不过是不能声明同样名字的函数罢了。参考：<a target="_blank" rel="noopener" href="http://locklessinc.com/articles/overloading/">http://locklessinc.com/articles/overloading/</a></p><blockquote><p>为什么Cpp可以重载而C不可以，从汇编的角度来看，Cpp汇编完了，总会在函数名字上加点什么，而C就不会</p></blockquote><p>省略号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, ...)</span>;  <span class="comment">// 着实有点僵硬，但也重载了一点，个数</span></span><br></pre></td></tr></table></figure><p>你说要重载参数类型，我觉得划不来，多写太多代码了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> param1;</span><br><span class="line">    <span class="type">int</span> param2;</span><br><span class="line">&#125; INT_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> param1;</span><br><span class="line">    <span class="type">double</span> param2;</span><br><span class="line">&#125; DOUBLE_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(ADDFUNC)</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int_add_func</span><span class="params">(<span class="type">void</span> *wParam)</span> &#123;</span><br><span class="line">    INT_PARAM *lParam = (INT_PARAM *) wParam;</span><br><span class="line">    <span class="type">int</span> res = lParam-&gt;param1 + lParam-&gt;param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">double_add_func</span><span class="params">(<span class="type">void</span> *wParam)</span> &#123;</span><br><span class="line">    DOUBLE_PARAM *lParam = (DOUBLE_PARAM *) wParam;</span><br><span class="line">    <span class="type">double</span> res = lParam-&gt;param1 + lParam-&gt;param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %f\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_func</span><span class="params">(ADDFUNC f, <span class="type">void</span> *wParam)</span> &#123;</span><br><span class="line">    f(wParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    INT_PARAM val1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    DOUBLE_PARAM val2 = &#123;<span class="number">30.5</span>, <span class="number">40.5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    add_func(int_add_func, &amp;val1);</span><br><span class="line">    add_func(double_add_func, &amp;val2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">overload_float</span><span class="params">(<span class="type">float</span> f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Use f */</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">overload_double</span><span class="params">(<span class="type">double</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Use d */</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> overload(A)\</span></span><br><span class="line"><span class="meta">    ((sizeof(A) == sizeof(float))?overload_float(A):\</span></span><br><span class="line"><span class="meta">    (sizeof(A) == sizeof(double))?overload_double(A):(void)0)</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="type">void</span> <span class="title function_">cpp_overload1</span><span class="params">(<span class="type">int</span> p1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPP One param: %d\n&quot;</span>, p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpp_overload2</span><span class="params">(<span class="type">double</span> *p1, <span class="type">const</span> <span class="type">char</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPP Two params: %p (%f) %s\n&quot;</span>, p1, *p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cpp_overload3</span><span class="params">(<span class="type">int</span> p1, <span class="type">int</span> p2, <span class="type">int</span> p3)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPP Three params: %c %d %d\n&quot;</span>, p1, p2, p3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAT(A, B) CAT2(A, B)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAT2(A, B) A ## B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cpp_overload(...)\</span></span><br><span class="line"><span class="meta">    CAT(cpp_overload, COUNT_PARMS(__VA_ARGS__))(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h2 id="2-3-指针函数"><a href="#2-3-指针函数" class="headerlink" title="2.3 指针函数"></a>2.3 指针函数</h2><p>看完参数，就该瞅瞅返回值了。基础类型的返回值没啥好看的，如果函数返回值是指针，数组，结构体..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int[] getArr();  // Function cannot return array type &#x27;int []&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; MY_POINT;</span><br><span class="line"></span><br><span class="line">MY_POINT <span class="title function_">pointFun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="comment">//return (MY_POINT) &#123;x, y&#125;;  // 直接返回的话 就不会为这个函数分配栈空间了</span></span><br><span class="line">    MY_POINT mp = &#123;x + <span class="number">1</span>, y + <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pointFun: %p, %p\n&quot;</span>, &amp;(mp.x), &amp;(mp.y));</span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="title function_">getIntP</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// return (int[]) &#123;1, 2, 3&#125;;  // 可不能返回一个局部数组 会出大事的</span></span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">3</span>);</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    *(p + <span class="number">1</span>) = <span class="number">11</span>;</span><br><span class="line">    *(p + <span class="number">2</span>) = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;getIntP: %p, %p, %p, %p\n&quot;</span>, &amp;p, p, p + <span class="number">1</span>, p + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MY_POINT point = pointFun(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="type">int</span> *p = getIntP();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;point: %d, %d\n&quot;</span>, point.x, point.y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;intP: %d, %d, %d\n&quot;</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p, %p\n&quot;</span>, &amp;p, p, p + <span class="number">1</span>, p + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %d\n&quot;</span>, (&amp;p + <span class="number">1</span>), (<span class="type">int</span>) *(&amp;p + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %d\n&quot;</span>, &amp;(point.x), point.x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pointFun: 000000000062FDC8, 000000000062FDCC</span></span><br><span class="line"><span class="comment">getIntP: 000000000062FDC8, 0000000000E72CA0, 0000000000E72CA4, 0000000000E72CA8</span></span><br><span class="line"><span class="comment">point: 6, 8</span></span><br><span class="line"><span class="comment">intP: 10, 11, 12</span></span><br><span class="line"><span class="comment">000000000062FE10, 0000000000E72CA0, 0000000000E72CA4, 0000000000E72CA8</span></span><br><span class="line"><span class="comment">000000000062FE18, 6</span></span><br><span class="line"><span class="comment">000000000062FE18, 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>首先，C&#x2F;Cpp函数不能直接返回一个<code>int[]</code>，或许是因为不知道大小吧。返回一个结构体似乎是没有问题的，而且貌似还能返回个局部变量。返回指针自然不必说，先不说有个指针函数的概念，我返回个地址咋不行了？</p><p>汇编瞅瞅，这次为了搞得更清楚一点呢，换一个新指令<code>gcc -S -fverbose-asm -O0 -m64 RetTest.c</code>，以”.”开头指令基本是伪指令，可以删了，不用看</p><p>汇编的函数跳转过程，参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ww188/article/details/82841617">linux进程运行空间分析_ww188的专栏-CSDN博客</a></p><p>内存布局参考：<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">    .ascii &quot;pointFun: %p, %p\12\0&quot;</span><br><span class="line">pointFun:</span><br><span class="line">    # 函数建立栈空间 start</span><br><span class="line">    pushq    %rbp     #</span><br><span class="line">    movq    %rsp, %rbp     #,</span><br><span class="line">    subq    $48, %rsp     #,</span><br><span class="line">    # 函数建立栈空间 end</span><br><span class="line">    movl    %ecx, 16(%rbp)     # 把参数拿出来 x</span><br><span class="line">    movl    %edx, 24(%rbp)     # y</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = &#123;x + 1, y + 2&#125;;</span><br><span class="line">    movl    16(%rbp), %eax     # x, tmp91</span><br><span class="line">    addl    $1, %eax     #, _1</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = &#123;x + 1, y + 2&#125;;</span><br><span class="line">    movl    %eax, -8(%rbp)     # _1, mp.x</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = &#123;x + 1, y + 2&#125;;</span><br><span class="line">    movl    24(%rbp), %eax     # y, tmp92</span><br><span class="line">    addl    $2, %eax     #, _2</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = &#123;x + 1, y + 2&#125;;</span><br><span class="line">    movl    %eax, -4(%rbp)     # _2, mp.y</span><br><span class="line"> # RetTest.c:17:     printf(&quot;pointFun: %p, %p\n&quot;, &amp;(mp.x), &amp;(mp.y));</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp93</span><br><span class="line">    leaq    4(%rax), %rdx     #, tmp94</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp95</span><br><span class="line">    movq    %rdx, %r8     # tmp94,</span><br><span class="line">    movq    %rax, %rdx     # tmp95,</span><br><span class="line">    leaq    .LC0(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:18:     return mp;</span><br><span class="line">    movq    -8(%rbp), %rax     # 把返回值放到rax中</span><br><span class="line"> # RetTest.c:19: &#125;</span><br><span class="line">    addq    $48, %rsp     # 上面为这个函数开辟了48字节 现在收回去</span><br><span class="line">    popq    %rbp     # 把当前rsp的值给rbp，此时rbp就是main的了，rsp再回去一个单位，还不是main的样子</span><br><span class="line">    ret     # 先把rsp的值给rip，rip就指向了main调用函数的那块了，rsp再回去一个单位，是main的样子了</span><br><span class="line">.LC1:</span><br><span class="line">    .ascii &quot;getIntP: %p, %p, %p, %p\12\0&quot;</span><br><span class="line">getIntP:</span><br><span class="line">    pushq    %rbp     #</span><br><span class="line">    movq    %rsp, %rbp     #,</span><br><span class="line">    subq    $64, %rsp     #,</span><br><span class="line"> # RetTest.c:23:     int *p = (int *) malloc(sizeof(int) * 3);</span><br><span class="line">    movl    $12, %ecx     #,</span><br><span class="line">    call    malloc     #</span><br><span class="line"> # RetTest.c:23:     int *p = (int *) malloc(sizeof(int) * 3);</span><br><span class="line">    movq    %rax, -8(%rbp)     # _1, p</span><br><span class="line"> # RetTest.c:24:     *p = 10;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.0_2</span><br><span class="line"> # RetTest.c:24:     *p = 10;</span><br><span class="line">    movl    $10, (%rax)     #, *p.0_2</span><br><span class="line"> # RetTest.c:25:     *(p + 1) = 11;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.1_3</span><br><span class="line">    addq    $4, %rax     #, _4</span><br><span class="line"> # RetTest.c:25:     *(p + 1) = 11;</span><br><span class="line">    movl    $11, (%rax)     #, *_4</span><br><span class="line"> # RetTest.c:26:     *(p + 2) = 12;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.2_5</span><br><span class="line">    addq    $8, %rax     #, _6</span><br><span class="line"> # RetTest.c:26:     *(p + 2) = 12;</span><br><span class="line">    movl    $12, (%rax)     #, *_6</span><br><span class="line"> # RetTest.c:27:     printf(&quot;getIntP: %p, %p, %p, %p\n&quot;, &amp;p, p, p + 1, p + 2);</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.3_7</span><br><span class="line">    leaq    8(%rax), %rdx     #, _8</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.4_9</span><br><span class="line">    leaq    4(%rax), %r8     #, _10</span><br><span class="line">    movq    -8(%rbp), %rcx     # p, p.5_11</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp101</span><br><span class="line">    movq    %rdx, 32(%rsp)     # _8,</span><br><span class="line">    movq    %r8, %r9     # _10,</span><br><span class="line">    movq    %rcx, %r8     # p.5_11,</span><br><span class="line">    movq    %rax, %rdx     # tmp101,</span><br><span class="line">    leaq    .LC1(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:28:     return p;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, _19</span><br><span class="line"> # RetTest.c:29: &#125;</span><br><span class="line">    addq    $64, %rsp     #,</span><br><span class="line">    popq    %rbp     #</span><br><span class="line">    ret    </span><br><span class="line">.LC2:</span><br><span class="line">    .ascii &quot;point: %d, %d\12\0&quot;</span><br><span class="line">.LC3:</span><br><span class="line">    .ascii &quot;intP: %d, %d, %d\12\0&quot;</span><br><span class="line">.LC4:</span><br><span class="line">    .ascii &quot;%p, %p, %p, %p\12\0&quot;</span><br><span class="line">.LC5:</span><br><span class="line">    .ascii &quot;%p, %d\12\0&quot;</span><br><span class="line">main:</span><br><span class="line">    # 给函数建立栈空间 start</span><br><span class="line">    pushq    %rbp     # 先将rsp向下增长一个单位(8bit)，把rbp压到栈中</span><br><span class="line">    movq    %rsp, %rbp     # 让rbp指向当前的rsp</span><br><span class="line">    subq    $64, %rsp     # rsp开辟64bit空间</span><br><span class="line">    # 给函数建立栈空间</span><br><span class="line"> # RetTest.c:31: int main() &#123;</span><br><span class="line">    call    __main     # 这个有时间再搞明白</span><br><span class="line"> # RetTest.c:32:     MY_POINT point = pointFun(5, 6);</span><br><span class="line">    movl    $6, %edx     # 参数2</span><br><span class="line">    movl    $5, %ecx     # 参数1</span><br><span class="line">    call    pointFun     # 先把rsp再增长一个单位，把rip的值压进栈，然后把pointFun值给rip 那么下一条指令就是pointFun的了</span><br><span class="line">    movq    %rax, -8(%rbp)     # rax是pointFun的返回值</span><br><span class="line"> # RetTest.c:33:     int *p = getIntP();</span><br><span class="line">    call    getIntP     #</span><br><span class="line"> # RetTest.c:33:     int *p = getIntP();</span><br><span class="line">    movq    %rax, -16(%rbp)     # _1, p</span><br><span class="line"> # RetTest.c:35:     printf(&quot;point: %d, %d\n&quot;, point.x, point.y);</span><br><span class="line">    movl    -4(%rbp), %edx     # point.y, _2</span><br><span class="line">    movl    -8(%rbp), %eax     # point.x, _3</span><br><span class="line">    movl    %edx, %r8d     # _2,</span><br><span class="line">    movl    %eax, %edx     # _3,</span><br><span class="line">    leaq    .LC2(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:36:     printf(&quot;intP: %d, %d, %d\n&quot;, *p, *(p + 1), *(p + 2));</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.6_4</span><br><span class="line">    addq    $8, %rax     #, _5</span><br><span class="line"> # RetTest.c:36:     printf(&quot;intP: %d, %d, %d\n&quot;, *p, *(p + 1), *(p + 2));</span><br><span class="line">    movl    (%rax), %ecx     # *_5, _6</span><br><span class="line"> # RetTest.c:36:     printf(&quot;intP: %d, %d, %d\n&quot;, *p, *(p + 1), *(p + 2));</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.7_7</span><br><span class="line">    addq    $4, %rax     #, _8</span><br><span class="line"> # RetTest.c:36:     printf(&quot;intP: %d, %d, %d\n&quot;, *p, *(p + 1), *(p + 2));</span><br><span class="line">    movl    (%rax), %edx     # *_8, _9</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.8_10</span><br><span class="line">    movl    (%rax), %eax     # *p.8_10, _11</span><br><span class="line">    movl    %ecx, %r9d     # _6,</span><br><span class="line">    movl    %edx, %r8d     # _9,</span><br><span class="line">    movl    %eax, %edx     # _11,</span><br><span class="line">    leaq    .LC3(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:37:     printf(&quot;%p, %p, %p, %p\n&quot;, &amp;p, p, p + 1, p + 2);</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.9_12</span><br><span class="line">    leaq    8(%rax), %rdx     #, _13</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.10_14</span><br><span class="line">    leaq    4(%rax), %r8     #, _15</span><br><span class="line">    movq    -16(%rbp), %rcx     # p, p.11_16</span><br><span class="line">    leaq    -16(%rbp), %rax     #, tmp113</span><br><span class="line">    movq    %rdx, 32(%rsp)     # _13,</span><br><span class="line">    movq    %r8, %r9     # _15,</span><br><span class="line">    movq    %rcx, %r8     # p.11_16,</span><br><span class="line">    movq    %rax, %rdx     # tmp113,</span><br><span class="line">    leaq    .LC4(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:38:     printf(&quot;%p, %d\n&quot;, (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    leaq    -16(%rbp), %rax     #, _17</span><br><span class="line">    addq    $8, %rax     #, _17</span><br><span class="line"> # RetTest.c:38:     printf(&quot;%p, %d\n&quot;, (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    movq    (%rax), %rax     # *_17, _18</span><br><span class="line"> # RetTest.c:38:     printf(&quot;%p, %d\n&quot;, (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    movl    %eax, %edx     # _19, _20</span><br><span class="line">    leaq    -16(%rbp), %rax     #, _21</span><br><span class="line">    addq    $8, %rax     #, _21</span><br><span class="line">    movl    %edx, %r8d     # _20,</span><br><span class="line">    movq    %rax, %rdx     # _21,</span><br><span class="line">    leaq    .LC5(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:39:     printf(&quot;%p, %d\n&quot;, &amp;(point.x), point.x);</span><br><span class="line">    movl    -8(%rbp), %edx     # point.x, _22</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp114</span><br><span class="line">    movl    %edx, %r8d     # _22,</span><br><span class="line">    movq    %rax, %rdx     # tmp114,</span><br><span class="line">    leaq    .LC5(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:41:     return 0;</span><br><span class="line">    movl    $0, %eax     #, _32</span><br><span class="line"> # RetTest.c:42: &#125;</span><br><span class="line">    addq    $64, %rsp     #,</span><br><span class="line">    popq    %rbp     #</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这个鬼程序还是蛮长的，用张图翻译一下</p><p><img data-src="/assets/04_Relearning-C-Cpp-Initialization-and-Functions/20210425212120_ret_value.svg" alt="20210425212120_ret_value"></p><p>基本上每个颜色就是一个步骤，还是比较容易理解的，所以说，指针函数就这样，没啥难度</p><p>再看看，为啥不能返回局部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">getArr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// int arr[] = &#123;1, 2, 3&#125;;</span></span><br><span class="line">    <span class="comment">// printf(&quot;getArr: %p, %p, %p\n&quot;, arr, arr + 1, arr + 2);</span></span><br><span class="line">    <span class="comment">// return arr;  // Address of stack memory associated with local variable &#x27;arr&#x27; returned</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>[]) &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;  <span class="comment">// 这仍然是个局部变量哦</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nothing</span><span class="params">()</span> &#123;  <span class="comment">// 真的就是nothing</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nothing: %p, %p, %p\n&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *arr = getArr();</span><br><span class="line">    nothing();</span><br><span class="line">    <span class="comment">// 猜猜值是多少</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d, %d, %d\n&quot;</span>, *arr, *(arr + <span class="number">1</span>), *(arr + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %p, %p, %p, %p\n&quot;</span>, &amp;arr, arr, arr + <span class="number">1</span>, arr + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">nothing: 000000000062FDCC, 000000000062FDC8, 000000000062FDC4</span></span><br><span class="line"><span class="comment">main: 10, 9, 8</span></span><br><span class="line"><span class="comment">main: 000000000062FE18, 000000000062FDC4, 000000000062FDC8, 000000000062FDCC</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个程序就不反汇编了，这种情况还是好的，能打印出来数据，更有甚者，程序可能会崩溃。所以<strong>永远不要返回局部变量的地址</strong></p><blockquote><p>指针和地址是一回事吗？通常是，但不完全是。我们这里都是用字节去划分内存，但是，如果是用字呢？</p></blockquote><h2 id="2-4-函数指针"><a href="#2-4-函数指针" class="headerlink" title="2.4 函数指针"></a>2.4 函数指针</h2><p>之前指针的应用都是指向数据，而函数指针不过就是把指针指向代码。这种指针可以被赋值，存放在数组中，传递给函数以及作为函数的返回值等等。简单的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> (*pFun)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p\n&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %p\n&quot;</span>, add(a, b), &amp;add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %p, %p\n&quot;</span>, pFun(a, b), pFun, &amp;pFun);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %p, %p\n&quot;</span>, (*pFun)(a, b), pFun, &amp;pFun);  <span class="comment">// *pFun的 () 不能少！！！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">000000000062FE0C, 000000000062FE08</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0, 000000000062FE00</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0, 000000000062FE00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个程序也没必要汇编了..函数add实际上存在text段的，指针pFun和a, b一样，都在栈中，只是存的值是add的地址，机制就是这么个机制。</p><p>还有就是有人喜欢把函数指针和typedef放一块看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="keyword">typedef</span> (*FUN_POINT)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FUN_POINT point;</span></span><br><span class="line"><span class="comment">// point = add;  // 为什么不能这么玩？</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FUN_POINT funPoint;</span><br><span class="line">    funPoint = add;</span><br><span class="line"></span><br><span class="line">    funPoint(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    (*funPoint)(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typedef就是重命名呀。好了，知道这么个机制，我们能做些什么？</p><p><strong>函数指针数组</strong></p><p>来看一个程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_cmd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">retrieve_cmd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update_cmd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">delete_cmd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是函数指针数组</span></span><br><span class="line"><span class="type">int</span> (*crud_cmd[])(<span class="type">int</span>, <span class="type">int</span>) = &#123;</span><br><span class="line">        create_cmd,</span><br><span class="line">        retrieve_cmd,</span><br><span class="line">        update_cmd,</span><br><span class="line">        delete_cmd</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = crud_cmd[<span class="number">1</span>](<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> b = (*crud_cmd + <span class="number">1</span>)(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把函数，指针，数组，三个词放一块还是很有意思的，比如实现一个状态机？</p><p><strong>多态</strong></p><p>多态是面向对象的概念，C语言是面向过程的语言(我觉得这句话不正确)。C语言就不能实现多态了？且看下面一个没有实质作用的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类 HUMANITY，基本特性 name，基本方法 intro</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HUMANITY</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> (*intro)(<span class="keyword">struct</span> HUMANITY *);</span><br><span class="line">&#125; HUMANITY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HUMANITY的子类 TEACHER，多了一个属性 teachNo</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HUMANITY humanity;</span><br><span class="line">    <span class="type">int</span> teachNo;</span><br><span class="line">&#125; TEACHER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TEACHER特有的 intro</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">teachIntro</span><span class="params">(HUMANITY *humanity)</span> &#123;</span><br><span class="line">    TEACHER *t = (TEACHER *) humanity;  <span class="comment">// 向下转型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a teacher. My name is %s and teachNo is %d\n&quot;</span>, t-&gt;humanity.name, t-&gt;teachNo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HUMANITY的子类 STUDENT，多了一个属性 stuNo</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    HUMANITY humanity;</span><br><span class="line">    <span class="type">long</span> stuNo;</span><br><span class="line">&#125; STUDENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STUDENT特有的 intro</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stuIntro</span><span class="params">(HUMANITY *humanity)</span> &#123;</span><br><span class="line">    STUDENT *s = (STUDENT *) humanity;  <span class="comment">// 向下转型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am a student. My name is %s and stuNo is %ld\n&quot;</span>, s-&gt;humanity.name, s-&gt;stuNo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    TEACHER *t = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TEACHER));  <span class="comment">// 创建一个TEACHER对象</span></span><br><span class="line">    t-&gt;humanity.name = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t-&gt;humanity.name, <span class="string">&quot;Wang&quot;</span>);</span><br><span class="line">    t-&gt;humanity.intro = teachIntro;</span><br><span class="line">    t-&gt;teachNo = <span class="number">12</span>;</span><br><span class="line">    HUMANITY *teacher = (HUMANITY *) t;  <span class="comment">// 向上转型</span></span><br><span class="line">    (teacher-&gt;intro)(teacher);  <span class="comment">// 实际上是 TEACHER 特有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(teacher-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line"></span><br><span class="line">    STUDENT *s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT));</span><br><span class="line">    s-&gt;humanity.name = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;humanity.name, <span class="string">&quot;Sidney Ding&quot;</span>);</span><br><span class="line">    s-&gt;humanity.intro = stuIntro;</span><br><span class="line">    s-&gt;stuNo = <span class="number">9999L</span>;</span><br><span class="line">    HUMANITY *student = (HUMANITY *) s;</span><br><span class="line">    (student-&gt;intro)(student);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(s-&gt;humanity.name);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">I am a teacher. My name is Wang and teachNo is 12</span></span><br><span class="line"><span class="comment">I am a student. My name is Sidney Ding and stuNo is 9999</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此时是不是发现C语言变得有趣多了？面向对象而已，C语言这么强大的语言必拿下。在这个例子中，不免要思考一件事，向上转型和向下转型？因为子类多余的属性是放在父类后面的，所谓的转型，我们就当是内存截断好了，父类前面的内容必然是符合的，至于后面内容，也不会丢，毕竟还是占内存的。此时再将这个父类向下转型，不过就是扩张而已，恰巧后面的就是子类多出的属性占的内存。</p><h2 id="2-5-宏函数"><a href="#2-5-宏函数" class="headerlink" title="2.5 宏函数"></a>2.5 宏函数</h2><p>这个没啥好说，<code>#define</code>这玩意本省就是编译时替换，所以注意多加括号就好了，至于宏的一些技巧，例如拼接，之前也说过了</p><p>所以，就到这里了，以后想到啥好玩的，再加进来吧！</p></div><footer class="post-footer"><div class="readEnd">------- This article is over <i class="fa fa-leaf" aria-hidden="true"></i> Thank you for your reading -------</div><div class="reward-container"><div>All I need is you needing me.</div><button>Donate</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="Sidney Ding WeChat Pay"> <span>WeChat Pay</span></div><div><img src="/images/alipay.jpg" alt="Sidney Ding Alipay"> <span>Alipay</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>Post author: </strong>Sidney Ding</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://sidneygod.gitlab.io/posts/e4de57a8/" title="[Relearning C&#x2F;Cpp] Initialization and Functions">https://sidneygod.gitlab.io/posts/e4de57a8/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li></ul></div><div class="post-tags"><a href="/tags/Relearning-C-Cpp/" rel="tag"><i class="fa fa-tag"></i> Relearning C/Cpp</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/61dcf29f/" rel="prev" title="[Relearning C/Cpp] Array and Pointer"><i class="fa fa-chevron-left"></i> [Relearning C/Cpp] Array and Pointer</a></div><div class="post-nav-item"><a href="/posts/c8ed763e/" rel="next" title="[Relearning C/Cpp] Supplement">[Relearning C/Cpp] Supplement <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="SOHUCS" sid="90950ddd0e98b5b9058d67f0593e70e8"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Sidney Ding</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>Symbols count total: </span><span title="Symbols count total">273k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>Reading time total &asymp;</span> <span title="Reading time total">4:08</span></span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a></div><div><span><i class="fa-solid fa-bomb"></i> </span><span id="showDays"></span></div><script>let seconds=1e3,minutes=60*seconds,hours=60*minutes,days=24*hours,years=365*days,birthDay=Date.UTC(2019,10,1,0,0,0);setInterval((function(){let e=new Date,s=e.getFullYear(),t=e.getMonth()+1,o=e.getDate(),a=e.getHours(),n=e.getMinutes(),r=e.getSeconds(),h=Date.UTC(s,t,o,a,n,r)-birthDay,u=Math.floor(h/years),d=Math.floor(h/days-365*u),y=Math.floor((h-(365*u+d)*days)/hours),i=Math.floor((h-(365*u+d)*days-y*hours)/minutes),l=Math.floor((h-(365*u+d)*days-y*hours-i*minutes)/seconds);document.getElementById("showDays").innerHTML="This website has been running for "+u+" years, "+d+" days, "+y+" hours, "+i+" minutes, "+l+" seconds"}),1e3)</script></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.8/pdfobject.min.js","integrity":"sha256-tu9j5pBilBQrWSDePOOajCUdz6hWsid/lBNzK4KgEPM="},"url":"/lib/pdf/web/viewer"}</script><script src="/js/third-party/tags/pdf.js"></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script><script src="/js/third-party/tags/mermaid.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.2.0/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://sidneygod.gitlab.io/posts/e4de57a8/"}</script><script src="/js/third-party/quicklink.js"></script><script src="/js/love.js"></script><script src="/js/show-text.js"></script><script src="/js/snowflakes.min.js"></script><script src="/js/activate-power-mode.min.js"></script><script>new Snowflakes({color:"rgba(129, 161, 193, 0.87)"}),POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cyw6GhFAo","appkey":"39c16599e32c872d8661763f6b93d932"}</script><script src="/js/third-party/comments/changyan.js"></script></body></html>