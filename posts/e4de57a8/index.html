<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=7.4.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.4.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.4.1"><link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222"><link rel="alternate" href="/atom.xml" title="Sidney God" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=7.4.1"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.4.1",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!0,lazyload:!0,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"},sidebarPadding:40}</script><meta name="description" content="1 初始化对象的声明可以通过初始化的过程获得初始值。主要就是见识一下C&#x2F;Cpp里面几种初始化的形式，免得大惊小怪1234567891011121314151617&#x2F;&#x2F; C语言的初始化还好，怎么着都得有个 &#x3D;int a[3] &#x3D; {1, 2, 3};int b &#x3D; 0;int c &#x3D; {1};  &#x2F;&#x2F; scalar initializationtypedef struct {int a[3], b;"><meta property="og:type" content="article"><meta property="og:title" content="[Relearning C&#x2F;Cpp] Initialization and Functions"><meta property="og:url" content="https://sidneygod.github.io/posts/e4de57a8/index.html"><meta property="og:site_name" content="Sidney God"><meta property="og:description" content="1 初始化对象的声明可以通过初始化的过程获得初始值。主要就是见识一下C&#x2F;Cpp里面几种初始化的形式，免得大惊小怪1234567891011121314151617&#x2F;&#x2F; C语言的初始化还好，怎么着都得有个 &#x3D;int a[3] &#x3D; {1, 2, 3};int b &#x3D; 0;int c &#x3D; {1};  &#x2F;&#x2F; scalar initializationtypedef struct {int a[3], b;"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://gitee.com/SidneyGod/ImagePlace/raw/master/20210425212120_ret_value.svg"><meta property="article:published_time" content="2021-04-17T08:53:30.000Z"><meta property="article:modified_time" content="2021-12-26T15:07:42.196Z"><meta property="article:author" content="Sidney Ding"><meta property="article:tag" content="Relearning C&#x2F;Cpp"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/SidneyGod/ImagePlace/raw/master/20210425212120_ret_value.svg"><link rel="canonical" href="https://sidneygod.github.io/posts/e4de57a8/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>[Relearning C/Cpp] Initialization and Functions | Sidney God</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Sidney God</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Keep quiet time for time</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">18</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">22</span></a></li><li class="menu-item menu-item-resources"><a href="/resources/" rel="section"><i class="fa fa-fw fa-book"></i>Resources</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="reading-progress-bar"></div><a class="book-mark-link book-mark-link-fixed" href="#"></a> <a href="https://github.com/SidneyGod" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article itemscope itemtype="http://schema.org/Article"><div class="post-block post"><link itemprop="mainEntityOfPage" href="https://sidneygod.github.io/posts/e4de57a8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Sidney Ding"><meta itemprop="description" content="You laugh at me for being different, but I laugh at you for being the same."><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sidney God"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">[Relearning C/Cpp] Initialization and Functions</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-04-17 16:53:30" itemprop="dateCreated datePublished" datetime="2021-04-17T16:53:30+08:00">2021-04-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2021-12-26 23:07:42" itemprop="dateModified" datetime="2021-12-26T23:07:42+08:00">2021-12-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Language/C-Cpp/" itemprop="url" rel="index"><span itemprop="name">C/Cpp</span></a></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine: </span><a title="valine" href="/posts/e4de57a8/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/e4de57a8/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>20k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>33 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><html><head></head><body><h1 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h1><p>对象的声明可以通过初始化的过程获得初始值。主要就是见识一下C/Cpp里面几种初始化的形式，免得大惊小怪</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言的初始化还好，怎么着都得有个 =</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c = {<span class="number">1</span>};  <span class="comment">// scalar initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span><span class="keyword">int</span> a[<span class="number">3</span>], b;} MyType;</span><br><span class="line">MyType mm = {{<span class="number">1</span>}, <span class="number">3</span>};</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* ptr = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cpp多了一个花样</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="keyword">int</span> b {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span><span class="keyword">int</span> a[<span class="number">3</span>], b;} MyType;</span><br><span class="line">MyType mm {{<span class="number">1</span>}, <span class="number">3</span>};</span><br><span class="line"><span class="keyword">auto</span> *m = <span class="keyword">new</span> MyType;</span><br><span class="line"><span class="keyword">auto</span> *m1 {<span class="keyword">new</span> MyType()};</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>对于C来说，有显示初始化(Explicit initialization)，隐式初始化(Implicit initialization)，零初始化(Zero initialization)</p><p>显示的比较好理解，<a href="https://en.cppreference.com/w/c/language/scalar_initialization" target="_blank" rel="noopener">scalar initialization</a>，<a href="https://en.cppreference.com/w/c/language/array_initialization" target="_blank" rel="noopener">array initialization</a>，<a href="https://en.cppreference.com/w/c/language/struct_initialization" target="_blank" rel="noopener">struct initialization</a>，基本都没啥好说的，经常用</p><p>隐式初始化就是你没给它显示初始化，这个时候有两种现象，一种是静态的和thread local <a href="https://en.cppreference.com/w/c/language/storage_duration" target="_blank" rel="noopener">storage duration</a>(这四个单词我的理解是整个线程生命周期都存在的对象，全局变量？)一般会置为零初始化；还有一种automatic <a href="https://en.cppreference.com/w/c/language/storage_duration" target="_blank" rel="noopener">storage duration</a>(auto和register修饰的，局部变量？)一般是个不确定值(野指针)</p><p>零初始化(在内存的表现形式是0？)</p><ul><li>pointers are initialized to null pointer values of their types</li><li>objects of integral types are initialized to unsigned zero</li><li>objects of floating types are initialized to positive zero</li><li>all elements of arrays, all members of structs, and the first members of unions are zero-initialized, recursively, plus all padding bits are initialized to zero</li></ul><p>对于Cpp来说呢，有静态初始化和动态初始化一说</p><p>Depending on context, the initializer may invoke:</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/value_initialization" target="_blank" rel="noopener">Value initialization</a>, e.g. <a href="http://en.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener">std::string</a> s{};</li><li><a href="https://en.cppreference.com/w/cpp/language/direct_initialization" target="_blank" rel="noopener">Direct initialization</a>, e.g. <a href="http://en.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener">std::string</a> s(“hello”);</li><li><a href="https://en.cppreference.com/w/cpp/language/copy_initialization" target="_blank" rel="noopener">Copy initialization</a>, e.g. <a href="http://en.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener">std::string</a> s = “hello”;</li><li><a href="https://en.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener">List initialization</a>, e.g. <a href="http://en.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener">std::string</a> s{‘a’, ‘b’, ‘c’};</li><li><a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" target="_blank" rel="noopener">Aggregate initialization</a>, e.g. char a[3] = {‘a’, ‘b’};</li><li><a href="https://en.cppreference.com/w/cpp/language/reference_initialization" target="_blank" rel="noopener">Reference initialization</a>, e.g. char&amp; c = a[0];</li></ul><p>If no initializer is provided, the rules of <a href="https://en.cppreference.com/w/cpp/language/default_initialization" target="_blank" rel="noopener">default initialization</a> apply.</p><p>这里有个<a href="https://en.cppreference.com/w/cpp/language/default_initialization" target="_blank" rel="noopener">default initialization</a>，还有个<a href="https://en.cppreference.com/w/cpp/language/zero_initialization" target="_blank" rel="noopener">zero-initialized</a>和<a href="https://en.cppreference.com/w/cpp/language/constant_initialization" target="_blank" rel="noopener">constant initialization</a></p><p>默认初始化呢，就当时默认构造函数好了。常量初始化呢，编译时期的。</p><h1 id="2-函数"><a href="#2-函数" class="headerlink" title="2 函数"></a>2 函数</h1><p>了解函数之前，得先了解语句，毕竟函数不就是把语句打包一下吗？这也是所有编程语言核心之处啊，这里不说编程语言，就说计算机语言，还是蛮简单的。赋值，选择，循环，跳转。</p><p>简单不代表容易呀</p><p>C/Cpp中选择if和switch，循环for，while和do-while，跳转goto，还有continue，break，空语句，几乎每种编程语言都有，感觉也没啥要注意的，main函数不就是个函数，和<code>y=f(x)</code>很像啊</p><p>函数定义形式如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名() {</span><br><span class="line">    语句;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言比较奔放 下面那就叫一个函数 CPP需要返回值类型</span></span><br><span class="line">tmp(){}  <span class="comment">// 适合C89，不适合C99</span></span><br></pre></td></tr></tbody></table></figure><p>Cpp的函数比较复杂一点</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br><span class="line">    [[noreturn]] virtual inline auto f(const unsigned long int * const) -&gt; void const noexcept;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看到了，一个破函数能有这么多修饰..</p><p><strong>返回值</strong></p><p>返回值这东西我们知道，一般写在函数名前面，然而Cpp总能给你来点不一样的</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string</span><span class="params">(<span class="keyword">int</span> a)</span></span>;   <span class="comment">// 前置返回类型</span></span><br><span class="line">auto to_string(int a) -&gt; string;  // 后置返回类型</span><br></pre></td></tr></tbody></table></figure><p>其中auto关键字就表示后置返回类型，后置返回类型的必要性来自于模板函数，因为返回类型依赖于参数</p><p><strong>inline和constexpr</strong></p><p>在函数声明或定义中函数返回类型前加上关键字inline即把函数指定为内联，函数固定为一个地址</p><p>关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用</p><p>定义在类声明之中的成员函数将自动地成为内联函数</p><p>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高</p><p>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大</p><p>面对constexpr，胆子大一点，直接当成常量就ok了</p><p><strong>[[noreturn]]</strong></p><p>形如<code>[[...]]</code>被称为属性，属性可以置于Cpp语法的任何位置。<code>[[noreturn]]</code>放在函数声明语句开始位置，表示我们不希望函数返回任何结果</p><h2 id="2-1-参数传递"><a href="#2-1-参数传递" class="headerlink" title="2.1 参数传递"></a>2.1 参数传递</h2><p>当程序调用一个函数时，我们为该函数的形参申请内存空间，并用实参初始化形参。参数传递的语义与初始化的语义一致(严格来说是拷贝初始化)。<strong>C中，所有函数参数都是”值传递”；Cpp中，除非形参是引用，其他情况函数参数也都是”值传递”</strong>。所谓值传递，就是传入函数的是实参的副本，传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中，被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本值。</p><p><strong>引用参数</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span>&amp; ref)</span> </span>{</span><br><span class="line">    ++val;</span><br><span class="line">    ++ref;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当调用函数f时，<code>++val</code>递增的是实参的副本，<code>++ref</code>递增的是实参本身</p><p>单从拷贝的角度来考虑，如果遇到大对象时，引用传递比值传递更有效。但是此时最好将引用类型的参数声明成const的，表明只是为了效率，而非想修改对象的值</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Large&amp; arg)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>对于小对象使用值传递方式；</p><p>对于无需修改的大对象使用const引用传递；</p><p>如需要返回计算结果，最好使用return而非通过参数修改对象；</p><p>使用右值实现移动和转发；</p><p>如果找不到合适的对象则传递指针(用nullptr表示没有对象)；</p><p>除非万不得已，否则不要使用引用传递，传递指针它不香吗？</p><p><strong>数组参数</strong></p><p>当数组作为参数时，实际传入的是指向该数组首元素的指针。也就是说，当数组作为参数传入函数时，<code>T[]</code>会转换成<code>T*</code>，所以也就没有长度一说，如果此时对数组元素赋值，则会改变该数组元素实际值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这叫复合字面量</span></span><br><span class="line">fun((<span class="keyword">int</span>[]) {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>});</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line">fun(arr);</span><br></pre></td></tr></tbody></table></figure><p><strong>列表参数</strong></p><p>一个由{}限定的列表可以作为下述形参的实参</p><p>1 类型<code>std::initializer_list&lt;T&gt;</code>，其中列表的值能隐式地转换成T</p><p>2 能用列表中的值初始化的类型</p><p>3 T类型数组的引用，其中列表值能隐式地转换成T</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f1</span>(<span class="title">std</span>:</span>:<span class="built_in">initializer_list</span>&lt;T&gt;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f3</span>(<span class="title">T</span> (&amp;&amp;<span class="title">r</span>)[<span class="title">N</span>]);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>{</span><br><span class="line">    f1({<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>});  <span class="comment">// T是int，initializer_list大小是4</span></span><br><span class="line">    f2({<span class="number">1</span>, <span class="string">"cpp"</span>});</span><br><span class="line">    f3({<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>});  <span class="comment">// T是int，N是4</span></span><br><span class="line">    f4({<span class="number">1</span>});</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果存在二义性，则initializer_list参数的函数被优先考虑</p><p><strong>数量未定参数</strong></p><p>对于某些函数，很难明确指出调用时期望的参数数量和类型，要实现这样的接口：</p><p>1 使用可变模板，安全</p><p>2 使用initializer_list作为参数类型，安全</p><p>3 使用省略号(…)结束参数列表，不安全</p><p><strong>默认参数</strong></p><p>只能给参数列表中位置靠后的参数提供默认值</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tp1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// int tp2(int a = 1, int b);  // Missing default argument on parameter 'b'</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tp3</span><span class="params">(<span class="keyword">char</span>* = <span class="literal">nullptr</span>)</span></span>;  <span class="comment">// * 和 = 之间必须有空格，否则就是 *= 了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tp4</span><span class="params">(<span class="keyword">int</span> = <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="comment">// int tp4(int x = 8);  // Redefinition of default argument</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tp4</span><span class="params">(<span class="keyword">long</span> x = <span class="number">8</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-函数重载"><a href="#2-2-函数重载" class="headerlink" title="2.2 函数重载"></a>2.2 函数重载</h2><p>为不同数据类型的同一种操作起同一种名字称为重载。这个概念是Cpp的，C没有。重载发生在一组重载函数集的成员内部，也就是说重载函数应该位于同一个作用域。</p><p><strong>自动重载</strong></p><p>由编译器决定使用一组函数中的某一个，主要依据实参和哪个函数形参类型最匹配</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> l)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>{</span><br><span class="line">    print(<span class="number">1L</span>);</span><br><span class="line">    print(<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// print(1);  // Call to 'print' is ambiguous</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>1 精确匹配，无须类型转换或者仅需简单类型转换即可实现匹配</p><p>2 执行提升后匹配，执行了整数提升(bool转int，char转int..)</p><p>3 执行标准类型转换后实现匹配，比如int转double，double转int，<code>T*</code>转<code>void*</code></p><p>4 执行用户自定义类型的转换后实现匹配</p><p>5 使用函数声明中的省略号进行匹配</p><p><strong>手动重载</strong></p><p>为了解决自动重载的二义性，方案一，增加一个函数版本；方案二，static_cast</p><p><strong>C的重载</strong></p><p>C语言真的没法重载了？不过是不能声明同样名字的函数罢了。参考：<a href="http://locklessinc.com/articles/overloading/" target="_blank" rel="noopener">http://locklessinc.com/articles/overloading/</a></p><blockquote><p>为什么Cpp可以重载而C不可以，从汇编的角度来看，Cpp汇编完了，总会在函数名字上加点什么，而C就不会</p></blockquote><p>省略号</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, ...)</span></span>;  <span class="comment">// 着实有点僵硬，但也重载了一点，个数</span></span><br></pre></td></tr></tbody></table></figure><p>你说要重载参数类型，我觉得划不来，多写太多代码了</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> param1;</span><br><span class="line">    <span class="keyword">int</span> param2;</span><br><span class="line">} INT_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">double</span> param1;</span><br><span class="line">    <span class="keyword">double</span> param2;</span><br><span class="line">} DOUBLE_PARAM;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(ADDFUNC)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int_add_func</span><span class="params">(<span class="keyword">void</span> *wParam)</span> </span>{</span><br><span class="line">    INT_PARAM *lParam = (INT_PARAM *) wParam;</span><br><span class="line">    <span class="keyword">int</span> res = lParam-&gt;param1 + lParam-&gt;param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, res);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_add_func</span><span class="params">(<span class="keyword">void</span> *wParam)</span> </span>{</span><br><span class="line">    DOUBLE_PARAM *lParam = (DOUBLE_PARAM *) wParam;</span><br><span class="line">    <span class="keyword">double</span> res = lParam-&gt;param1 + lParam-&gt;param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %f\n"</span>, res);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_func</span><span class="params">(ADDFUNC f, <span class="keyword">void</span> *wParam)</span> </span>{</span><br><span class="line">    f(wParam);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    INT_PARAM val1 = {<span class="number">10</span>, <span class="number">20</span>};</span><br><span class="line">    DOUBLE_PARAM val2 = {<span class="number">30.5</span>, <span class="number">40.5</span>};</span><br><span class="line"></span><br><span class="line">    add_func(int_add_func, &amp;val1);</span><br><span class="line">    add_func(double_add_func, &amp;val2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">overload_float</span><span class="params">(<span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Use f */</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">overload_double</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* Use d */</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> overload(A)\</span></span><br><span class="line">    ((<span class="keyword">sizeof</span>(A) == <span class="keyword">sizeof</span>(<span class="keyword">float</span>))?overload_float(A):\</span><br><span class="line">    (<span class="keyword">sizeof</span>(A) == <span class="keyword">sizeof</span>(<span class="keyword">double</span>))?overload_double(A):(<span class="keyword">void</span>)<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpp_overload1</span><span class="params">(<span class="keyword">int</span> p1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CPP One param: %d\n"</span>, p1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpp_overload2</span><span class="params">(<span class="keyword">double</span> *p1, <span class="keyword">const</span> <span class="keyword">char</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CPP Two params: %p (%f) %s\n"</span>, p1, *p1, p2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpp_overload3</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2, <span class="keyword">int</span> p3)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CPP Three params: %c %d %d\n"</span>, p1, p2, p3);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT(A, B) CAT2(A, B)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT2(A, B) A ## B</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpp_overload(...)\</span></span><br><span class="line">    CAT(cpp_overload, COUNT_PARMS(__VA_ARGS__))(__VA_ARGS__)</span><br></pre></td></tr></tbody></table></figure><h2 id="2-3-指针函数"><a href="#2-3-指针函数" class="headerlink" title="2.3 指针函数"></a>2.3 指针函数</h2><p>看完参数，就该瞅瞅返回值了。基础类型的返回值没啥好看的，如果函数返回值是指针，数组，结构体..</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int[] getArr();  // Function cannot return array type 'int []'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">} MY_POINT;</span><br><span class="line"></span><br><span class="line"><span class="function">MY_POINT <span class="title">pointFun</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="comment">//return (MY_POINT) {x, y};  // 直接返回的话 就不会为这个函数分配栈空间了</span></span><br><span class="line">    MY_POINT mp = {x + <span class="number">1</span>, y + <span class="number">2</span>};</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pointFun: %p, %p\n"</span>, &amp;(mp.x), &amp;(mp.y));</span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getIntP</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// return (int[]) {1, 2, 3};  // 可不能返回一个局部数组 会出大事的</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">3</span>);</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    *(p + <span class="number">1</span>) = <span class="number">11</span>;</span><br><span class="line">    *(p + <span class="number">2</span>) = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"getIntP: %p, %p, %p, %p\n"</span>, &amp;p, p, p + <span class="number">1</span>, p + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    MY_POINT point = pointFun(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">int</span> *p = getIntP();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"point: %d, %d\n"</span>, point.x, point.y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"intP: %d, %d, %d\n"</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p, %p, %p\n"</span>, &amp;p, p, p + <span class="number">1</span>, p + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %d\n"</span>, (&amp;p + <span class="number">1</span>), (<span class="keyword">int</span>) *(&amp;p + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %d\n"</span>, &amp;(point.x), point.x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pointFun: 000000000062FDC8, 000000000062FDCC</span></span><br><span class="line"><span class="comment">getIntP: 000000000062FDC8, 0000000000E72CA0, 0000000000E72CA4, 0000000000E72CA8</span></span><br><span class="line"><span class="comment">point: 6, 8</span></span><br><span class="line"><span class="comment">intP: 10, 11, 12</span></span><br><span class="line"><span class="comment">000000000062FE10, 0000000000E72CA0, 0000000000E72CA4, 0000000000E72CA8</span></span><br><span class="line"><span class="comment">000000000062FE18, 6</span></span><br><span class="line"><span class="comment">000000000062FE18, 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>首先，C/Cpp函数不能直接返回一个<code>int[]</code>，或许是因为不知道大小吧。返回一个结构体似乎是没有问题的，而且貌似还能返回个局部变量。返回指针自然不必说，先不说有个指针函数的概念，我返回个地址咋不行了？</p><p>汇编瞅瞅，这次为了搞得更清楚一点呢，换一个新指令<code>gcc -S -fverbose-asm -O0 -m64 RetTest.c</code>，以”.”开头指令基本是伪指令，可以删了，不用看</p><p>汇编的函数跳转过程，参考：<a href="https://blog.csdn.net/ww188/article/details/82841617" target="_blank" rel="noopener">linux进程运行空间分析_ww188的专栏-CSDN博客</a></p><p>内存布局参考：<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">    .ascii "pointFun: %p, %p\12\0"</span><br><span class="line">pointFun:</span><br><span class="line">    # 函数建立栈空间 start</span><br><span class="line">    pushq    %rbp     #</span><br><span class="line">    movq    %rsp, %rbp     #,</span><br><span class="line">    subq    $48, %rsp     #,</span><br><span class="line">    # 函数建立栈空间 end</span><br><span class="line">    movl    %ecx, 16(%rbp)     # 把参数拿出来 x</span><br><span class="line">    movl    %edx, 24(%rbp)     # y</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = {x + 1, y + 2};</span><br><span class="line">    movl    16(%rbp), %eax     # x, tmp91</span><br><span class="line">    addl    $1, %eax     #, _1</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = {x + 1, y + 2};</span><br><span class="line">    movl    %eax, -8(%rbp)     # _1, mp.x</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = {x + 1, y + 2};</span><br><span class="line">    movl    24(%rbp), %eax     # y, tmp92</span><br><span class="line">    addl    $2, %eax     #, _2</span><br><span class="line"> # RetTest.c:16:     MY_POINT mp = {x + 1, y + 2};</span><br><span class="line">    movl    %eax, -4(%rbp)     # _2, mp.y</span><br><span class="line"> # RetTest.c:17:     printf("pointFun: %p, %p\n", &amp;(mp.x), &amp;(mp.y));</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp93</span><br><span class="line">    leaq    4(%rax), %rdx     #, tmp94</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp95</span><br><span class="line">    movq    %rdx, %r8     # tmp94,</span><br><span class="line">    movq    %rax, %rdx     # tmp95,</span><br><span class="line">    leaq    .LC0(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:18:     return mp;</span><br><span class="line">    movq    -8(%rbp), %rax     # 把返回值放到rax中</span><br><span class="line"> # RetTest.c:19: }</span><br><span class="line">    addq    $48, %rsp     # 上面为这个函数开辟了48字节 现在收回去</span><br><span class="line">    popq    %rbp     # 把当前rsp的值给rbp，此时rbp就是main的了，rsp再回去一个单位，还不是main的样子</span><br><span class="line">    ret     # 先把rsp的值给rip，rip就指向了main调用函数的那块了，rsp再回去一个单位，是main的样子了</span><br><span class="line">.LC1:</span><br><span class="line">    .ascii "getIntP: %p, %p, %p, %p\12\0"</span><br><span class="line">getIntP:</span><br><span class="line">    pushq    %rbp     #</span><br><span class="line">    movq    %rsp, %rbp     #,</span><br><span class="line">    subq    $64, %rsp     #,</span><br><span class="line"> # RetTest.c:23:     int *p = (int *) malloc(sizeof(int) * 3);</span><br><span class="line">    movl    $12, %ecx     #,</span><br><span class="line">    call    malloc     #</span><br><span class="line"> # RetTest.c:23:     int *p = (int *) malloc(sizeof(int) * 3);</span><br><span class="line">    movq    %rax, -8(%rbp)     # _1, p</span><br><span class="line"> # RetTest.c:24:     *p = 10;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.0_2</span><br><span class="line"> # RetTest.c:24:     *p = 10;</span><br><span class="line">    movl    $10, (%rax)     #, *p.0_2</span><br><span class="line"> # RetTest.c:25:     *(p + 1) = 11;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.1_3</span><br><span class="line">    addq    $4, %rax     #, _4</span><br><span class="line"> # RetTest.c:25:     *(p + 1) = 11;</span><br><span class="line">    movl    $11, (%rax)     #, *_4</span><br><span class="line"> # RetTest.c:26:     *(p + 2) = 12;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.2_5</span><br><span class="line">    addq    $8, %rax     #, _6</span><br><span class="line"> # RetTest.c:26:     *(p + 2) = 12;</span><br><span class="line">    movl    $12, (%rax)     #, *_6</span><br><span class="line"> # RetTest.c:27:     printf("getIntP: %p, %p, %p, %p\n", &amp;p, p, p + 1, p + 2);</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.3_7</span><br><span class="line">    leaq    8(%rax), %rdx     #, _8</span><br><span class="line">    movq    -8(%rbp), %rax     # p, p.4_9</span><br><span class="line">    leaq    4(%rax), %r8     #, _10</span><br><span class="line">    movq    -8(%rbp), %rcx     # p, p.5_11</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp101</span><br><span class="line">    movq    %rdx, 32(%rsp)     # _8,</span><br><span class="line">    movq    %r8, %r9     # _10,</span><br><span class="line">    movq    %rcx, %r8     # p.5_11,</span><br><span class="line">    movq    %rax, %rdx     # tmp101,</span><br><span class="line">    leaq    .LC1(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:28:     return p;</span><br><span class="line">    movq    -8(%rbp), %rax     # p, _19</span><br><span class="line"> # RetTest.c:29: }</span><br><span class="line">    addq    $64, %rsp     #,</span><br><span class="line">    popq    %rbp     #</span><br><span class="line">    ret    </span><br><span class="line">.LC2:</span><br><span class="line">    .ascii "point: %d, %d\12\0"</span><br><span class="line">.LC3:</span><br><span class="line">    .ascii "intP: %d, %d, %d\12\0"</span><br><span class="line">.LC4:</span><br><span class="line">    .ascii "%p, %p, %p, %p\12\0"</span><br><span class="line">.LC5:</span><br><span class="line">    .ascii "%p, %d\12\0"</span><br><span class="line">main:</span><br><span class="line">    # 给函数建立栈空间 start</span><br><span class="line">    pushq    %rbp     # 先将rsp向下增长一个单位(8bit)，把rbp压到栈中</span><br><span class="line">    movq    %rsp, %rbp     # 让rbp指向当前的rsp</span><br><span class="line">    subq    $64, %rsp     # rsp开辟64bit空间</span><br><span class="line">    # 给函数建立栈空间</span><br><span class="line"> # RetTest.c:31: int main() {</span><br><span class="line">    call    __main     # 这个有时间再搞明白</span><br><span class="line"> # RetTest.c:32:     MY_POINT point = pointFun(5, 6);</span><br><span class="line">    movl    $6, %edx     # 参数2</span><br><span class="line">    movl    $5, %ecx     # 参数1</span><br><span class="line">    call    pointFun     # 先把rsp再增长一个单位，把rip的值压进栈，然后把pointFun值给rip 那么下一条指令就是pointFun的了</span><br><span class="line">    movq    %rax, -8(%rbp)     # rax是pointFun的返回值</span><br><span class="line"> # RetTest.c:33:     int *p = getIntP();</span><br><span class="line">    call    getIntP     #</span><br><span class="line"> # RetTest.c:33:     int *p = getIntP();</span><br><span class="line">    movq    %rax, -16(%rbp)     # _1, p</span><br><span class="line"> # RetTest.c:35:     printf("point: %d, %d\n", point.x, point.y);</span><br><span class="line">    movl    -4(%rbp), %edx     # point.y, _2</span><br><span class="line">    movl    -8(%rbp), %eax     # point.x, _3</span><br><span class="line">    movl    %edx, %r8d     # _2,</span><br><span class="line">    movl    %eax, %edx     # _3,</span><br><span class="line">    leaq    .LC2(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:36:     printf("intP: %d, %d, %d\n", *p, *(p + 1), *(p + 2));</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.6_4</span><br><span class="line">    addq    $8, %rax     #, _5</span><br><span class="line"> # RetTest.c:36:     printf("intP: %d, %d, %d\n", *p, *(p + 1), *(p + 2));</span><br><span class="line">    movl    (%rax), %ecx     # *_5, _6</span><br><span class="line"> # RetTest.c:36:     printf("intP: %d, %d, %d\n", *p, *(p + 1), *(p + 2));</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.7_7</span><br><span class="line">    addq    $4, %rax     #, _8</span><br><span class="line"> # RetTest.c:36:     printf("intP: %d, %d, %d\n", *p, *(p + 1), *(p + 2));</span><br><span class="line">    movl    (%rax), %edx     # *_8, _9</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.8_10</span><br><span class="line">    movl    (%rax), %eax     # *p.8_10, _11</span><br><span class="line">    movl    %ecx, %r9d     # _6,</span><br><span class="line">    movl    %edx, %r8d     # _9,</span><br><span class="line">    movl    %eax, %edx     # _11,</span><br><span class="line">    leaq    .LC3(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:37:     printf("%p, %p, %p, %p\n", &amp;p, p, p + 1, p + 2);</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.9_12</span><br><span class="line">    leaq    8(%rax), %rdx     #, _13</span><br><span class="line">    movq    -16(%rbp), %rax     # p, p.10_14</span><br><span class="line">    leaq    4(%rax), %r8     #, _15</span><br><span class="line">    movq    -16(%rbp), %rcx     # p, p.11_16</span><br><span class="line">    leaq    -16(%rbp), %rax     #, tmp113</span><br><span class="line">    movq    %rdx, 32(%rsp)     # _13,</span><br><span class="line">    movq    %r8, %r9     # _15,</span><br><span class="line">    movq    %rcx, %r8     # p.11_16,</span><br><span class="line">    movq    %rax, %rdx     # tmp113,</span><br><span class="line">    leaq    .LC4(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:38:     printf("%p, %d\n", (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    leaq    -16(%rbp), %rax     #, _17</span><br><span class="line">    addq    $8, %rax     #, _17</span><br><span class="line"> # RetTest.c:38:     printf("%p, %d\n", (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    movq    (%rax), %rax     # *_17, _18</span><br><span class="line"> # RetTest.c:38:     printf("%p, %d\n", (&amp;p + 1), (int) *(&amp;p + 1));</span><br><span class="line">    movl    %eax, %edx     # _19, _20</span><br><span class="line">    leaq    -16(%rbp), %rax     #, _21</span><br><span class="line">    addq    $8, %rax     #, _21</span><br><span class="line">    movl    %edx, %r8d     # _20,</span><br><span class="line">    movq    %rax, %rdx     # _21,</span><br><span class="line">    leaq    .LC5(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:39:     printf("%p, %d\n", &amp;(point.x), point.x);</span><br><span class="line">    movl    -8(%rbp), %edx     # point.x, _22</span><br><span class="line">    leaq    -8(%rbp), %rax     #, tmp114</span><br><span class="line">    movl    %edx, %r8d     # _22,</span><br><span class="line">    movq    %rax, %rdx     # tmp114,</span><br><span class="line">    leaq    .LC5(%rip), %rcx     #,</span><br><span class="line">    call    printf     #</span><br><span class="line"> # RetTest.c:41:     return 0;</span><br><span class="line">    movl    $0, %eax     #, _32</span><br><span class="line"> # RetTest.c:42: }</span><br><span class="line">    addq    $64, %rsp     #,</span><br><span class="line">    popq    %rbp     #</span><br><span class="line">    ret</span><br></pre></td></tr></tbody></table></figure><p>这个鬼程序还是蛮长的，用张图翻译一下</p><p><img data-src="https://gitee.com/SidneyGod/ImagePlace/raw/master/20210425212120_ret_value.svg"></p><p>基本上每个颜色就是一个步骤，还是比较容易理解的，所以说，指针函数就这样，没啥难度</p><p>再看看，为啥不能返回局部变量</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">getArr</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// int arr[] = {1, 2, 3};</span></span><br><span class="line">    <span class="comment">// printf("getArr: %p, %p, %p\n", arr, arr + 1, arr + 2);</span></span><br><span class="line">    <span class="comment">// return arr;  // Address of stack memory associated with local variable 'arr' returned</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>[]) {<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>};  <span class="comment">// 这仍然是个局部变量哦</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nothing</span><span class="params">()</span> </span>{  <span class="comment">// 真的就是nothing</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nothing: %p, %p, %p\n"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> *arr = getArr();</span><br><span class="line">    nothing();</span><br><span class="line">    <span class="comment">// 猜猜值是多少</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main: %d, %d, %d\n"</span>, *arr, *(arr + <span class="number">1</span>), *(arr + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main: %p, %p, %p, %p\n"</span>, &amp;arr, arr, arr + <span class="number">1</span>, arr + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">nothing: 000000000062FDCC, 000000000062FDC8, 000000000062FDC4</span></span><br><span class="line"><span class="comment">main: 10, 9, 8</span></span><br><span class="line"><span class="comment">main: 000000000062FE18, 000000000062FDC4, 000000000062FDC8, 000000000062FDCC</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>这个程序就不反汇编了，这种情况还是好的，能打印出来数据，更有甚者，程序可能会崩溃。所以<strong>永远不要返回局部变量的地址</strong></p><blockquote><p>指针和地址是一回事吗？通常是，但不完全是。我们这里都是用字节去划分内存，但是，如果是用字呢？</p></blockquote><h2 id="2-4-函数指针"><a href="#2-4-函数指针" class="headerlink" title="2.4 函数指针"></a>2.4 函数指针</h2><p>之前指针的应用都是指向数据，而函数指针不过就是把指针指向代码。这种指针可以被赋值，存放在数组中，传递给函数以及作为函数的返回值等等。简单的例子</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> (*pFun)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p, %p\n"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %p\n"</span>, add(a, b), &amp;add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %p, %p\n"</span>, pFun(a, b), pFun, &amp;pFun);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %p, %p\n"</span>, (*pFun)(a, b), pFun, &amp;pFun);  <span class="comment">// *pFun的 () 不能少！！！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">000000000062FE0C, 000000000062FE08</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0, 000000000062FE00</span></span><br><span class="line"><span class="comment">8, 0000000000401FF0, 000000000062FE00</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>这个程序也没必要汇编了..函数add实际上存在text段的，指针pFun和a, b一样，都在栈中，只是存的值是add的地址，机制就是这么个机制。</p><p>还有就是有人喜欢把函数指针和typedef放一块看</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> (*FUN_POINT)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FUN_POINT point;</span></span><br><span class="line"><span class="comment">// point = add;  // 为什么不能这么玩？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    FUN_POINT funPoint;</span><br><span class="line">    funPoint = add;</span><br><span class="line"></span><br><span class="line">    funPoint(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    (*funPoint)(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>typedef就是重命名呀。好了，知道这么个机制，我们能做些什么？</p><p><strong>函数指针数组</strong></p><p>来看一个程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_cmd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">retrieve_cmd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update_cmd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_cmd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这就是函数指针数组</span></span><br><span class="line"><span class="keyword">int</span> (*crud_cmd[])(<span class="keyword">int</span>, <span class="keyword">int</span>) = {</span><br><span class="line">        create_cmd,</span><br><span class="line">        retrieve_cmd,</span><br><span class="line">        update_cmd,</span><br><span class="line">        delete_cmd</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = crud_cmd[<span class="number">1</span>](<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> b = (*crud_cmd + <span class="number">1</span>)(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>把函数，指针，数组，三个词放一块还是很有意思的，比如实现一个状态机？</p><p><strong>多态</strong></p><p>多态是面向对象的概念，C语言是面向过程的语言(我觉得这句话不正确)。C语言就不能实现多态了？且看下面一个没有实质作用的程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类 HUMANITY，基本特性 name，基本方法 intro</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HUMANITY</span> {</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">void</span> (*intro)(struct HUMANITY *);</span><br><span class="line">} HUMANITY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HUMANITY的子类 TEACHER，多了一个属性 teachNo</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    HUMANITY humanity;</span><br><span class="line">    <span class="keyword">int</span> teachNo;</span><br><span class="line">} TEACHER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TEACHER特有的 intro</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teachIntro</span><span class="params">(HUMANITY *humanity)</span> </span>{</span><br><span class="line">    TEACHER *t = (TEACHER *) humanity;  <span class="comment">// 向下转型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am a teacher. My name is %s and teachNo is %d\n"</span>, t-&gt;humanity.name, t-&gt;teachNo);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HUMANITY的子类 STUDENT，多了一个属性 stuNo</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    HUMANITY humanity;</span><br><span class="line">    <span class="keyword">long</span> stuNo;</span><br><span class="line">} STUDENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STUDENT特有的 intro</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stuIntro</span><span class="params">(HUMANITY *humanity)</span> </span>{</span><br><span class="line">    STUDENT *s = (STUDENT *) humanity;  <span class="comment">// 向下转型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am a student. My name is %s and stuNo is %ld\n"</span>, s-&gt;humanity.name, s-&gt;stuNo);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    TEACHER *t = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TEACHER));  <span class="comment">// 创建一个TEACHER对象</span></span><br><span class="line">    t-&gt;humanity.name = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(t-&gt;humanity.name, <span class="string">"Wang"</span>);</span><br><span class="line">    t-&gt;humanity.intro = teachIntro;</span><br><span class="line">    t-&gt;teachNo = <span class="number">12</span>;</span><br><span class="line">    HUMANITY *teacher = (HUMANITY *) t;  <span class="comment">// 向上转型</span></span><br><span class="line">    (teacher-&gt;intro)(teacher);  <span class="comment">// 实际上是 TEACHER 特有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(teacher-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line"></span><br><span class="line">    STUDENT *s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(STUDENT));</span><br><span class="line">    s-&gt;humanity.name = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;humanity.name, <span class="string">"Sidney Ding"</span>);</span><br><span class="line">    s-&gt;humanity.intro = stuIntro;</span><br><span class="line">    s-&gt;stuNo = <span class="number">9999L</span>;</span><br><span class="line">    HUMANITY *student = (HUMANITY *) s;</span><br><span class="line">    (student-&gt;intro)(student);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(s-&gt;humanity.name);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">I am a teacher. My name is Wang and teachNo is 12</span></span><br><span class="line"><span class="comment">I am a student. My name is Sidney Ding and stuNo is 9999</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>此时是不是发现C语言变得有趣多了？面向对象而已，C语言这么强大的语言必拿下。在这个例子中，不免要思考一件事，向上转型和向下转型？因为子类多余的属性是放在父类后面的，所谓的转型，我们就当是内存截断好了，父类前面的内容必然是符合的，至于后面内容，也不会丢，毕竟还是占内存的。此时再将这个父类向下转型，不过就是扩张而已，恰巧后面的就是子类多出的属性占的内存。</p><h2 id="2-5-宏函数"><a href="#2-5-宏函数" class="headerlink" title="2.5 宏函数"></a>2.5 宏函数</h2><p>这个没啥好说，<code>#define</code>这玩意本省就是编译时替换，所以注意多加括号就好了，至于宏的一些技巧，例如拼接，之前也说过了</p><p>所以，就到这里了，以后想到啥好玩的，再加进来吧！</p></body></html></div><div style="text-align:center;color:#636363;font-size:14px">------- This article is over <i class="fa fa-leaf" aria-hidden="true"></i> Thank you for your reading -------</div><div id="reward-container"><div>All I need is you needing me.</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">Donate</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Sidney Ding WeChat Pay"><p>WeChat Pay</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Sidney Ding Alipay"><p>Alipay</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Sidney Ding</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://sidneygod.github.io/posts/e4de57a8/" title="[Relearning C&#x2F;Cpp] Initialization and Functions">https://sidneygod.github.io/posts/e4de57a8/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Relearning-C-Cpp/" rel="tag"><i class="fa fa-tag"></i> Relearning C/Cpp</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/61dcf29f/" rel="next" title="[Relearning C/Cpp] Array and Pointer"><i class="fa fa-chevron-left"></i> [Relearning C/Cpp] Array and Pointer</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/c8ed763e/" rel="prev" title="[Relearning C/Cpp] Supplement">[Relearning C/Cpp] Supplement <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Catalogue</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-初始化"><span class="nav-text">1 初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-函数"><span class="nav-text">2 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-参数传递"><span class="nav-text">2.1 参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-函数重载"><span class="nav-text">2.2 函数重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-指针函数"><span class="nav-text">2.3 指针函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-函数指针"><span class="nav-text">2.4 函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-宏函数"><span class="nav-text">2.5 宏函数</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="#"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Sidney Ding"></a><p class="site-author-name" itemprop="name">Sidney Ding</p><div class="site-description" itemprop="description">You laugh at me for being different, but I laugh at you for being the same.</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">22</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/SidneyGod" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SidneyGod" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:sidneyding183@gmail.com" title="E-Mail &amp;rarr; mailto:sidneyding183@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://google.com/" title="https:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">Google</a></li><li class="links-of-blogroll-item"><a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Sidney Ding</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Symbols count total: </span><span title="Symbols count total">232k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">Reading time total &asymp;</span> <span title="Reading time total">6:26</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div><div><span><i class="fa fa-bomb"></i> </span><span id="showDays"></span></div><script>var seconds=1e3,minutes=60*seconds,hours=60*minutes,days=24*hours,years=365*days,birthDay=Date.UTC(2019,10,1,0,0,0);setInterval(function(){var e=(n=new Date).getFullYear(),s=n.getMonth()+1,t=n.getDate(),a=n.getHours(),o=n.getMinutes(),n=n.getSeconds(),s=Date.UTC(e,s,t,a,o,n)-birthDay,t=Math.floor(s/years),a=Math.floor(s/days-365*t),o=Math.floor((s-(365*t+a)*days)/hours),n=Math.floor((s-(365*t+a)*days-o*hours)/minutes),s=Math.floor((s-(365*t+a)*days-o*hours-n*minutes)/seconds);document.getElementById("showDays").innerHTML="This website has been running for "+t+" years, "+a+" days, "+o+" hours, "+n+" minutes, "+s+" seconds"},1e3)</script></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.4.1.js"></script><script src="/js/motion.js?v=7.4.1.js"></script><script src="/js/schemes/pisces.js?v=7.4.1.js"></script><script src="/js/next-boot.js?v=7.4.1.js"></script><script src="/js/bookmark.js?v=7.4.1.js"></script><script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js"></script><script src="/js/local-search.js?v=7.4.1.js"></script><script>document.querySelectorAll("div.pdf").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js",()=>{document.querySelectorAll("div.pdf").forEach(e=>{PDFObject.embed(e.getAttribute("target"),e,{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:e.getAttribute("height")||"500px"})})},window.PDFObject)</script><script>NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],i="nick,mail,link".split(",").filter(i=>e.includes(i));new Valine({el:"#comments",verify:!0,notify:!1,appId:"IJiDbg4VAiIeDsIj4MBo39Hq-gzGzoHsz",appKey:"0osu23DWjzCzrIVH4Ybe3ihh",placeholder:"Just go go",avatar:"monsterid",meta:i,pageSize:"10",visitor:!1,lang:"en",path:location.pathname,recordIP:!0,serverURLs:""})},window.Valine)</script><script src="/js/snowflakes.min.js"></script><script>new Snowflakes({color:"rgba(129, 161, 193, 0.87)"})</script><script async src="/js/love.js"></script><script async src="/js/fireworks.js"></script><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~"+OriginTitile,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script></body></html>