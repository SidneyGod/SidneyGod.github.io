<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=7.4.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.4.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.4.1"><link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222"><link rel="alternate" href="/atom.xml" title="Sidney God" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=7.4.1"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.4.1",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!0,lazyload:!0,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"},sidebarPadding:40}</script><meta name="description" content="说是第三天，我看了该一个星期了..发现之前看得有点浮躁，最近看了费曼读书法有了新的想法，不怕慢，就不没看明白，所以听费曼的，每次看卡壳了，就返回去重新看..看到这里，突然觉得还是以《64位》为主比较好，《32位》太老了，用的还是nask转换起来有点累，并且《64位》介绍得细啊，所以我悟了，《32位》用来打辅助吧..1 软盘与FAT12先来看软盘，一个PC里面可以有多个软盘，一个软盘里面包含2个磁头"><meta property="og:type" content="article"><meta property="og:title" content="[Make MyOS] Find loader"><meta property="og:url" content="https://sidneygod.github.io/posts/1d4ddf18/index.html"><meta property="og:site_name" content="Sidney God"><meta property="og:description" content="说是第三天，我看了该一个星期了..发现之前看得有点浮躁，最近看了费曼读书法有了新的想法，不怕慢，就不没看明白，所以听费曼的，每次看卡壳了，就返回去重新看..看到这里，突然觉得还是以《64位》为主比较好，《32位》太老了，用的还是nask转换起来有点累，并且《64位》介绍得细啊，所以我悟了，《32位》用来打辅助吧..1 软盘与FAT12先来看软盘，一个PC里面可以有多个软盘，一个软盘里面包含2个磁头"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://gitee.com/SidneyGod/ImagePlace/raw/master/202110162308914.png"><meta property="og:image" content="https://gitee.com/SidneyGod/ImagePlace/raw/master/202110162324743.png"><meta property="og:image" content="https://gitee.com/SidneyGod/ImagePlace/raw/master/202112261614209.png"><meta property="og:image" content="https://gitee.com/SidneyGod/ImagePlace/raw/master/202112261616755.svg"><meta property="og:image" content="https://gitee.com/SidneyGod/ImagePlace/raw/master/202110312044018.png"><meta property="article:published_time" content="2021-10-31T15:05:46.000Z"><meta property="article:modified_time" content="2022-01-16T13:54:18.909Z"><meta property="article:author" content="Sidney Ding"><meta property="article:tag" content="Sidney"><meta property="article:tag" content=" Ding"><meta property="article:tag" content=" Sidney Ding"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/SidneyGod/ImagePlace/raw/master/202110162308914.png"><link rel="canonical" href="https://sidneygod.github.io/posts/1d4ddf18/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>[Make MyOS] Find loader | Sidney God</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Sidney God</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Keep quiet time for time</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">18</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">23</span></a></li><li class="menu-item menu-item-resources"><a href="/resources/" rel="section"><i class="fa fa-fw fa-book"></i>Resources</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="reading-progress-bar"></div><a class="book-mark-link book-mark-link-fixed" href="#"></a> <a href="https://github.com/SidneyGod" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article itemscope itemtype="http://schema.org/Article"><div class="post-block post"><link itemprop="mainEntityOfPage" href="https://sidneygod.github.io/posts/1d4ddf18/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Sidney Ding"><meta itemprop="description" content="You laugh at me for being different, but I laugh at you for being the same."><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sidney God"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">[Make MyOS] Find loader</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-10-31 23:05:46" itemprop="dateCreated datePublished" datetime="2021-10-31T23:05:46+08:00">2021-10-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2022-01-16 21:54:18" itemprop="dateModified" datetime="2022-01-16T21:54:18+08:00">2022-01-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OS/Make-OS/" itemprop="url" rel="index"><span itemprop="name">Make OS</span></a></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine: </span><a title="valine" href="/posts/1d4ddf18/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/1d4ddf18/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>15k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>25 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><html><head></head><body><p>说是第三天，我看了该一个星期了..发现之前看得有点浮躁，最近看了费曼读书法有了新的想法，不怕慢，就不没看明白，所以听费曼的，每次看卡壳了，就返回去重新看..</p><p>看到这里，突然觉得还是以《64位》为主比较好，《32位》太老了，用的还是nask转换起来有点累，并且《64位》介绍得细啊，所以我悟了，《32位》用来打辅助吧..</p><h1 id="1-软盘与FAT12"><a href="#1-软盘与FAT12" class="headerlink" title="1 软盘与FAT12"></a>1 软盘与FAT12</h1><p>先来看软盘，一个PC里面可以有多个软盘，一个软盘里面包含2个磁头，80个柱面，18个扇区。因为软盘正反面都可以存储数据，所以有俩磁头去读取数据。柱面参考下图(注意编号0~79)，英文是cylinder；扇区参考下图(注意编号1~18)，英文是sector</p><a id="more"></a><p><img alt="" data-src="https://gitee.com/SidneyGod/ImagePlace/raw/master/202110162308914.png"></p><p>两本书用的都是FAT12文件系统来装载Loader程序和内核程序，将软盘格式化成FAT12文件系统时，FAT类文件系统会对软盘里的扇区进行结构化处理，把软盘<strong>扇区划分为引导扇区，FAT表，根目录区和数据区</strong>4部分</p><ul><li>引导扇区</li></ul><p>这一部分其实第一天的程序helloos2就已经介绍个大概了，再抄一遍《64位》里面的表格</p><div class="table-container"><table><thead><tr><th>名称</th><th>偏移</th><th>长度</th><th>内容</th><th>本引导程序数据</th></tr></thead><tbody><tr><td>BS_jmpBoot</td><td>0</td><td>3</td><td>跳转指令</td><td>jmp short Label_Start nop</td></tr><tr><td>BS_OEMName</td><td>3</td><td>8</td><td>生产厂商名</td><td>‘MINEboot’</td></tr><tr><td>BPB_BytesPerSec</td><td>11</td><td>2</td><td>每扇区字节数</td><td>512</td></tr><tr><td>BPB_SecPerClus</td><td>13</td><td>1</td><td>每簇扇区数</td><td>1</td></tr><tr><td>BPB_RsvdSecCnt</td><td>14</td><td>2</td><td>保留扇区数</td><td>1</td></tr><tr><td>BPB_NumFATs</td><td>16</td><td>1</td><td>FAT表的份数</td><td>2</td></tr><tr><td>BPB_RootEntCnt</td><td>17</td><td>2</td><td>根目录可容纳的目录份数</td><td>224</td></tr><tr><td>BPB_TotSec16</td><td>19</td><td>2</td><td>总扇区数</td><td>2880</td></tr><tr><td>BPB_Media</td><td>21</td><td>1</td><td>介质描述符</td><td>0xF0</td></tr><tr><td>BPB_FATs16</td><td>22</td><td>2</td><td>每FAT扇区数</td><td>9</td></tr><tr><td>BPB_SecPerTrk</td><td>24</td><td>2</td><td>每磁道扇区数</td><td>18</td></tr><tr><td>BPB_NumHeads</td><td>26</td><td>2</td><td>磁头数</td><td>2</td></tr><tr><td>BPB_HiddSec</td><td>28</td><td>4</td><td>隐藏扇区数</td><td>0</td></tr><tr><td>BPB_TotSec32</td><td>32</td><td>4</td><td>若BPB_TotSec16为0，则由该值记录扇区数</td><td>0</td></tr><tr><td>BS_DrvNum</td><td>36</td><td>1</td><td>int 13h的驱动器号</td><td>0</td></tr><tr><td>BS_Reserved1</td><td>37</td><td>1</td><td>未使用</td><td>0</td></tr><tr><td>BS_BootSig</td><td>38</td><td>1</td><td>扩展引导标记(29h)</td><td>0x29</td></tr><tr><td>BS_VolID</td><td>39</td><td>4</td><td>卷序列号</td><td>0</td></tr><tr><td>BS_VolLab</td><td>43</td><td>11</td><td>卷标</td><td>‘boot loader’</td></tr><tr><td>BS_FileSysType</td><td>54</td><td>8</td><td>描述文件系统类型</td><td>‘FAT12’</td></tr><tr><td>引导代码</td><td>62</td><td>448</td><td>引导代码，数据及其他信息</td><td></td></tr><tr><td>结束标志</td><td>510</td><td>2</td><td>结束标志0xAA55</td><td>0xAA55</td></tr></tbody></table></div><p>其中，</p><p>BPB_Media，对于不可移动存储介质而言，标准值是0xF8，对于可移动存储介质，常用值是0xF0。此域合法值是0xF0，0xF8，0xF9，0xFB，0xFC，0xFD，0xFE，0xFF。</p><p>BS_VolLab，就是Windows或Linux系统中显示的磁盘名</p><p>按照上述描述，可将软盘扇区描绘成下图，其中FAT2是对FAT1的备份</p><p><img alt="" data-src="https://gitee.com/SidneyGod/ImagePlace/raw/master/202110162324743.png"></p><ul><li>FAT表</li></ul><p>FAT12文件系统是以簇为单位来分配数据区的存储空间，每个簇的大小为<script type="math/tex">BPB\_BytesPerSec × BPB\_SecPerClus</script>字节，<strong>数据区的簇号与FAT表的表项是一一对应关系</strong>。文件在FAT类文件系统存储单位是簇，即使文件长度只有1字节，也是分配了一个簇。</p><blockquote><p>在该实例中，1簇=1扇区，数据区有2880-1(MBR)-9(FAT1)-9(FAT2)-14(RootDir)=2847扇区(簇)，而FAT1表的大小是9*512B=4608B，每个表项占12bit，一共有4608/1.5=3072个表项，其中有两个表项不用，也就是3070个FAT表项，对应2847个簇是绰绰有余了</p></blockquote><p>FAT表由FAT表项构成。每个FAT表项的大小有12位、16位、和32位三种情况。每个FAT表项都有一个固定的编号，这个编号从0开始。</p><p><table></table></p><p></p>FAT项实例值描述<p></p><p></p>0FF0H磁盘标识字，低字节与BPB_Media数值保持一致<br>第一个簇已经被占用1FFFH2003H0x000：可用簇<br>0x002 ~ 0xFEF：已用簇标识下一个簇的簇号<br>0xFF0 ~ 0xFF6：保留簇<br>0xFF7：坏簇<br>0xFF8 ~ 0xFFF：文件的最后一个簇3004H......NFFFHN+1000H......<br>&lt;/table&gt;<br>FAT表的0号和1号FAT表项有专门的用途。0号FAT表项通常用来存放分区所在的介质类型；1号FAT表项用来存储文件系统的肮脏标志，表明文件系统被非法卸载或者磁盘表面存在错误。<p></p><p>每一个FAT表项都会映射FAT数据区的一个簇中。因为0号FAT表项和1号FAT表项有特殊用途，无法与数据区中的簇形成映射，所以从2号FAT表项开始跟数据区中的第一个簇映射，正因为如此，<strong>数据区中的第一个簇也就编号为2号簇，这也是没有0号簇和1号簇的原因</strong>。然后3号簇跟3号FAT表项映射，4号簇跟4号FAT表项映射，以此类推，直到数据区中的最后一个簇。比如说FAT[2]中实例值是003H(指向FAT[3])，表示对应数据区2号簇，实际上第(2-2=0)号扇区，并要在FAT[3]中找更后面的数据，实例值指的就是下一个FAT项</p><p>在编写程序的时候我们直接跳过FAT[0]和FAT[1]即可，并不使用它们，不必要理会其中的值。</p><ul><li>根目录区和数据区</li></ul><p>根目录和数据区都保存着与文件相关的数据，只不过根目录只能保存目录项信息，而数据区不但可以保存目录项信息，还可以保存文件内的数据。此处所提及的<strong>目录项是由一个32B</strong>组成的结构体，它既可以 表示成一个目录，又可以表示成一个文件，其中<strong>字段DIR_FstClus描述了文件在磁盘存放的具体位置</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">偏移</th><th style="text-align:center">长度</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>DIR_Name</strong></td><td style="text-align:center"><strong>0x00</strong></td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center"><strong>文件名8B，扩展名3B</strong></td></tr><tr><td style="text-align:center">DIR_Attr</td><td style="text-align:center">0x0B</td><td style="text-align:center">1</td><td style="text-align:center">文件属性</td></tr><tr><td style="text-align:center">保留</td><td style="text-align:center">0x0C</td><td style="text-align:center">10</td><td style="text-align:center">保留位</td></tr><tr><td style="text-align:center">DIR_WrtTime</td><td style="text-align:center">0x16</td><td style="text-align:center">2</td><td style="text-align:center">最后一次写入时间</td></tr><tr><td style="text-align:center">DIR_WrtDate</td><td style="text-align:center">0x18</td><td style="text-align:center">2</td><td style="text-align:center">最后一次写入日期</td></tr><tr><td style="text-align:center"><strong>DIR_FstClus</strong></td><td style="text-align:center"><strong>0x1A</strong></td><td style="text-align:center">2</td><td style="text-align:center"><strong>起始簇号</strong></td></tr><tr><td style="text-align:center">DIR_FileSize</td><td style="text-align:center">0x1C</td><td style="text-align:center">4</td><td style="text-align:center">文件大小</td></tr></tbody></table></div><p><img alt="Root Directory Entry Format" data-src="https://gitee.com/SidneyGod/ImagePlace/raw/master/202112261614209.png"></p><p><a href="http://www.c-jump.com/CIS24/Slides/FAT/lecture.html#F01_0140_root_directory" target="_blank" rel="noopener">The FAT File System (c-jump.com)</a></p><h1 id="2-boot-asm"><a href="#2-boot-asm" class="headerlink" title="2 boot.asm"></a>2 boot.asm</h1><p>了解了FAT文件系统知识后，再来瞅瞅《64位》中boot程序，感觉比《32位》那个解释得更加详细一点</p><p>引导代码boot.bin文件是放在引导扇区中的，LOADER.BIN文件是放在数据区中的一个个簇中，而文件的文件名是放在根目录区中的目录项的，根目录区的目录项就保存着文件起始簇号，而数据区中的每个簇都与FAT1表中每个FAT项对应的，每个FAT项的值标明了下一个簇号。</p><p>所以想将数据区的文件加载到内存，需要先去根目录区找文件名，根据文件名定位根目录区目录项，接着拿到起始簇号/FAT表项，根据起始簇号/FAT表项接着读下一个簇/FAT表项，直到FAT表项的值为0xfff</p><p>整坨代码大概是这么个关系</p><p><img alt="" data-src="https://gitee.com/SidneyGod/ImagePlace/raw/master/202112261616755.svg"></p><h2 id="2-1-FAT12文件系统数据"><a href="#2-1-FAT12文件系统数据" class="headerlink" title="2.1 FAT12文件系统数据"></a>2.1 FAT12文件系统数据</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">; 告诉编译器这段代码要加载到0x7c00处的</span><br><span class="line">; 编译器在编译代码的时涉及到变量寻址(标号)会自动加上0x7c00这个基址</span><br><span class="line">; 但是并不会影响到CS DS ES SS</span><br><span class="line">    org 0x7c00</span><br><span class="line"></span><br><span class="line">BaseOfStack    equ  0x7c00  ; 相当于C语言的 #define</span><br><span class="line"></span><br><span class="line">BaseOfLoader    equ 0x1000</span><br><span class="line">OffsetOfLoader  equ 0x00</span><br><span class="line"></span><br><span class="line">RootDirSectors  equ 14</span><br><span class="line">SectorNumOfRootDirStart equ 19</span><br><span class="line">SectorNumOfFAT1Start    equ 1</span><br><span class="line">SectorBalance   equ 17</span><br><span class="line">    ; 段内短转移，以当前ip的相对跳转地址的偏依量作为转移量，但偏移量只允许在-128 ~ +127字节之间</span><br><span class="line">    jmp short Label_Start  ; 下面只是磁盘的元数据 真正程序开始是Label_Start</span><br><span class="line">    nop  ; fat12文件头格式中的BS_jmpBoot固定格式</span><br><span class="line">    BS_OEMName  db  'MINEboot'</span><br><span class="line">    BPB_BytesPerSec dw  512</span><br><span class="line">    BPB_SecPerClus  db  1</span><br><span class="line">    BPB_RsvdSecCnt  dw  1</span><br><span class="line">    BPB_NumFATs db  2</span><br><span class="line">    BPB_RootEntCnt  dw  224</span><br><span class="line">    BPB_TotSec16    dw  2880</span><br><span class="line">    BPB_Media   db  0xf0</span><br><span class="line">    BPB_FATSz16 dw  9</span><br><span class="line">    BPB_SecPerTrk   dw  18</span><br><span class="line">    BPB_NumHeads    dw  2</span><br><span class="line">    BPB_HiddSec dd  0</span><br><span class="line">    BPB_TotSec32    dd  0</span><br><span class="line">    BS_DrvNum   db  0</span><br><span class="line">    BS_Reserved1    db  0</span><br><span class="line">    BS_BootSig  db  0x29</span><br><span class="line">    BS_VolID    dd  0</span><br><span class="line">    BS_VolLab   db  'boot loader'</span><br><span class="line">    BS_FileSysType  db  'FAT12   '</span><br></pre></td></tr></tbody></table></figure><p><code>BaseOfLoader equ 0x1000</code>和<code>OffsetOfLoader equ 0x00</code>组合成了Loader的起始地址，这个组合必须经过实模式的地址变换公式才能生成物理地址，即<code>BaseOfLoader &lt;&lt; 4 + OffsetOfLoader = 0x10000</code></p><p><code>RootDirSectors equ 14</code>定义了根目录占用的扇区数，这个数值是根据FAT12文件系统提供的起始物理地址计算而得，即<code>(BPB_RootEntCnt * 32 + BPB_BytesPerSec - 1) / BPB_BytesPerSec = (224 * 32 + 512 - 1) / 512 = 14</code></p><p><code>SectorNumOfRootDirStart equ 19</code>定义了根目录的起始扇区号，这个数值是根据<code>保留扇区数 + FAT表扇区数 * FAT表份数 = 1 + 9 * 2 = 19</code>，因为扇区标号是从0开始计数，所以根目录起始扇区为19</p><p><code>SectorNumOfFAT1Start equ 1</code>表示FAT1表的起始扇区号，在FAT1表前有一个保留扇区</p><p><code>SectorBalance equ 17</code>用于平衡文件的起始簇号与数据区起始簇号的差值。数据区中的第一个簇为2号簇，所以把必须将FAT表项值减2以计算FAT表项对应的数据区起始扇区号，实际上是(19 - 2)</p><p>代码是在程序一开始就定义的，但是程序是从上往下顺序执行的，代码中有想当一部分是数据，并不是代码，所以我们一开始就需要使用无条件跳转指令<code>jmp short Label_Start</code>，跳转到<code>Label_Start</code>标签处开始执行代码。</p><h2 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Label_Start:</span><br><span class="line">    mov ax, cs  ; 最开始cs是等于0的</span><br><span class="line">    mov ds, ax  ; ds es ss不能通过立即数赋值 需要ax中转</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov sp, BaseOfStack  ; 栈指针设到0x7c00</span><br><span class="line"></span><br><span class="line">;=======    clear screen</span><br><span class="line">    mov ax, 0600h</span><br><span class="line">    mov bx, 0700h</span><br><span class="line">    mov cx, 0</span><br><span class="line">    mov dx, 0184fh</span><br><span class="line">    int 10h           ; 0x10中断的AH=0x06号功能 清屏</span><br><span class="line"></span><br><span class="line">;=======    set focus</span><br><span class="line">    mov ax, 0200h</span><br><span class="line">    mov bx, 0000h</span><br><span class="line">    mov dx, 0000h</span><br><span class="line">    int 10h           ; 0x10中断的AH=0x2号功能 设置游标位置</span><br><span class="line"></span><br><span class="line">;=======    display on screen : Start Booting......</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 000fh</span><br><span class="line">    mov dx, 0000h</span><br><span class="line">    mov cx, 10</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, StartBootMessage  ; 字符串定义在最后 Start Boot</span><br><span class="line">    int 10h          ; 0x10中断的AH=0x13号功能 写字符串</span><br><span class="line"></span><br><span class="line">;=======    reset floppy</span><br><span class="line">    xor ah, ah      ; ah=0</span><br><span class="line">    xor dl, dl      ; dl=0</span><br><span class="line">    int 13h         ; 0x13中断的AH=0号功能 复位磁盘</span><br></pre></td></tr></tbody></table></figure><p>这段没啥好说的..看第二天的就好了</p><h2 id="2-3-查找loader-bin文件"><a href="#2-3-查找loader-bin文件" class="headerlink" title="2.3 查找loader.bin文件"></a>2.3 查找loader.bin文件</h2><p>核心目标，从根目录中搜索出引导加载程序(文件名为loader.bin)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">;=======    search loader.bin</span><br><span class="line">    mov word [SectorNo], SectorNumOfRootDirStart  ; 根目录从第19个扇区开始</span><br><span class="line"></span><br><span class="line">Lable_Search_In_Root_Dir_Begin:</span><br><span class="line">    cmp word [RootDirSizeForLoop], 0  ; RootDirSizeForLoop初始值为根目录扇区数 一个扇区一个扇区找</span><br><span class="line">    jz  Label_No_LoaderBin  ; 找到剩0 就表示找不到</span><br><span class="line">    dec word [RootDirSizeForLoop]  ; RootDirSizeForLoop--</span><br><span class="line">    mov ax, 00h</span><br><span class="line">    mov es, ax  ; 不能直接通过立即数赋值 需要通过ax中转以下 es=00h</span><br><span class="line">    mov bx, 8000h  ; bx=8000h</span><br><span class="line">    mov ax, [SectorNo]  ; ax=19</span><br><span class="line">    mov cl, 1  ; cl=1</span><br><span class="line">    ; call命令实际上是两条命令结合 push ip和mov ip, Func_ReadOneSector</span><br><span class="line">    ; 然后push ip又可以拆成两条指令 add sp, 2 和 mov sp, ip</span><br><span class="line">    ; 简单来说就是将当前的ip存到栈sp+2位置(向上增长，因为看到下面bp-2了)，并且将ip指向Func_ReadOneSector</span><br><span class="line">    ; 而ip的值表示下一条指令 也就是说下一条指令执行Func_ReadOneSector的东西</span><br><span class="line">    call Func_ReadOneSector</span><br><span class="line">    mov si, LoaderFileName  ; 通过ds:si指向文件名源地址</span><br><span class="line">    mov di, 8000h  ; es:di也指向了扇区内容起始地址</span><br><span class="line">    cld  ; DF复位=0，这样通过LODSB从ds:si加载内容到al后 si就会递增1</span><br><span class="line">    mov dx, 10h  ; dx记录一个扇区可容纳的目录项个数 一个扇区最多有512B/32B=16=0x10个目录项</span><br><span class="line"></span><br><span class="line">Label_Search_For_LoaderBin:</span><br><span class="line">    cmp dx, 0</span><br><span class="line">    jz  Label_Goto_Next_Sector_In_Root_Dir</span><br><span class="line">    dec dx  ; 上面三句就是一个扇区所有目录项都找完了 可以去下一个扇区找了</span><br><span class="line">    mov cx, 11  ; 文件名的长度11B 包括文件名和扩展名 但不包括分隔符 .</span><br><span class="line"></span><br><span class="line">Label_Cmp_FileName:</span><br><span class="line">    cmp cx, 0</span><br><span class="line">    jz  Label_FileName_Found</span><br><span class="line">    dec cx  ; 一样的道理 这里是比较文件名</span><br><span class="line">    lodsb  ; 从ds:si读取一个字节到寄存器AL 然后si+=1(取决于DF)</span><br><span class="line">    cmp al, byte [es:di]  ; 一个字符一个字符去比较</span><br><span class="line">    jz  Label_Go_On  ; 如果相等</span><br><span class="line">    jmp Label_Different  ; 如果不相等</span><br><span class="line"></span><br><span class="line">Label_Go_On:</span><br><span class="line">    inc di  ; di+=1</span><br><span class="line">    jmp Label_Cmp_FileName  ; 也就是比较下一个字符</span><br><span class="line"></span><br><span class="line">Label_Different:</span><br><span class="line">    and di, 0ffe0h  ; 将di后5位置0 消除比较文件名带来的影响</span><br><span class="line">    add di, 20h  ; di+=32B 下一个目录项</span><br><span class="line">    mov si, LoaderFileName  ; 重置要搜索的文件名的指针</span><br><span class="line">    jmp Label_Search_For_LoaderBin  ; 继续找</span><br><span class="line"></span><br><span class="line">Label_Goto_Next_Sector_In_Root_Dir:</span><br><span class="line">    add word  [SectorNo], 1  ; 扇区号+1</span><br><span class="line">    jmp Lable_Search_In_Root_Dir_Begin  ; 去下一个扇区去找</span><br><span class="line"></span><br><span class="line">;=======    display on screen : ERROR:No LOADER Found</span><br><span class="line">Label_No_LoaderBin:</span><br><span class="line">    mov ax, 1301h</span><br><span class="line">    mov bx, 008ch</span><br><span class="line">    mov dx, 0100h</span><br><span class="line">    mov cx, 21</span><br><span class="line">    push    ax</span><br><span class="line">    mov ax, ds</span><br><span class="line">    mov es, ax</span><br><span class="line">    pop ax</span><br><span class="line">    mov bp, NoLoaderMessage</span><br><span class="line">    int 10h  ; 如果找不到就在屏幕输出 ERROR:No LOADER Found</span><br><span class="line">    jmp $  ; 死循环在这里</span><br></pre></td></tr></tbody></table></figure><p>这里的Func_ReadOneSector可以先理解为一个函数，用于读取磁盘扇区内容的函数，参数是ax=磁盘起始扇区号，cl读入的扇区数量；返回值FALGS.CF，其中0表示没错误，并且扇区内容加载到es:bx上</p><p>1 为什么要使用循环去读取磁盘？AL不是能够直接指定读取多少个扇区麽</p><blockquote><p>指定处理的扇区数，范围在0x01~0xff(在指定0x02以上的数值时，要特别注意能够连续处理多个扇区的条件，如果是FD的话，似乎不能跨越多个磁道，也不能超过64KB界限)</p></blockquote><p>2 FAT12文件系统的文件名是不分大小写的，即是将小写字母命名的文件赋值到FAT12文件系统内，文件系统也会为其创建大写字母的文件名和目录项。而小写字母文件名只作为其显示名，而真正的数据内容皆保存在对应的大写字母目录项。所以这里应该搜索大写字母的文件名字符串。</p><p>3 关于<strong>lodsb</strong>指令，参考64-ia-32-architectures-software-developer-vol-2-manual的chapter 3.2指令介绍</p><p>LODS/LODSB/LODSW/LODSD/LODSQ—Load String</p><p>分别将源操作数中的字节、字或双字加载到AL、AX或EAX寄存器中。源操作数是一个内存位置，其地址从DS:ESI或DS:SI寄存器中读取（取决于指令的地址大小属性，分别为32或16）。DS段可以被段覆盖前缀覆盖。</p><p>字节、字或双字从内存位置传送到 AL、AX 或 EAX 寄存器后，(E)SI寄存器根据EFLAGS寄存器中DF标志的设置自动递增或递减。（如果DF标志为0，（E）SI寄存器递增；如果DF标志为1，ESI寄存器递减。）（E）SI寄存器递增或递减1为字节操作，递减2为字运算，或双字运算乘以4。</p><p>4 关于操作</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and di, 0ffe0h  ; 将di后5位置0 消除找文件名带来的影响</span><br><span class="line">add di, 20h  ; +32 下一个目录项</span><br></pre></td></tr></tbody></table></figure><p>因为文件名是11B，最大也就是<code>1011b</code>，一个目录项的大小是32B，也就是<code>100000b</code>，再看di初始值是<code>mov di, 8000h</code>，也就是说每个目录项的起始地址低5位都是0，而查找时加上11B顶多只会影响到低4位，所以将低5位置0是没有毛病的，乃至于只将低4位置0都是ok的，只要di的起始地址低4位别有1就好</p><h2 id="2-4-加载扇区内容到内存"><a href="#2-4-加载扇区内容到内存" class="headerlink" title="2.4 加载扇区内容到内存"></a>2.4 加载扇区内容到内存</h2><p>如果在根目录中发现了文件名(loader.bin)，那就表示磁盘中有这个文件，那么接下来的任务就是读出文件的数据到内存，最终将整个文件加载到内存中</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;=======    found loader.bin name in root director struct</span><br><span class="line">Label_FileName_Found:  ; 如果找到了 那么现在es:di指向的是 包含文件的目录项+11B</span><br><span class="line">    mov ax, RootDirSectors  ; 根目录扇区数14</span><br><span class="line">    and di, 0ffe0h  ; 清除文件名的影响 现在es:di指向的是包含文件的目录项</span><br><span class="line">    add di, 01ah  ; 目录项偏移0x1A(DIR_FstClus)得到起始簇号(数据区的，数据区第一个簇是2)</span><br><span class="line">    mov cx, word [es:di]  ; 起始簇号(这里1簇只包含1个扇区 也可以理解为起始扇区号)占2B</span><br><span class="line">    push cx  ; 将起始簇号(也是FAT表项值)暂存到栈中</span><br><span class="line">    add cx, ax  ; cx += 14</span><br><span class="line">    add cx, SectorBalance  ; cx += 17  实际上是+19(FAT占的扇区)-2(数据区从2开始的)得到实际的起始扇区号</span><br><span class="line">    mov ax, BaseOfLoader  ; ax = 0x1000</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov bx, OffsetOfLoader  ; 通过es:bx=0x1000&lt;&lt;4+0x00=0x10000得到loader的起始地址</span><br><span class="line">    mov ax, cx  ; 存储文件的实际起始扇区号 放在ax中</span><br><span class="line"></span><br><span class="line">Label_Go_On_Loading_File:</span><br><span class="line">    push ax  ; 接着上面的说咯 将起始扇区号和加载文件内容起始地址保存起来 但是要注意cx也进栈了 并且没有出栈</span><br><span class="line">    push bx  ; 所以出栈顺序应当是 bx(内存加载起始地址)-&gt;ax(存储文件的实际起始扇区号)-&gt;cx(起始簇号)</span><br><span class="line">    mov ah, 0eh  ; 打印一个字符</span><br><span class="line">    mov al, '.'</span><br><span class="line">    mov bl, 0fh</span><br><span class="line">    int 10h  ; 调用中断int 10h在屏幕上打印一个"."</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax  ; 保存的起始扇区号和加载文件内容起始地址取出来</span><br><span class="line"></span><br><span class="line">    mov cl, 1  ; 读一个扇区</span><br><span class="line">    call Func_ReadOneSector  ; 将一个扇区的内容读出来</span><br><span class="line">    pop ax  ; 这里就是cx了 取出此扇区在FAT中的序号(和数据区的簇号是一一对应的)</span><br><span class="line">    call Func_GetFATEntry</span><br><span class="line">    cmp ax, 0fffh  ; 读出来FAT项值是否为0xFFF，如果是文件尾</span><br><span class="line">    jz  Label_File_Loaded  ; 就表示loader.bin文件加载到内存完毕</span><br><span class="line">    push ax  ; 将FAT表项值入栈</span><br><span class="line">    mov dx, RootDirSectors</span><br><span class="line">    add ax, dx</span><br><span class="line">    add ax, SectorBalance  ; 得到下一个起始扇区号</span><br><span class="line">    add bx, [BPB_BytesPerSec]  ; bx再向前进一个扇区 存储下一个</span><br><span class="line">    jmp Label_Go_On_Loading_File  ; 继续下一个扇区</span><br><span class="line"></span><br><span class="line">Label_File_Loaded:</span><br><span class="line">    jmp $  ; 因为还没有写loader.bin所以就停在这里</span><br></pre></td></tr></tbody></table></figure><p>这里又提到了另一个函数Func_GetFATEntry，这个函数的作用是根据当前FAT表项索引来获取当前FAT表项值(下一个表项索引或文件结尾标志0xfff)。这里会根据FAT表项指向的数据区的簇的内容加载到内存0x10000</p><h2 id="2-5-读取磁盘扇区模块"><a href="#2-5-读取磁盘扇区模块" class="headerlink" title="2.5 读取磁盘扇区模块"></a>2.5 读取磁盘扇区模块</h2><p>上面提到读取磁盘扇区的函数，该模块的作用就是读取软盘，每次读取一个扇区</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;=======    read one sector from floppy</span><br><span class="line">Func_ReadOneSector:</span><br><span class="line">    push bp  ; 将原来的bp保存在栈sp=sp+2位置</span><br><span class="line">    mov bp, sp  ; 把当前的sp位置存在bp中 这两步就被称之为压栈操作</span><br><span class="line">    sub esp, 2  ; 再找栈要2B的空间 局部变量</span><br><span class="line">    mov byte [bp - 2], cl  ; 把cl的值存在刚才申请的栈空间中</span><br><span class="line">    push bx  ; bx将要被使用 先将bx保存在sp=sp+2位置</span><br><span class="line">    mov bl, [BPB_SecPerTrk]  ; bl = 18</span><br><span class="line">    div bl  ; ax / bl = al...ah</span><br><span class="line">    inc ah  ; ah+1 余数+1得到柱面的开始扇区号</span><br><span class="line">    mov cl, ah  ; 起始扇区号存到cl</span><br><span class="line">    mov dh, al  ; 将al存到dh</span><br><span class="line">    shr al, 1  ; al&gt;&gt;1 商右移1位得到柱面号</span><br><span class="line">    mov ch, al  ; 柱面号存到ch</span><br><span class="line">    and dh, 1  ; dh&amp;1 商和1与运算得到磁头号</span><br><span class="line">    ; pop实际上是push的逆运算 mov bx, sp 和 sub sp, 2</span><br><span class="line">    ; 意思就是将当前栈顶的值取出来放bx中，再将栈顶收缩</span><br><span class="line">    pop bx</span><br><span class="line">    mov dl, [BS_DrvNum]  ; 驱动器号 0表示A盘</span><br><span class="line">    ; 到这里参数都准备好了 ch=柱面号 cl=起始扇区号 dh=磁头号 dl=驱动器号 es:bx=读取内容存放的缓冲区位置</span><br><span class="line">Label_Go_On_Reading:</span><br><span class="line">    mov ah, 2  ; 表示要读磁盘</span><br><span class="line">    mov al, byte [bp - 2]  ; 要读多少个扇区 从栈中将数据取出来</span><br><span class="line">    int 13h  ; 0x13中断的AH=02号功能 读取扇区</span><br><span class="line">    jc  Label_Go_On_Reading  ; 如果读盘错误CF值会被置为1 跳过去继续读</span><br><span class="line">    add esp, 2  ; 栈顶+2 回收栈空间</span><br><span class="line">    pop bp  ; 将进入函数之前的bp取回来 再修正栈</span><br><span class="line">    ; 这条指令等于pop ip，也就是将存在当前栈顶的ip(调用函数之前的位置)取回来，再将修正栈顶</span><br><span class="line">    ; 也就等于是子函数结束 回到调用函数的位置 继续执行</span><br><span class="line">    ret</span><br></pre></td></tr></tbody></table></figure><p>这个<code>Func_ReadOneSector</code>其实就可以理解为C语言中的函数，功能就是通过BIOS中断<code>int 13h</code>的主功能号<code>AH=02h</code>实现软盘扇区的读取操作</p><blockquote><p>INT 13h, AH=02h功能：读取磁盘扇区</p><p>AL=读入的扇区数(必须非0)</p><p>CH=磁道号(柱面号)的低8位</p><p>CL=扇区号1~63(bit 0~5)，磁道号(柱面号)的高2位(bit 6~7，只对硬盘有效)</p><p>DH=磁头号</p><p>DL=驱动器号(如果操作的是硬盘驱动器，bit 7必须被置位)</p><p>ES:BX=数据缓冲区</p><p>返回值:</p><p>FLAGS.CF=0，没有错误，AH=0</p><p>FLAGS.CF=1，有错误，错误号码存入AH内(与重置功能一样)</p></blockquote><p><strong>问题1，调用函数之前AX，CL的值代表什么，怎么来的？</strong></p><p>AX代表的是待读取的磁盘起始扇区号，CL代表的是读入的扇区数量，都来自另一段程序，下面会继续解释</p><p><strong>问题2，为什么要这么计算？</strong></p><p>因为磁盘扇区号是LBA(Logical Block Address，逻辑块寻址)格式的，而<code>INT 13h, AH=02h</code>中断服务程序只能受理CHS(Cylinder/Header/Sector，柱面/磁头/扇区)格式的磁盘扇区号，所以需要通过下面的公式将LBA格式转为CHS格式</p><script type="math/tex;mode=display">LBA扇区号 \div 每磁道扇区数 = 
\begin{cases}
商Q \rightarrow 
  \begin{cases}
    柱面号 = Q >> 1 \\ 
    磁头号 = Q \& 1
   \end{cases}
\\ 
余数R \rightarrow 起始扇区号 = R + 1
\end{cases}</script><p><strong>问题3，返回值FLAGS.CF代表啥？</strong></p><p>表示进位标识符，jc指令与之搭配使用，当carry flag值为1时就会跳转。如果调用这个函数出错CF就会置为1。这里就是如果出错就一直读，个人觉得没有《32位》处理得好，读错了就尝试5次</p><p><strong>问题4，<code>ES:BX</code>代表什么？</strong></p><p>这个表示内存地址，表明把从软盘上读出的数据装载到内存的哪个位置。如果用一个寄存器BX来表示内存地址的话，只能表示0~0xffff的值，最大才64K，现在谁家内存条这么小？当然了，你可能会现在不是有ebx或者rbx麽，用这个当然没问题，但问题是设计BIOS的时代没有啊，所以设计了起辅助作用的段寄存器，在指定内存地址时，可以用这个段寄存器。所以使用段及寄存器时，以<code>ES:BX</code>这种方式来表示<code>ES * 16 + BX</code>的内存地址地址，这样就可以指定1M以内的内存地址，这在当时就满足要求了，当然现在为了兼容也要遵守这一规则</p><h2 id="2-6-FAT表项解析模块"><a href="#2-6-FAT表项解析模块" class="headerlink" title="2.6 FAT表项解析模块"></a>2.6 FAT表项解析模块</h2><p>如果从扇区中找到了loader.bin，那就根据FAT表提供的簇号顺序依次加载到扇区数据到内存中，这个加载过程会涉及FAT表项的解析工作</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;=======    get FAT Entry</span><br><span class="line">Func_GetFATEntry:</span><br><span class="line">    push es</span><br><span class="line">    push bx</span><br><span class="line">    push ax  ; 常规的保护操作</span><br><span class="line">    mov ax, 00</span><br><span class="line">    mov es, ax  ; 这里将es置为00，因为外面的es是0x1000</span><br><span class="line">    pop ax  ; 这里的ax就是FAT表项</span><br><span class="line">    mov byte [Odd], 0  ; 标志位Odd置0</span><br><span class="line">    mov bx, 3  ; bx=3</span><br><span class="line">    mul bx  ; ax = ax * bx(3)</span><br><span class="line">    mov bx, 2  ; bx=2</span><br><span class="line">    div bx  ; ax/bx(2)=ax...dx，ax=ax*3/2扩大1.5倍得到该FAT表项占用的字节数</span><br><span class="line">    cmp dx, 0  ; ax是否为偶数，是偶数直接去Label_Even，Odd=0</span><br><span class="line">    jz  Label_Even</span><br><span class="line">    mov byte [Odd], 1  ; 不是的话 先将标志位Odd置为1</span><br><span class="line"></span><br><span class="line">Label_Even:</span><br><span class="line">    xor dx, dx  ; 将dx置0</span><br><span class="line">    mov bx, [BPB_BytesPerSec]  ; bx=512</span><br><span class="line">    div bx  ; ax/512=ax(FAT表中的偏移扇区号)...dx(在扇区中的位置)</span><br><span class="line">    push dx</span><br><span class="line">    mov bx, 8000h  ; es:bx=读取内容存放的缓冲区位置</span><br><span class="line">    add ax, SectorNumOfFAT1Start  ; ax=ax+1 得到该FAT表项的起始扇区号</span><br><span class="line">    mov cl, 2  ; 读取FAT表项所在的扇区，一次读两个，避免在边界发生错误，因为一个FAT表项可能跨越两个扇区</span><br><span class="line">    call Func_ReadOneSector</span><br><span class="line"></span><br><span class="line">    pop dx</span><br><span class="line">    add bx, dx  ; bx=bx+dx 缓冲区起始地址+要读的内容长度(在扇区中的位置)</span><br><span class="line">    mov ax, [es:bx]  ; 读出FAT表项内容到ax中</span><br><span class="line">    cmp byte [Odd], 1  ; 是不是奇数</span><br><span class="line">    jnz Label_Even_2  ; Odd != 1跳到Label_Even_2</span><br><span class="line">    shr ax, 4  ; ax右移四位 也就是0.5B 把属于前一个表项的部分移除掉</span><br><span class="line"></span><br><span class="line">Label_Even_2:</span><br><span class="line">    and ax, 0fffh  ; 只保留低12bit，也就是截取该FAT表项</span><br><span class="line">    pop bx</span><br><span class="line">    pop es</span><br><span class="line">    ret  ; 函数调用结束 返回调用位置 返回值AX=要找的FAT表项值</span><br></pre></td></tr></tbody></table></figure><p><strong>1 这里AX代表什么？</strong></p><p>作为参数的时候是当前FAT表项索引，作为返回值的时候是下一个表项号</p><p><strong>2 为啥要把ax放大1.5倍？</strong></p><p>因为FAT12文件系统的每个FAT表项占用12bit，即每3B存两个FAT表项，所以需要先根据表项号转化成占用字节数，通过字节数除以每扇区字节数可以得到偏移的扇区号，以及FAT表项在该扇区中的偏移位置，再根据这个扇区号往后面读取两个扇区，根据奇偶位处理表项错位问题，这样就能得到下一扇区的表项号。</p><h2 id="2-7-Other"><a href="#2-7-Other" class="headerlink" title="2.7 Other"></a>2.7 Other</h2><p>这就是一些定义一些变量常量什么的</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;=======    tmp variable</span><br><span class="line">RootDirSizeForLoop  dw  RootDirSectors</span><br><span class="line">SectorNo        dw  0</span><br><span class="line">Odd         db  0</span><br><span class="line"></span><br><span class="line">;=======    display messages</span><br><span class="line">StartBootMessage:   db  "Start Boot"</span><br><span class="line">NoLoaderMessage:    db  "ERROR:No LOADER Found"</span><br><span class="line">LoaderFileName:     db  "LOADER  BIN",0</span><br><span class="line"></span><br><span class="line">;=======    fill zero until whole sector</span><br><span class="line">    times   510 - ($ - $$)  db  0</span><br><span class="line">    dw  0xaa55</span><br></pre></td></tr></tbody></table></figure><p>NASM编译器中的单引号和双引号作用相同，并非C语言规定的双引号会在结尾添加字符<code>'\0'</code>，在NASM中必须自行添加</p><p>好了都解释完了，编译一下，并在qemu上跑一下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm boot.asm -o boot.bin -l boot.lst</span><br><span class="line">dd <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br><span class="line">qemu-system-x86_64 -drive file=boot.img,format=raw,<span class="keyword">if</span>=floppy</span><br></pre></td></tr></tbody></table></figure><p>启动效果是这个死样子</p><p><img alt="" data-src="https://gitee.com/SidneyGod/ImagePlace/raw/master/202110312044018.png"></p></body></html></div><div style="text-align:center;color:#636363;font-size:14px">------- This article is over <i class="fa fa-leaf" aria-hidden="true"></i> Thank you for your reading -------</div><div id="reward-container"><div>All I need is you needing me.</div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">Donate</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Sidney Ding WeChat Pay"><p>WeChat Pay</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Sidney Ding Alipay"><p>Alipay</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Sidney Ding</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://sidneygod.github.io/posts/1d4ddf18/" title="[Make MyOS] Find loader">https://sidneygod.github.io/posts/1d4ddf18/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/c0d78c8f/" rel="next" title="[Make MyOS] Make a boot"><i class="fa fa-chevron-left"></i> [Make MyOS] Make a boot</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/a4707db6/" rel="prev" title="[Make MyOS] Basic execution env & Interrupt">[Make MyOS] Basic execution env & Interrupt <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Catalogue</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-软盘与FAT12"><span class="nav-text">1 软盘与FAT12</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-boot-asm"><span class="nav-text">2 boot.asm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-FAT12文件系统数据"><span class="nav-text">2.1 FAT12文件系统数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-初始化"><span class="nav-text">2.2 初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-查找loader-bin文件"><span class="nav-text">2.3 查找loader.bin文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-加载扇区内容到内存"><span class="nav-text">2.4 加载扇区内容到内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-读取磁盘扇区模块"><span class="nav-text">2.5 读取磁盘扇区模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-FAT表项解析模块"><span class="nav-text">2.6 FAT表项解析模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-Other"><span class="nav-text">2.7 Other</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="#"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Sidney Ding"></a><p class="site-author-name" itemprop="name">Sidney Ding</p><div class="site-description" itemprop="description">You laugh at me for being different, but I laugh at you for being the same.</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">23</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/SidneyGod" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;SidneyGod" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:sidneyding183@gmail.com" title="E-Mail &amp;rarr; mailto:sidneyding183@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://google.com/" title="https:&#x2F;&#x2F;google.com" rel="noopener" target="_blank">Google</a></li><li class="links-of-blogroll-item"><a href="https://bing.com/" title="https:&#x2F;&#x2F;bing.com" rel="noopener" target="_blank">Bing</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Sidney Ding</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Symbols count total: </span><span title="Symbols count total">279k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">Reading time total &asymp;</span> <span title="Reading time total">7:44</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0</div><span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div><div><span><i class="fa fa-bomb"></i> </span><span id="showDays"></span></div><script>var seconds=1e3,minutes=60*seconds,hours=60*minutes,days=24*hours,years=365*days,birthDay=Date.UTC(2019,10,1,0,0,0);setInterval(function(){var e=(n=new Date).getFullYear(),s=n.getMonth()+1,t=n.getDate(),a=n.getHours(),o=n.getMinutes(),n=n.getSeconds(),s=Date.UTC(e,s,t,a,o,n)-birthDay,t=Math.floor(s/years),a=Math.floor(s/days-365*t),o=Math.floor((s-(365*t+a)*days)/hours),n=Math.floor((s-(365*t+a)*days-o*hours)/minutes),s=Math.floor((s-(365*t+a)*days-o*hours-n*minutes)/seconds);document.getElementById("showDays").innerHTML="This website has been running for "+t+" years, "+a+" days, "+o+" hours, "+n+" minutes, "+s+" seconds"},1e3)</script></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.4.1.js"></script><script src="/js/motion.js?v=7.4.1.js"></script><script src="/js/schemes/pisces.js?v=7.4.1.js"></script><script src="/js/next-boot.js?v=7.4.1.js"></script><script src="/js/bookmark.js?v=7.4.1.js"></script><script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script><script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js"></script><script src="/js/local-search.js?v=7.4.1.js"></script><script>document.querySelectorAll("div.pdf").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js",()=>{document.querySelectorAll("div.pdf").forEach(e=>{PDFObject.embed(e.getAttribute("target"),e,{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:e.getAttribute("height")||"500px"})})},window.PDFObject)</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });</script><script>NexT.utils.getScript("//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML",()=>{MathJax.Hub.Typeset()},window.MathJax)</script><script>NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],i="nick,mail,link".split(",").filter(i=>e.includes(i));new Valine({el:"#comments",verify:!0,notify:!1,appId:"IJiDbg4VAiIeDsIj4MBo39Hq-gzGzoHsz",appKey:"0osu23DWjzCzrIVH4Ybe3ihh",placeholder:"Just go go",avatar:"monsterid",meta:i,pageSize:"10",visitor:!1,lang:"en",path:location.pathname,recordIP:!0,serverURLs:""})},window.Valine)</script><script src="/js/snowflakes.min.js"></script><script>new Snowflakes({color:"rgba(129, 161, 193, 0.87)"})</script><script async src="/js/love.js"></script><script async src="/js/fireworks.js"></script><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~"+OriginTitile,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><script src="/js/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script></body></html>